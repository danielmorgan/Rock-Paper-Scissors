(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
(function (global){

/*
 * Konva JavaScript Framework v0.10.0
 * http://konvajs.github.io/
 * Licensed under the MIT or GPL Version 2 licenses.
 * Date: Tue Oct 27 2015
 *
 * Original work Copyright (C) 2011 - 2013 by Eric Rowell (KineticJS)
 * Modified work Copyright (C) 2014 - 2015 by Anton Lavrenov (Konva)
 *
 * @license
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @namespace Konva
 */
var Konva = {};
(function(root) {
    'use strict';
    var PI_OVER_180 = Math.PI / 180;

    Konva = {
        // public
        version: '0.10.0',

        // private
        stages: [],
        idCounter: 0,
        ids: {},
        names: {},
        shapes: {},
        listenClickTap: false,
        inDblClickWindow: false,

        // configurations
        enableTrace: false,
        traceArrMax: 100,
        dblClickWindow: 400,
        /**
         * Global pixel ratio configuration. KonvaJS automatically detect pixel ratio of current device.
         * But you may override such property, if you want to use your value.
         * @property pixelRatio
         * @default undefined
         * @memberof Konva
         * @example
         * Konva.pixelRatio = 1;
         */
        pixelRatio: undefined,
        /**
         * Drag distance property. If you start to drag a node you may want to wait until pointer is moved to some distance from start point,
         * only then start dragging.
         * @property dragDistance
         * @default 0
         * @memberof Konva
         * @example
         * Konva.dragDistance = 10;
         */
        dragDistance: 0,
        /**
         * Use degree values for angle properties. You may set this property to false if you want to use radiant values.
         * @property angleDeg
         * @default true
         * @memberof Konva
         * @example
         * node.rotation(45); // 45 degrees
         * Konva.angleDeg = false;
         * node.rotation(Math.PI / 2); // PI/2 radian
         */
        angleDeg: true,
         /**
         * Show different warnings about errors or wrong API usage
         * @property showWarnings
         * @default true
         * @memberof Konva
         * @example
         * Konva.showWarnings = false;
         */
        showWarnings: true,



        /**
         * @namespace Filters
         * @memberof Konva
         */
        Filters: {},

        /**
         * returns whether or not drag and drop is currently active
         * @method
         * @memberof Konva
         */
        isDragging: function() {
            var dd = Konva.DD;

            // if DD is not included with the build, then
            // drag and drop is not even possible
            if (dd) {
                return dd.isDragging;
            }
            return false;
        },
        /**
        * returns whether or not a drag and drop operation is ready, but may
        *  not necessarily have started
        * @method
        * @memberof Konva
        */
        isDragReady: function() {
            var dd = Konva.DD;

            // if DD is not included with the build, then
            // drag and drop is not even possible
            if (dd) {
                return !!dd.node;
            }
            return false;
        },
        _addId: function(node, id) {
            if(id !== undefined) {
                this.ids[id] = node;
            }
        },
        _removeId: function(id) {
            if(id !== undefined) {
                delete this.ids[id];
            }
        },
        _addName: function(node, name) {
            if(name) {
                if(!this.names[name]) {
                    this.names[name] = [];
                }
                this.names[name].push(node);
            }
        },
        _removeName: function(name, _id) {
            if(!name) {
                return;
            }
            var nodes = this.names[name];
            if(!nodes) {
                return;
            }
            for(var n = 0; n < nodes.length; n++) {
                var no = nodes[n];
                if(no._id === _id) {
                    nodes.splice(n, 1);
                }
            }
            if(nodes.length === 0) {
                delete this.names[name];
            }
        },
        getAngle: function(angle) {
            return this.angleDeg ? angle * PI_OVER_180 : angle;
        },
        _parseUA: function(userAgent) {
            var ua = userAgent.toLowerCase(),
                // jQuery UA regex
                match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
                /(webkit)[ \/]([\w.]+)/.exec( ua ) ||
                /(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
                /(msie) ([\w.]+)/.exec( ua ) ||
                ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
                [],

                // adding mobile flag as well
                mobile = !!(userAgent.match(/Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile/i)),
                ieMobile = !!(userAgent.match(/IEMobile/i));

            return {
                browser: match[ 1 ] || '',
                version: match[ 2 ] || '0',

                // adding mobile flab
                mobile: mobile,
                ieMobile: ieMobile  // If this is true (i.e., WP8), then Konva touch events are executed instead of equivalent Konva mouse events
            };
        },
        // user agent
        UA: undefined
    };

    Konva.UA = Konva._parseUA((root.navigator && root.navigator.userAgent) || '');

})(this);

// Uses Node, AMD or browser globals to create a module.

// If you want something that will work in other stricter CommonJS environments,
// or if you need to create a circular dependency, see commonJsStrict.js

// Defines a module "returnExports" that depends another module called "b".
// Note that the name of the module is implied by the file name. It is best
// if the file name and the exported global have matching names.

// If the 'b' module also uses this type of boilerplate, then
// in the browser, it will create a global .b that is used below.

// If you do not want to support the browser global path, then you
// can remove the `root` use and the passing `this` as the first arg to
// the top function.

// if the module has no dependencies, the above pattern can be simplified to
( function(root, factory) {
    'use strict';
    if( typeof exports === 'object') {
        var KonvaJS = factory();
        // runtime-check for browserify and nw.js (node-webkit)
        if(global.window && global.window.document) {
            Konva.document = global.window.document;
            Konva.window = global.window;
        } else {
            // Node. Does not work with strict CommonJS, but
            // only CommonJS-like enviroments that support module.exports,
            // like Node.
            var Canvas = require('canvas');
            var jsdom = require('jsdom').jsdom;

            Konva.document = jsdom('<!DOCTYPE html><html><head></head><body></body></html>');
            Konva.window = Konva.document.parentWindow;
            Konva.window.Image = Canvas.Image;
            Konva._nodeCanvas = Canvas;
        }

        Konva.root = root;
        module.exports = KonvaJS;
        return;
    }
    else if( typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory);
    }
    Konva.document = document;
    Konva.window = window;
    Konva.root = root;
}(this, function() {
    'use strict';
    // Just return a value to define the module export.
    // This example returns an object, but the module
    // can return a function as the exported value.
    return Konva;
}));

/*eslint-disable  eqeqeq, no-cond-assign, no-empty*/
(function() {
    'use strict';
    /**
     * Collection constructor.  Collection extends
     *  Array.  This class is used in conjunction with {@link Konva.Container#get}
     * @constructor
     * @memberof Konva
     */
    Konva.Collection = function() {
        var args = [].slice.call(arguments), length = args.length, i = 0;

        this.length = length;
        for(; i < length; i++) {
            this[i] = args[i];
        }
        return this;
    };
    Konva.Collection.prototype = [];
    /**
     * iterate through node array and run a function for each node.
     *  The node and index is passed into the function
     * @method
     * @memberof Konva.Collection.prototype
     * @param {Function} func
     * @example
     * // get all nodes with name foo inside layer, and set x to 10 for each
     * layer.get('.foo').each(function(shape, n) {
     *   shape.setX(10);
     * });
     */
    Konva.Collection.prototype.each = function(func) {
        for(var n = 0; n < this.length; n++) {
            func(this[n], n);
        }
    };
    /**
     * convert collection into an array
     * @method
     * @memberof Konva.Collection.prototype
     */
    Konva.Collection.prototype.toArray = function() {
        var arr = [],
            len = this.length,
            n;

        for(n = 0; n < len; n++) {
            arr.push(this[n]);
        }
        return arr;
    };
    /**
     * convert array into a collection
     * @method
     * @memberof Konva.Collection
     * @param {Array} arr
     */
    Konva.Collection.toCollection = function(arr) {
        var collection = new Konva.Collection(),
            len = arr.length,
            n;

        for(n = 0; n < len; n++) {
            collection.push(arr[n]);
        }
        return collection;
    };

    // map one method by it's name
    Konva.Collection._mapMethod = function(methodName) {
        Konva.Collection.prototype[methodName] = function() {
            var len = this.length,
                i;

            var args = [].slice.call(arguments);
            for(i = 0; i < len; i++) {
                this[i][methodName].apply(this[i], args);
            }

            return this;
        };
    };

    Konva.Collection.mapMethods = function(constructor) {
        var prot = constructor.prototype;
        for(var methodName in prot) {
            Konva.Collection._mapMethod(methodName);
        }
    };

    /*
    * Last updated November 2011
    * By Simon Sarris
    * www.simonsarris.com
    * sarris@acm.org
    *
    * Free to use and distribute at will
    * So long as you are nice to people, etc
    */

    /*
    * The usage of this class was inspired by some of the work done by a forked
    * project, KineticJS-Ext by Wappworks, which is based on Simon's Transform
    * class.  Modified by Eric Rowell
    */

    /**
     * Transform constructor
     * @constructor
     * @param {Array} [m] Optional six-element matrix
     * @memberof Konva
     */
    Konva.Transform = function(m) {
        this.m = (m && m.slice()) || [1, 0, 0, 1, 0, 0];
    };

    Konva.Transform.prototype = {
        /**
         * Copy Konva.Transform object
         * @method
         * @memberof Konva.Transform.prototype
         * @returns {Konva.Transform}
         */
        copy: function() {
            return new Konva.Transform(this.m);
        },
        /**
         * Transform point
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Object} point 2D point(x, y)
         * @returns {Object} 2D point(x, y)
         */
        point: function(point) {
            var m = this.m;
            return {
                x: m[0] * point.x + m[2] * point.y + m[4],
                y: m[1] * point.x + m[3] * point.y + m[5]
            };
        },
        /**
         * Apply translation
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Number} x
         * @param {Number} y
         * @returns {Konva.Transform}
         */
        translate: function(x, y) {
            this.m[4] += this.m[0] * x + this.m[2] * y;
            this.m[5] += this.m[1] * x + this.m[3] * y;
            return this;
        },
        /**
         * Apply scale
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Number} sx
         * @param {Number} sy
         * @returns {Konva.Transform}
         */
        scale: function(sx, sy) {
            this.m[0] *= sx;
            this.m[1] *= sx;
            this.m[2] *= sy;
            this.m[3] *= sy;
            return this;
        },
        /**
         * Apply rotation
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Number} rad  Angle in radians
         * @returns {Konva.Transform}
         */
        rotate: function(rad) {
            var c = Math.cos(rad);
            var s = Math.sin(rad);
            var m11 = this.m[0] * c + this.m[2] * s;
            var m12 = this.m[1] * c + this.m[3] * s;
            var m21 = this.m[0] * -s + this.m[2] * c;
            var m22 = this.m[1] * -s + this.m[3] * c;
            this.m[0] = m11;
            this.m[1] = m12;
            this.m[2] = m21;
            this.m[3] = m22;
            return this;
        },
        /**
         * Returns the translation
         * @method
         * @memberof Konva.Transform.prototype
         * @returns {Object} 2D point(x, y)
         */
        getTranslation: function() {
            return {
                x: this.m[4],
                y: this.m[5]
            };
        },
        /**
         * Apply skew
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Number} sx
         * @param {Number} sy
         * @returns {Konva.Transform}
         */
        skew: function(sx, sy) {
            var m11 = this.m[0] + this.m[2] * sy;
            var m12 = this.m[1] + this.m[3] * sy;
            var m21 = this.m[2] + this.m[0] * sx;
            var m22 = this.m[3] + this.m[1] * sx;
            this.m[0] = m11;
            this.m[1] = m12;
            this.m[2] = m21;
            this.m[3] = m22;
            return this;
         },
        /**
         * Transform multiplication
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Konva.Transform} matrix
         * @returns {Konva.Transform}
         */
        multiply: function(matrix) {
            var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
            var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];

            var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
            var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];

            var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
            var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];

            this.m[0] = m11;
            this.m[1] = m12;
            this.m[2] = m21;
            this.m[3] = m22;
            this.m[4] = dx;
            this.m[5] = dy;
            return this;
        },
        /**
         * Invert the matrix
         * @method
         * @memberof Konva.Transform.prototype
         * @returns {Konva.Transform}
         */
        invert: function() {
            var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
            var m0 = this.m[3] * d;
            var m1 = -this.m[1] * d;
            var m2 = -this.m[2] * d;
            var m3 = this.m[0] * d;
            var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
            var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
            this.m[0] = m0;
            this.m[1] = m1;
            this.m[2] = m2;
            this.m[3] = m3;
            this.m[4] = m4;
            this.m[5] = m5;
            return this;
        },
        /**
         * return matrix
         * @method
         * @memberof Konva.Transform.prototype
         */
        getMatrix: function() {
            return this.m;
        },
        /**
         * set to absolute position via translation
         * @method
         * @memberof Konva.Transform.prototype
         * @returns {Konva.Transform}
         * @author ericdrowell
         */
        setAbsolutePosition: function(x, y) {
            var m0 = this.m[0],
                m1 = this.m[1],
                m2 = this.m[2],
                m3 = this.m[3],
                m4 = this.m[4],
                m5 = this.m[5],
                yt = ((m0 * (y - m5)) - (m1 * (x - m4))) / ((m0 * m3) - (m1 * m2)),
                xt = (x - m4 - (m2 * yt)) / m0;

            return this.translate(xt, yt);
        }
    };

    // CONSTANTS
    var CONTEXT_2D = '2d',
        OBJECT_ARRAY = '[object Array]',
        OBJECT_NUMBER = '[object Number]',
        OBJECT_STRING = '[object String]',
        PI_OVER_DEG180 = Math.PI / 180,
        DEG180_OVER_PI = 180 / Math.PI,
        HASH = '#',
        EMPTY_STRING = '',
        ZERO = '0',
        KONVA_WARNING = 'Konva warning: ',
        KONVA_ERROR = 'Konva error: ',
        RGB_PAREN = 'rgb(',
        COLORS = {
            aliceblue: [240, 248, 255],
            antiquewhite: [250, 235, 215],
            aqua: [0, 255, 255],
            aquamarine: [127, 255, 212],
            azure: [240, 255, 255],
            beige: [245, 245, 220],
            bisque: [255, 228, 196],
            black: [0, 0, 0],
            blanchedalmond: [255, 235, 205],
            blue: [0, 0, 255],
            blueviolet: [138, 43, 226],
            brown: [165, 42, 42],
            burlywood: [222, 184, 135],
            cadetblue: [95, 158, 160],
            chartreuse: [127, 255, 0],
            chocolate: [210, 105, 30],
            coral: [255, 127, 80],
            cornflowerblue: [100, 149, 237],
            cornsilk: [255, 248, 220],
            crimson: [220, 20, 60],
            cyan: [0, 255, 255],
            darkblue: [0, 0, 139],
            darkcyan: [0, 139, 139],
            darkgoldenrod: [184, 132, 11],
            darkgray: [169, 169, 169],
            darkgreen: [0, 100, 0],
            darkgrey: [169, 169, 169],
            darkkhaki: [189, 183, 107],
            darkmagenta: [139, 0, 139],
            darkolivegreen: [85, 107, 47],
            darkorange: [255, 140, 0],
            darkorchid: [153, 50, 204],
            darkred: [139, 0, 0],
            darksalmon: [233, 150, 122],
            darkseagreen: [143, 188, 143],
            darkslateblue: [72, 61, 139],
            darkslategray: [47, 79, 79],
            darkslategrey: [47, 79, 79],
            darkturquoise: [0, 206, 209],
            darkviolet: [148, 0, 211],
            deeppink: [255, 20, 147],
            deepskyblue: [0, 191, 255],
            dimgray: [105, 105, 105],
            dimgrey: [105, 105, 105],
            dodgerblue: [30, 144, 255],
            firebrick: [178, 34, 34],
            floralwhite: [255, 255, 240],
            forestgreen: [34, 139, 34],
            fuchsia: [255, 0, 255],
            gainsboro: [220, 220, 220],
            ghostwhite: [248, 248, 255],
            gold: [255, 215, 0],
            goldenrod: [218, 165, 32],
            gray: [128, 128, 128],
            green: [0, 128, 0],
            greenyellow: [173, 255, 47],
            grey: [128, 128, 128],
            honeydew: [240, 255, 240],
            hotpink: [255, 105, 180],
            indianred: [205, 92, 92],
            indigo: [75, 0, 130],
            ivory: [255, 255, 240],
            khaki: [240, 230, 140],
            lavender: [230, 230, 250],
            lavenderblush: [255, 240, 245],
            lawngreen: [124, 252, 0],
            lemonchiffon: [255, 250, 205],
            lightblue: [173, 216, 230],
            lightcoral: [240, 128, 128],
            lightcyan: [224, 255, 255],
            lightgoldenrodyellow: [250, 250, 210],
            lightgray: [211, 211, 211],
            lightgreen: [144, 238, 144],
            lightgrey: [211, 211, 211],
            lightpink: [255, 182, 193],
            lightsalmon: [255, 160, 122],
            lightseagreen: [32, 178, 170],
            lightskyblue: [135, 206, 250],
            lightslategray: [119, 136, 153],
            lightslategrey: [119, 136, 153],
            lightsteelblue: [176, 196, 222],
            lightyellow: [255, 255, 224],
            lime: [0, 255, 0],
            limegreen: [50, 205, 50],
            linen: [250, 240, 230],
            magenta: [255, 0, 255],
            maroon: [128, 0, 0],
            mediumaquamarine: [102, 205, 170],
            mediumblue: [0, 0, 205],
            mediumorchid: [186, 85, 211],
            mediumpurple: [147, 112, 219],
            mediumseagreen: [60, 179, 113],
            mediumslateblue: [123, 104, 238],
            mediumspringgreen: [0, 250, 154],
            mediumturquoise: [72, 209, 204],
            mediumvioletred: [199, 21, 133],
            midnightblue: [25, 25, 112],
            mintcream: [245, 255, 250],
            mistyrose: [255, 228, 225],
            moccasin: [255, 228, 181],
            navajowhite: [255, 222, 173],
            navy: [0, 0, 128],
            oldlace: [253, 245, 230],
            olive: [128, 128, 0],
            olivedrab: [107, 142, 35],
            orange: [255, 165, 0],
            orangered: [255, 69, 0],
            orchid: [218, 112, 214],
            palegoldenrod: [238, 232, 170],
            palegreen: [152, 251, 152],
            paleturquoise: [175, 238, 238],
            palevioletred: [219, 112, 147],
            papayawhip: [255, 239, 213],
            peachpuff: [255, 218, 185],
            peru: [205, 133, 63],
            pink: [255, 192, 203],
            plum: [221, 160, 203],
            powderblue: [176, 224, 230],
            purple: [128, 0, 128],
            rebeccapurple: [102, 51, 153],
            red: [255, 0, 0],
            rosybrown: [188, 143, 143],
            royalblue: [65, 105, 225],
            saddlebrown: [139, 69, 19],
            salmon: [250, 128, 114],
            sandybrown: [244, 164, 96],
            seagreen: [46, 139, 87],
            seashell: [255, 245, 238],
            sienna: [160, 82, 45],
            silver: [192, 192, 192],
            skyblue: [135, 206, 235],
            slateblue: [106, 90, 205],
            slategray: [119, 128, 144],
            slategrey: [119, 128, 144],
            snow: [255, 255, 250],
            springgreen: [0, 255, 127],
            steelblue: [70, 130, 180],
            tan: [210, 180, 140],
            teal: [0, 128, 128],
            thistle: [216, 191, 216],
            transparent: [255, 255, 255, 0],
            tomato: [255, 99, 71],
            turquoise: [64, 224, 208],
            violet: [238, 130, 238],
            wheat: [245, 222, 179],
            white: [255, 255, 255],
            whitesmoke: [245, 245, 245],
            yellow: [255, 255, 0],
            yellowgreen: [154, 205, 5]
        },

        RGB_REGEX = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/;

    /**
     * @namespace Util
     * @memberof Konva
     */
    Konva.Util = {
        /*
         * cherry-picked utilities from underscore.js
         */
        _isElement: function(obj) {
            return !!(obj && obj.nodeType == 1);
        },
        _isFunction: function(obj) {
            return !!(obj && obj.constructor && obj.call && obj.apply);
        },
        _isObject: function(obj) {
            return (!!obj && obj.constructor === Object);
        },
        _isArray: function(obj) {
            return Object.prototype.toString.call(obj) === OBJECT_ARRAY;
        },
        _isNumber: function(obj) {
            return Object.prototype.toString.call(obj) === OBJECT_NUMBER;
        },
        _isString: function(obj) {
            return Object.prototype.toString.call(obj) === OBJECT_STRING;
        },
        // Returns a function, that, when invoked, will only be triggered at most once
        // during a given window of time. Normally, the throttled function will run
        // as much as it can, without ever going more than once per `wait` duration;
        // but if you'd like to disable the execution on the leading edge, pass
        // `{leading: false}`. To disable execution on the trailing edge, ditto.
        _throttle: function(func, wait, opts) {
            var context, args, result;
            var timeout = null;
            var previous = 0;
            var options = opts || {};
            var later = function() {
                previous = options.leading === false ? 0 : new Date().getTime();
                timeout = null;
                result = func.apply(context, args);
                context = args = null;
            };
            return function() {
                var now = new Date().getTime();
                if (!previous && options.leading === false) {
                    previous = now;
                }
                var remaining = wait - (now - previous);
                context = this;
                args = arguments;
                if (remaining <= 0) {
                  clearTimeout(timeout);
                  timeout = null;
                  previous = now;
                  result = func.apply(context, args);
                  context = args = null;
                } else if (!timeout && options.trailing !== false) {
                  timeout = setTimeout(later, remaining);
                }
                return result;
            };
        },
        /*
         * other utils
         */
        _hasMethods: function(obj) {
            var names = [],
                key;

            for(key in obj) {
                if (!obj.hasOwnProperty(key)) {
                    continue;
                }
                if(this._isFunction(obj[key])) {
                    names.push(key);
                }
            }
            return names.length > 0;
        },
        createCanvasElement: function() {
            var canvas = Konva.document.createElement('canvas');
            // on some environments canvas.style is readonly
            try {
                canvas.style = canvas.style || {};
            } catch (e) {
            }
            return canvas;
        },
        isBrowser: function() {
            return (typeof exports !== 'object');
        },
        _isInDocument: function(el) {
            while(el = el.parentNode) {
                if(el == Konva.document) {
                    return true;
                }
            }
            return false;
        },
        _simplifyArray: function(arr) {
            var retArr = [],
                len = arr.length,
                util = Konva.Util,
                n, val;

            for (n = 0; n < len; n++) {
                val = arr[n];
                if (util._isNumber(val)) {
                    val = Math.round(val * 1000) / 1000;
                }
                else if (!util._isString(val)) {
                    val = val.toString();
                }

                retArr.push(val);
            }

            return retArr;
        },
        /*
         * arg can be an image object or image data
         */
        _getImage: function(arg, callback) {
            var imageObj, canvas;

            // if arg is null or undefined
            if(!arg) {
                callback(null);
            }

            // if arg is already an image object
            else if(this._isElement(arg)) {
                callback(arg);
            }

            // if arg is a string, then it's a data url
            else if(this._isString(arg)) {
                imageObj = new Konva.window.Image();
                imageObj.onload = function() {
                    callback(imageObj);
                };
                imageObj.src = arg;
            }

            //if arg is an object that contains the data property, it's an image object
            else if(arg.data) {
                canvas = Konva.Util.createCanvasElement();
                canvas.width = arg.width;
                canvas.height = arg.height;
                var _context = canvas.getContext(CONTEXT_2D);
                _context.putImageData(arg, 0, 0);
                this._getImage(canvas.toDataURL(), callback);
            }
            else {
                callback(null);
            }
        },
        _getRGBAString: function(obj) {
            var red = obj.red || 0,
                green = obj.green || 0,
                blue = obj.blue || 0,
                alpha = obj.alpha || 1;

            return [
                'rgba(',
                red,
                ',',
                green,
                ',',
                blue,
                ',',
                alpha,
                ')'
            ].join(EMPTY_STRING);
        },
        _rgbToHex: function(r, g, b) {
            return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        },
        _hexToRgb: function(hex) {
            hex = hex.replace(HASH, EMPTY_STRING);
            var bigint = parseInt(hex, 16);
            return {
                r: (bigint >> 16) & 255,
                g: (bigint >> 8) & 255,
                b: bigint & 255
            };
        },
        /**
         * return random hex color
         * @method
         * @memberof Konva.Util.prototype
         */
        getRandomColor: function() {
            var randColor = (Math.random() * 0xFFFFFF << 0).toString(16);
            while (randColor.length < 6) {
                randColor = ZERO + randColor;
            }
            return HASH + randColor;
        },
        /**
         * return value with default fallback
         * @method
         * @memberof Konva.Util.prototype
         */
        get: function(val, def) {
            if (val === undefined) {
                return def;
            }
            else {
                return val;
            }
        },
        /**
         * get RGB components of a color
         * @method
         * @memberof Konva.Util.prototype
         * @param {String} color
         * @example
         * // each of the following examples return {r:0, g:0, b:255}
         * var rgb = Konva.Util.getRGB('blue');
         * var rgb = Konva.Util.getRGB('#0000ff');
         * var rgb = Konva.Util.getRGB('rgb(0,0,255)');
         */
        getRGB: function(color) {
            var rgb;
            // color string
            if (color in COLORS) {
                rgb = COLORS[color];
                return {
                    r: rgb[0],
                    g: rgb[1],
                    b: rgb[2]
                };
            }
            // hex
            else if (color[0] === HASH) {
                return this._hexToRgb(color.substring(1));
            }
            // rgb string
            else if (color.substr(0, 4) === RGB_PAREN) {
                rgb = RGB_REGEX.exec(color.replace(/ /g, ''));
                return {
                    r: parseInt(rgb[1], 10),
                    g: parseInt(rgb[2], 10),
                    b: parseInt(rgb[3], 10)
                };
            }
            // default
            else {
                return {
                    r: 0,
                    g: 0,
                    b: 0
                };
            }
        },
        // convert any color string to RGBA object
        // from https://github.com/component/color-parser
        colorToRGBA: function(str) {
            str = str || 'black';
            return Konva.Util._namedColorToRBA(str)
                || Konva.Util._hex3ColorToRGBA(str)
                || Konva.Util._hex6ColorToRGBA(str)
                || Konva.Util._rgbColorToRGBA(str)
                || Konva.Util._rgbaColorToRGBA(str);
        },
        // Parse named css color. Like "green"
        _namedColorToRBA: function(str) {
            var c = COLORS[str.toLowerCase()];
            if (!c) {
                return null;
            }
            return {
                r: c[0],
                g: c[1],
                b: c[2],
                a: 1
            };
        },
        // Parse rgb(n, n, n)
        _rgbColorToRGBA: function(str) {
            if (str.indexOf('rgb(') === 0) {
                str = str.match(/rgb\(([^)]+)\)/)[1];
                var parts = str.split(/ *, */).map(Number);
                return {
                    r: parts[0],
                    g: parts[1],
                    b: parts[2],
                    a: 1
                };
            }
        },
        // Parse rgba(n, n, n, n)
        _rgbaColorToRGBA: function(str) {
            if (str.indexOf('rgba(') === 0) {
                str = str.match(/rgba\(([^)]+)\)/)[1];
                var parts = str.split(/ *, */).map(Number);
                return {
                    r: parts[0],
                    g: parts[1],
                    b: parts[2],
                    a: parts[3]
                };
            }

        },
        // Parse #nnnnnn
        _hex6ColorToRGBA: function(str) {
            if ((str[0] === '#') && (str.length === 7)) {
                return {
                    r: parseInt(str.slice(1, 3), 16),
                    g: parseInt(str.slice(3, 5), 16),
                    b: parseInt(str.slice(5, 7), 16),
                    a: 1
                };
            }
        },
        // Parse #nnn
        _hex3ColorToRGBA: function(str) {
            if ((str[0] === '#') && (str.length === 4)) {
                return {
                    r: parseInt(str[1] + str[1], 16),
                    g: parseInt(str[2] + str[2], 16),
                    b: parseInt(str[3] + str[3], 16),
                    a: 1
                };
            }
        },
        // o1 takes precedence over o2
        _merge: function(o1, o2) {
            var retObj = this._clone(o2);
            for(var key in o1) {
                if(this._isObject(o1[key])) {
                    retObj[key] = this._merge(o1[key], retObj[key]);
                }
                else {
                    retObj[key] = o1[key];
                }
            }
            return retObj;
        },
        cloneObject: function(obj) {
            var retObj = {};
            for(var key in obj) {
                if(this._isObject(obj[key])) {
                    retObj[key] = this.cloneObject(obj[key]);
                }
                else if (this._isArray(obj[key])) {
                    retObj[key] = this.cloneArray(obj[key]);
                } else {
                    retObj[key] = obj[key];
                }
            }
            return retObj;
        },
        cloneArray: function(arr) {
            return arr.slice(0);
        },
        _degToRad: function(deg) {
            return deg * PI_OVER_DEG180;
        },
        _radToDeg: function(rad) {
            return rad * DEG180_OVER_PI;
        },
        _capitalize: function(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        },
        throw: function(str) {
            throw new Error(KONVA_ERROR + str);
        },
        error: function(str) {
          console.error(KONVA_ERROR + str);
        },
        warn: function(str) {
            /*
             * IE9 on Windows7 64bit will throw a JS error
             * if we don't use window.console in the conditional
             */
            if(Konva.root.console && console.warn && Konva.showWarnings) {
                console.warn(KONVA_WARNING + str);
            }
        },
        extend: function(child, parent) {
            function Ctor() {
                this.constructor = child;
            }
            Ctor.prototype = parent.prototype;
            var oldProto = child.prototype;
            child.prototype = new Ctor();
            for (var key in oldProto) {
                if (oldProto.hasOwnProperty(key)) {
                    child.prototype[key] = oldProto[key];
                }
            }
            child.__super__ = parent.prototype;
            // create reference to parent
            child.super = parent;
        },
        /**
         * adds methods to a constructor prototype
         * @method
         * @memberof Konva.Util.prototype
         * @param {Function} constructor
         * @param {Object} methods
         */
        addMethods: function(constructor, methods) {
            var key;

            for (key in methods) {
                constructor.prototype[key] = methods[key];
            }
        },
        _getControlPoints: function(x0, y0, x1, y1, x2, y2, t) {
            var d01 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2)),
                d12 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)),
                fa = t * d01 / (d01 + d12),
                fb = t * d12 / (d01 + d12),
                p1x = x1 - fa * (x2 - x0),
                p1y = y1 - fa * (y2 - y0),
                p2x = x1 + fb * (x2 - x0),
                p2y = y1 + fb * (y2 - y0);

            return [p1x, p1y, p2x, p2y];
        },
        _expandPoints: function(p, tension) {
            var len = p.length,
                allPoints = [],
                n, cp;

            for (n = 2; n < len - 2; n += 2) {
                cp = Konva.Util._getControlPoints(p[n - 2], p[n - 1], p[n], p[n + 1], p[n + 2], p[n + 3], tension);
                allPoints.push(cp[0]);
                allPoints.push(cp[1]);
                allPoints.push(p[n]);
                allPoints.push(p[n + 1]);
                allPoints.push(cp[2]);
                allPoints.push(cp[3]);
            }

            return allPoints;
        },
        _removeLastLetter: function(str) {
            return str.substring(0, str.length - 1);
        },
        each: function(obj, func) {
            for (var key in obj) {
                func(key, obj[key]);
            }
        },
        _getProjectionToSegment: function(x1, y1, x2, y2, x3, y3) {
            var x, y, dist;

            var pd2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
            if(pd2 == 0) {
                x = x1;
                y = y1;
                dist = (x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2);
            } else {
                var u = ((x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1)) / pd2;
                if(u < 0) {
                    x = x1;
                    y = y1;
                    dist = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3);
                } else if (u > 1.0) {
                    x = x2;
                    y = y2;
                    dist = (x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3);
                } else {
                    x = x1 + u * (x2 - x1);
                    y = y1 + u * (y2 - y1);
                    dist = (x - x3) * (x - x3) + (y - y3) * (y - y3);
                }
            }
            return [x, y, dist];
        },
        // line as array of points.
        // line might be closed
        _getProjectionToLine: function(pt, line, isClosed) {
            var pc = Konva.Util.cloneObject(pt);
            var dist = Number.MAX_VALUE;
            line.forEach(function(p1, i) {
                if (!isClosed && i === line.length - 1) {
                    return;
                }
                var p2 = line[(i + 1) % line.length];
                var proj = Konva.Util._getProjectionToSegment(p1.x, p1.y, p2.x, p2.y, pt.x, pt.y);
                var px = proj[0], py = proj[1], pdist = proj[2];
                if (pdist < dist) {
                    pc.x = px;
                    pc.y = py;
                    dist = pdist;
                }
            });
            return pc;
        },
        _prepareArrayForTween: function(startArray, endArray, isClosed) {
            var n, start = [], end = [];
            if (startArray.length > endArray.length) {
                var temp = endArray;
                endArray = startArray;
                startArray = temp;
            }
            for (n = 0; n < startArray.length; n += 2) {
                start.push({
                    x: startArray[n],
                    y: startArray[n + 1]
                });
            }
            for (n = 0; n < endArray.length; n += 2) {
                end.push({
                    x: endArray[n],
                    y: endArray[n + 1]
                });
            }


            var newStart = [];
            end.forEach(function(point) {
                var pr = Konva.Util._getProjectionToLine(point, start, isClosed);
                newStart.push(pr.x);
                newStart.push(pr.y);
            });
            return newStart;
        }
    };
})();

(function() {
    'use strict';
    // calculate pixel ratio
    var canvas = Konva.Util.createCanvasElement(),
        context = canvas.getContext('2d'),
        _pixelRatio = (function(){
            var devicePixelRatio = Konva.window.devicePixelRatio || 1,
            backingStoreRatio = context.webkitBackingStorePixelRatio
                || context.mozBackingStorePixelRatio
                || context.msBackingStorePixelRatio
                || context.oBackingStorePixelRatio
                || context.backingStorePixelRatio
                || 1;
            return devicePixelRatio / backingStoreRatio;
        })();

    /**
     * Canvas Renderer constructor
     * @constructor
     * @abstract
     * @memberof Konva
     * @param {Object} config
     * @param {Number} config.width
     * @param {Number} config.height
     * @param {Number} config.pixelRatio KonvaJS automatically handles pixel ratio adjustments in order to render crisp drawings
     *  on all devices. Most desktops, low end tablets, and low end phones, have device pixel ratios
     *  of 1.  Some high end tablets and phones, like iPhones and iPads (not the mini) have a device pixel ratio
     *  of 2.  Some Macbook Pros, and iMacs also have a device pixel ratio of 2.  Some high end Android devices have pixel
     *  ratios of 2 or 3.  Some browsers like Firefox allow you to configure the pixel ratio of the viewport.  Unless otherwise
     *  specified, the pixel ratio will be defaulted to the actual device pixel ratio.  You can override the device pixel
     *  ratio for special situations, or, if you don't want the pixel ratio to be taken into account, you can set it to 1.
     */
    Konva.Canvas = function(config) {
        this.init(config);
    };

    Konva.Canvas.prototype = {
        init: function(config) {
            var conf = config || {};

            var pixelRatio = conf.pixelRatio || Konva.pixelRatio || _pixelRatio;

            this.pixelRatio = pixelRatio;
            this._canvas = Konva.Util.createCanvasElement();

            // set inline styles
            this._canvas.style.padding = 0;
            this._canvas.style.margin = 0;
            this._canvas.style.border = 0;
            this._canvas.style.background = 'transparent';
            this._canvas.style.position = 'absolute';
            this._canvas.style.top = 0;
            this._canvas.style.left = 0;
        },
        /**
         * get canvas context
         * @method
         * @memberof Konva.Canvas.prototype
         * @returns {CanvasContext} context
         */
        getContext: function() {
            return this.context;
        },
        /**
         * get pixel ratio
         * @method
         * @memberof Konva.Canvas.prototype
         * @returns {Number} pixel ratio
         */
        getPixelRatio: function() {
            return this.pixelRatio;
        },
        /**
         * get pixel ratio
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {Number} pixelRatio KonvaJS automatically handles pixel ratio adustments in order to render crisp drawings
         *  on all devices. Most desktops, low end tablets, and low end phones, have device pixel ratios
         *  of 1.  Some high end tablets and phones, like iPhones and iPads have a device pixel ratio
         *  of 2.  Some Macbook Pros, and iMacs also have a device pixel ratio of 2.  Some high end Android devices have pixel
         *  ratios of 2 or 3.  Some browsers like Firefox allow you to configure the pixel ratio of the viewport.  Unless otherwise
         *  specificed, the pixel ratio will be defaulted to the actual device pixel ratio.  You can override the device pixel
         *  ratio for special situations, or, if you don't want the pixel ratio to be taken into account, you can set it to 1.
         */
        setPixelRatio: function(pixelRatio) {
            var previousRatio = this.pixelRatio;
            this.pixelRatio = pixelRatio;
            this.setSize(this.getWidth() / previousRatio, this.getHeight() / previousRatio);
        },
        /**
         * set width
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {Number} width
         */
        setWidth: function(width) {
            // take into account pixel ratio
            this.width = this._canvas.width = width * this.pixelRatio;
            this._canvas.style.width = width + 'px';

            var pixelRatio = this.pixelRatio,
                _context = this.getContext()._context;
            _context.scale(pixelRatio, pixelRatio);
        },
        /**
         * set height
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {Number} height
         */
        setHeight: function(height) {
            // take into account pixel ratio
            this.height = this._canvas.height = height * this.pixelRatio;
            this._canvas.style.height = height + 'px';
            var pixelRatio = this.pixelRatio,
                _context = this.getContext()._context;
            _context.scale(pixelRatio, pixelRatio);
        },
        /**
         * get width
         * @method
         * @memberof Konva.Canvas.prototype
         * @returns {Number} width
         */
        getWidth: function() {
            return this.width;
        },
        /**
         * get height
         * @method
         * @memberof Konva.Canvas.prototype
         * @returns {Number} height
         */
        getHeight: function() {
            return this.height;
        },
        /**
         * set size
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {Number} width
         * @param {Number} height
         */
        setSize: function(width, height) {
            this.setWidth(width);
            this.setHeight(height);
        },
        /**
         * to data url
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {String} mimeType
         * @param {Number} quality between 0 and 1 for jpg mime types
         * @returns {String} data url string
         */
        toDataURL: function(mimeType, quality) {
            try {
                // If this call fails (due to browser bug, like in Firefox 3.6),
                // then revert to previous no-parameter image/png behavior
                return this._canvas.toDataURL(mimeType, quality);
            }
            catch(e) {
                try {
                    return this._canvas.toDataURL();
                }
                catch(err) {
                    Konva.Util.warn('Unable to get data URL. ' + err.message);
                    return '';
                }
            }
        }
    };

    Konva.SceneCanvas = function(config) {
        var conf = config || {};
        var width = conf.width || 0,
            height = conf.height || 0;

        Konva.Canvas.call(this, conf);
        this.context = new Konva.SceneContext(this);
        this.setSize(width, height);
    };

    Konva.Util.extend(Konva.SceneCanvas, Konva.Canvas);

    Konva.HitCanvas = function(config) {
        var conf = config || {};
        var width = conf.width || 0,
            height = conf.height || 0;

        Konva.Canvas.call(this, conf);
        this.context = new Konva.HitContext(this);
        this.setSize(width, height);
        this.hitCanvas = true;
    };
    Konva.Util.extend(Konva.HitCanvas, Konva.Canvas);

})();

(function() {
    'use strict';
    var COMMA = ',',
        OPEN_PAREN = '(',
        CLOSE_PAREN = ')',
        OPEN_PAREN_BRACKET = '([',
        CLOSE_BRACKET_PAREN = '])',
        SEMICOLON = ';',
        DOUBLE_PAREN = '()',
        // EMPTY_STRING = '',
        EQUALS = '=',
        // SET = 'set',
        CONTEXT_METHODS = [
            'arc',
            'arcTo',
            'beginPath',
            'bezierCurveTo',
            'clearRect',
            'clip',
            'closePath',
            'createLinearGradient',
            'createPattern',
            'createRadialGradient',
            'drawImage',
            'fill',
            'fillText',
            'getImageData',
            'createImageData',
            'lineTo',
            'moveTo',
            'putImageData',
            'quadraticCurveTo',
            'rect',
            'restore',
            'rotate',
            'save',
            'scale',
            'setLineDash',
            'setTransform',
            'stroke',
            'strokeText',
            'transform',
            'translate'
        ];

    var CONTEXT_PROPERTIES = ['fillStyle', 'strokeStyle', 'shadowColor', 'shadowBlur', 'shadowOffsetX',
        'shadowOffsetY', 'lineCap', 'lineJoin', 'lineWidth', 'miterLimit', 'font', 'textAlign', 'textBaseline',
        'globalAlpha', 'globalCompositeOperation'];

    /**
     * Canvas Context constructor
     * @constructor
     * @abstract
     * @memberof Konva
     */
    Konva.Context = function(canvas) {
        this.init(canvas);
    };

    Konva.Context.prototype = {
        init: function(canvas) {
            this.canvas = canvas;
            this._context = canvas._canvas.getContext('2d');

            if (Konva.enableTrace) {
                this.traceArr = [];
                this._enableTrace();
            }
        },
        /**
         * fill shape
         * @method
         * @memberof Konva.Context.prototype
         * @param {Konva.Shape} shape
         */
        fillShape: function(shape) {
            if(shape.getFillEnabled()) {
                this._fill(shape);
            }
        },
        /**
         * stroke shape
         * @method
         * @memberof Konva.Context.prototype
         * @param {Konva.Shape} shape
         */
        strokeShape: function(shape) {
            if(shape.getStrokeEnabled()) {
                this._stroke(shape);
            }
        },
        /**
         * fill then stroke
         * @method
         * @memberof Konva.Context.prototype
         * @param {Konva.Shape} shape
         */
        fillStrokeShape: function(shape) {
            var fillEnabled = shape.getFillEnabled();
            if(fillEnabled) {
                this._fill(shape);
            }
            if(shape.getStrokeEnabled()) {
                this._stroke(shape);
            }
        },
        /**
         * get context trace if trace is enabled
         * @method
         * @memberof Konva.Context.prototype
         * @param {Boolean} relaxed if false, return strict context trace, which includes method names, method parameters
         *  properties, and property values.  If true, return relaxed context trace, which only returns method names and
         *  properites.
         * @returns {String}
         */
        getTrace: function(relaxed) {
            var traceArr = this.traceArr,
                len = traceArr.length,
                str = '',
                n, trace, method, args;

            for (n = 0; n < len; n++) {
                trace = traceArr[n];
                method = trace.method;

                // methods
                if (method) {
                    args = trace.args;
                    str += method;
                    if (relaxed) {
                        str += DOUBLE_PAREN;
                    }
                    else {
                        if (Konva.Util._isArray(args[0])) {
                            str += OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;
                        }
                        else {
                            str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;
                        }
                    }
                }
                // properties
                else {
                    str += trace.property;
                    if (!relaxed) {
                        str += EQUALS + trace.val;
                    }
                }

                str += SEMICOLON;
            }

            return str;
        },
        /**
         * clear trace if trace is enabled
         * @method
         * @memberof Konva.Context.prototype
         */
        clearTrace: function() {
            this.traceArr = [];
        },
        _trace: function(str) {
            var traceArr = this.traceArr,
                len;

            traceArr.push(str);
            len = traceArr.length;

            if (len >= Konva.traceArrMax) {
                traceArr.shift();
            }
        },
        /**
         * reset canvas context transform
         * @method
         * @memberof Konva.Context.prototype
         */
        reset: function() {
            var pixelRatio = this.getCanvas().getPixelRatio();
            this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);
        },
        /**
         * get canvas
         * @method
         * @memberof Konva.Context.prototype
         * @returns {Konva.Canvas}
         */
        getCanvas: function() {
            return this.canvas;
        },
        /**
         * clear canvas
         * @method
         * @memberof Konva.Context.prototype
         * @param {Object} [bounds]
         * @param {Number} [bounds.x]
         * @param {Number} [bounds.y]
         * @param {Number} [bounds.width]
         * @param {Number} [bounds.height]
         */
        clear: function(bounds) {
            var canvas = this.getCanvas();

            if (bounds) {
                this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0);
            }
            else {
                this.clearRect(0, 0, canvas.getWidth() / canvas.pixelRatio, canvas.getHeight() / canvas.pixelRatio);
            }
        },
        _applyLineCap: function(shape) {
            var lineCap = shape.getLineCap();
            if(lineCap) {
                this.setAttr('lineCap', lineCap);
            }
        },
        _applyOpacity: function(shape) {
            var absOpacity = shape.getAbsoluteOpacity();
            if(absOpacity !== 1) {
                this.setAttr('globalAlpha', absOpacity);
            }
        },
        _applyLineJoin: function(shape) {
            var lineJoin = shape.getLineJoin();
            if(lineJoin) {
                this.setAttr('lineJoin', lineJoin);
            }
        },
        setAttr: function(attr, val) {
            this._context[attr] = val;
        },

        // context pass through methods
        arc: function() {
            var a = arguments;
            this._context.arc(a[0], a[1], a[2], a[3], a[4], a[5]);
        },
        beginPath: function() {
            this._context.beginPath();
        },
        bezierCurveTo: function() {
            var a = arguments;
            this._context.bezierCurveTo(a[0], a[1], a[2], a[3], a[4], a[5]);
        },
        clearRect: function() {
            var a = arguments;
            this._context.clearRect(a[0], a[1], a[2], a[3]);
        },
        clip: function() {
            this._context.clip();
        },
        closePath: function() {
            this._context.closePath();
        },
        createImageData: function() {
            var a = arguments;
            if(a.length === 2) {
                return this._context.createImageData(a[0], a[1]);
            }
            else if(a.length === 1) {
                return this._context.createImageData(a[0]);
            }
        },
        createLinearGradient: function() {
            var a = arguments;
            return this._context.createLinearGradient(a[0], a[1], a[2], a[3]);
        },
        createPattern: function() {
            var a = arguments;
            return this._context.createPattern(a[0], a[1]);
        },
        createRadialGradient: function() {
            var a = arguments;
            return this._context.createRadialGradient(a[0], a[1], a[2], a[3], a[4], a[5]);
        },
        drawImage: function() {
            var a = arguments,
                _context = this._context;

            if(a.length === 3) {
                _context.drawImage(a[0], a[1], a[2]);
            }
            else if(a.length === 5) {
                _context.drawImage(a[0], a[1], a[2], a[3], a[4]);
            }
            else if(a.length === 9) {
                _context.drawImage(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
            }
        },
        isPointInPath: function(x, y) {
            return this._context.isPointInPath(x, y);
        },
        fill: function() {
            this._context.fill();
        },
        fillRect: function(x, y, width, height) {
            this._context.fillRect(x, y, width, height);
        },
        strokeRect: function(x, y, width, height) {
            this._context.strokeRect(x, y, width, height);
        },
        fillText: function() {
            var a = arguments;
            this._context.fillText(a[0], a[1], a[2]);
        },
        measureText: function(text) {
            return this._context.measureText(text);
        },
        getImageData: function() {
            var a = arguments;
            return this._context.getImageData(a[0], a[1], a[2], a[3]);
        },
        lineTo: function() {
            var a = arguments;
            this._context.lineTo(a[0], a[1]);
        },
        moveTo: function() {
            var a = arguments;
            this._context.moveTo(a[0], a[1]);
        },
        rect: function() {
            var a = arguments;
            this._context.rect(a[0], a[1], a[2], a[3]);
        },
        putImageData: function() {
            var a = arguments;
            this._context.putImageData(a[0], a[1], a[2]);
        },
        quadraticCurveTo: function() {
            var a = arguments;
            this._context.quadraticCurveTo(a[0], a[1], a[2], a[3]);
        },
        restore: function() {
            this._context.restore();
        },
        rotate: function() {
            var a = arguments;
            this._context.rotate(a[0]);
        },
        save: function() {
            this._context.save();
        },
        scale: function() {
            var a = arguments;
            this._context.scale(a[0], a[1]);
        },
        setLineDash: function() {
            var a = arguments,
                _context = this._context;

            // works for Chrome and IE11
            if(this._context.setLineDash) {
                _context.setLineDash(a[0]);
            }
            // verified that this works in firefox
            else if('mozDash' in _context) {
                _context.mozDash = a[0];
            }
            // does not currently work for Safari
            else if('webkitLineDash' in _context) {
                _context.webkitLineDash = a[0];
            }

            // no support for IE9 and IE10
        },
        getLineDash: function() {
            return this._context.getLineDash();
        },
        setTransform: function() {
            var a = arguments;
            this._context.setTransform(a[0], a[1], a[2], a[3], a[4], a[5]);
        },
        stroke: function() {
            this._context.stroke();
        },
        strokeText: function() {
            var a = arguments;
            this._context.strokeText(a[0], a[1], a[2]);
        },
        transform: function() {
            var a = arguments;
            this._context.transform(a[0], a[1], a[2], a[3], a[4], a[5]);
        },
        translate: function() {
            var a = arguments;
            this._context.translate(a[0], a[1]);
        },
        _enableTrace: function() {
            var that = this,
                len = CONTEXT_METHODS.length,
                _simplifyArray = Konva.Util._simplifyArray,
                origSetter = this.setAttr,
                n, args;

            // to prevent creating scope function at each loop
            var func = function(methodName) {
                    var origMethod = that[methodName],
                        ret;

                    that[methodName] = function() {
                        args = _simplifyArray(Array.prototype.slice.call(arguments, 0));
                        ret = origMethod.apply(that, arguments);

                        if (methodName === 'clearRect') {
                            args[2] = args[2] / that.canvas.getPixelRatio();
                            args[3] = args[3] / that.canvas.getPixelRatio();
                        }
                        that._trace({
                            method: methodName,
                            args: args
                        });

                        return ret;
                    };
            };
            // methods
            for (n = 0; n < len; n++) {
                func(CONTEXT_METHODS[n]);
            }

            // attrs
            that.setAttr = function() {
                origSetter.apply(that, arguments);
                that._trace({
                    property: arguments[0],
                    val: arguments[1]
                });
            };
        }
    };

    CONTEXT_PROPERTIES.forEach(function(prop) {
        Object.defineProperty(Konva.Context.prototype, prop, {
            get: function () {
                return this._context[prop];
            },
            set: function (val) {
                this._context[prop] = val;
            }
        });
    });

    Konva.SceneContext = function(canvas) {
        Konva.Context.call(this, canvas);
    };

    Konva.SceneContext.prototype = {
        _fillColor: function(shape) {
            var fill = shape.fill();

            this.setAttr('fillStyle', fill);
            shape._fillFunc(this);
        },
        _fillPattern: function(shape) {
            var fillPatternX = shape.getFillPatternX(),
                fillPatternY = shape.getFillPatternY(),
                fillPatternScale = shape.getFillPatternScale(),
                fillPatternRotation = Konva.getAngle(shape.getFillPatternRotation()),
                fillPatternOffset = shape.getFillPatternOffset();

            if(fillPatternX || fillPatternY) {
                this.translate(fillPatternX || 0, fillPatternY || 0);
            }
            if(fillPatternRotation) {
                this.rotate(fillPatternRotation);
            }
            if(fillPatternScale) {
                this.scale(fillPatternScale.x, fillPatternScale.y);
            }
            if(fillPatternOffset) {
                this.translate(-1 * fillPatternOffset.x, -1 * fillPatternOffset.y);
            }

            this.setAttr('fillStyle', this.createPattern(shape.getFillPatternImage(), shape.getFillPatternRepeat() || 'repeat'));
            this.fill();
        },
        _fillLinearGradient: function(shape) {
            var start = shape.getFillLinearGradientStartPoint(),
                end = shape.getFillLinearGradientEndPoint(),
                colorStops = shape.getFillLinearGradientColorStops(),
                grd = this.createLinearGradient(start.x, start.y, end.x, end.y);

            if (colorStops) {
                // build color stops
                for(var n = 0; n < colorStops.length; n += 2) {
                    grd.addColorStop(colorStops[n], colorStops[n + 1]);
                }
                this.setAttr('fillStyle', grd);
                shape._fillFunc(this);
            }
        },
        _fillRadialGradient: function(shape) {
            var start = shape.getFillRadialGradientStartPoint(),
                end = shape.getFillRadialGradientEndPoint(),
                startRadius = shape.getFillRadialGradientStartRadius(),
                endRadius = shape.getFillRadialGradientEndRadius(),
                colorStops = shape.getFillRadialGradientColorStops(),
                grd = this.createRadialGradient(start.x, start.y, startRadius, end.x, end.y, endRadius);

            // build color stops
            for(var n = 0; n < colorStops.length; n += 2) {
                grd.addColorStop(colorStops[n], colorStops[n + 1]);
            }
            this.setAttr('fillStyle', grd);
            this.fill();
        },
        _fill: function(shape) {
            var hasColor = shape.fill(),
                hasPattern = shape.getFillPatternImage(),
                hasLinearGradient = shape.getFillLinearGradientColorStops(),
                hasRadialGradient = shape.getFillRadialGradientColorStops(),
                fillPriority = shape.getFillPriority();

            // priority fills
            if(hasColor && fillPriority === 'color') {
                this._fillColor(shape);
            }
            else if(hasPattern && fillPriority === 'pattern') {
                this._fillPattern(shape);
            }
            else if(hasLinearGradient && fillPriority === 'linear-gradient') {
                this._fillLinearGradient(shape);
            }
            else if(hasRadialGradient && fillPriority === 'radial-gradient') {
                this._fillRadialGradient(shape);
            }
            // now just try and fill with whatever is available
            else if(hasColor) {
                this._fillColor(shape);
            }
            else if(hasPattern) {
                this._fillPattern(shape);
            }
            else if(hasLinearGradient) {
                this._fillLinearGradient(shape);
            }
            else if(hasRadialGradient) {
                this._fillRadialGradient(shape);
            }
        },
        _stroke: function(shape) {
            var dash = shape.dash(),
                // ignore strokeScaleEnabled for Text
                strokeScaleEnabled = (shape.getStrokeScaleEnabled() || (shape instanceof Konva.Text));

            if(shape.hasStroke()) {
                if (!strokeScaleEnabled) {
                    this.save();
                    this.setTransform(1, 0, 0, 1, 0, 0);
                }

                this._applyLineCap(shape);
                if(dash && shape.dashEnabled()) {
                    this.setLineDash(dash);
                }

                this.setAttr('lineWidth', shape.strokeWidth());
                this.setAttr('strokeStyle', shape.stroke());

                if (!shape.getShadowForStrokeEnabled()) {
                    this.setAttr('shadowColor', 'rgba(0,0,0,0)');
                }
                shape._strokeFunc(this);

                if (!strokeScaleEnabled) {
                    this.restore();
                }
            }
        },
        _applyShadow: function(shape) {
            var util = Konva.Util,
                color = util.get(shape.getShadowRGBA(), 'black'),
                blur = util.get(shape.getShadowBlur(), 5),
                offset = util.get(shape.getShadowOffset(), {
                    x: 0,
                    y: 0
                }),
                m = shape.getAbsoluteTransform().m,
                scaleX = m[0],
                scaleY = m[3];

            this.setAttr('shadowColor', color);
            this.setAttr('shadowBlur', blur);
            this.setAttr('shadowOffsetX', offset.x * scaleX);
            this.setAttr('shadowOffsetY', offset.y * scaleY);
        }
    };
    Konva.Util.extend(Konva.SceneContext, Konva.Context);

    Konva.HitContext = function(canvas) {
        Konva.Context.call(this, canvas);
    };

    Konva.HitContext.prototype = {
        _fill: function(shape) {
            this.save();
            this.setAttr('fillStyle', shape.colorKey);
            shape._fillFuncHit(this);
            this.restore();
        },
        _stroke: function(shape) {
            if(shape.hasStroke() && shape.strokeHitEnabled()) {
                // ignore strokeScaleEnabled for Text
                var strokeScaleEnabled = (shape.getStrokeScaleEnabled() || (shape instanceof Konva.Text));
                if (!strokeScaleEnabled) {
                    this.save();
                    this.setTransform(1, 0, 0, 1, 0, 0);
                }
                this._applyLineCap(shape);
                this.setAttr('lineWidth', shape.strokeWidth());
                this.setAttr('strokeStyle', shape.colorKey);
                shape._strokeFuncHit(this);
                if (!strokeScaleEnabled) {
                    this.restore();
                }
            }
        }
    };
    Konva.Util.extend(Konva.HitContext, Konva.Context);
})();

(function() {
    'use strict';
    // CONSTANTS
    var GET = 'get',
        SET = 'set';

    Konva.Factory = {
        addGetterSetter: function(constructor, attr, def, validator, after) {
            this.addGetter(constructor, attr, def);
            this.addSetter(constructor, attr, validator, after);
            this.addOverloadedGetterSetter(constructor, attr);
        },
        addGetter: function(constructor, attr, def) {
            var method = GET + Konva.Util._capitalize(attr);

            constructor.prototype[method] = function() {
                var val = this.attrs[attr];
                return val === undefined ? def : val;
            };
        },
        addSetter: function(constructor, attr, validator, after) {
            var method = SET + Konva.Util._capitalize(attr);

            constructor.prototype[method] = function(val) {
                if (validator) {
                    val = validator.call(this, val);
                }

                this._setAttr(attr, val);

                if (after) {
                    after.call(this);
                }

                return this;
            };
        },
        addComponentsGetterSetter: function(constructor, attr, components, validator, after) {
            var len = components.length,
                capitalize = Konva.Util._capitalize,
                getter = GET + capitalize(attr),
                setter = SET + capitalize(attr),
                n, component;

            // getter
            constructor.prototype[getter] = function() {
                var ret = {};

                for (n = 0; n < len; n++) {
                    component = components[n];
                    ret[component] = this.getAttr(attr + capitalize(component));
                }

                return ret;
            };

            // setter
            constructor.prototype[setter] = function(val) {
                var oldVal = this.attrs[attr],
                    key;

                if (validator) {
                    val = validator.call(this, val);
                }

                for (key in val) {
                    if (!val.hasOwnProperty(key)) {
                        continue;
                    }
                    this._setAttr(attr + capitalize(key), val[key]);
                }

                this._fireChangeEvent(attr, oldVal, val);

                if (after) {
                    after.call(this);
                }

                return this;
            };

            this.addOverloadedGetterSetter(constructor, attr);
        },
        addOverloadedGetterSetter: function(constructor, attr) {
            var capitalizedAttr = Konva.Util._capitalize(attr),
                setter = SET + capitalizedAttr,
                getter = GET + capitalizedAttr;

            constructor.prototype[attr] = function() {
                // setting
                if (arguments.length) {
                    this[setter](arguments[0]);
                    return this;
                }
                // getting
                return this[getter]();
            };
        },
        addDeprecatedGetterSetter: function(constructor, attr, def, validator) {
            var method = GET + Konva.Util._capitalize(attr);
            var message = attr + ' property is deprecated and will be removed soon. Look at Konva change log for more information.';
            constructor.prototype[method] = function() {
                Konva.Util.error(message);
                var val = this.attrs[attr];
                return val === undefined ? def : val;
            };
            this.addSetter(constructor, attr, validator, function() {
              Konva.Util.error(message);
            });
            this.addOverloadedGetterSetter(constructor, attr);
        },
        backCompat: function(constructor, methods) {
            Konva.Util.each(methods, function(oldMethodName, newMethodName) {
                var method = constructor.prototype[newMethodName];
                constructor.prototype[oldMethodName] = function(){
                    method.apply(this, arguments);
                    Konva.Util.error(oldMethodName + ' method is deprecated and will be removed soon. Use ' + newMethodName + ' instead');
                };
            });
        },
        afterSetFilter: function() {
            this._filterUpToDate = false;
        }
    };

    Konva.Validators = {
        /**
         * @return {number}
         */
        RGBComponent: function(val) {
            if (val > 255) {
                return 255;
            } else if (val < 0) {
                return 0;
            }
            return Math.round(val);
        },
        alphaComponent: function(val) {
            if (val > 1) {
                return 1;
            }
            // chrome does not honor alpha values of 0
            else if (val < 0.0001) {
                return 0.0001;
            }

            return val;
        }
    };
})();

(function(Konva) {
    'use strict';
    // CONSTANTS
    var ABSOLUTE_OPACITY = 'absoluteOpacity',
        ABSOLUTE_TRANSFORM = 'absoluteTransform',
        CHANGE = 'Change',
        CHILDREN = 'children',
        DOT = '.',
        EMPTY_STRING = '',
        GET = 'get',
        ID = 'id',
        KONVA = 'konva',
        LISTENING = 'listening',
        MOUSEENTER = 'mouseenter',
        MOUSELEAVE = 'mouseleave',
        NAME = 'name',
        SET = 'set',
        SHAPE = 'Shape',
        SPACE = ' ',
        STAGE = 'stage',
        TRANSFORM = 'transform',
        UPPER_STAGE = 'Stage',
        VISIBLE = 'visible',
        CLONE_BLACK_LIST = ['id'],

        TRANSFORM_CHANGE_STR = [
            'xChange.konva',
            'yChange.konva',
            'scaleXChange.konva',
            'scaleYChange.konva',
            'skewXChange.konva',
            'skewYChange.konva',
            'rotationChange.konva',
            'offsetXChange.konva',
            'offsetYChange.konva',
            'transformsEnabledChange.konva'
        ].join(SPACE);

    /**
     * Node constructor. Nodes are entities that can be transformed, layered,
     * and have bound events. The stage, layers, groups, and shapes all extend Node.
     * @constructor
     * @memberof Konva
     * @abstract
     * @param {Object} config
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     */
    Konva.Node = function(config) {
        this._init(config);
    };

    Konva.Util.addMethods(Konva.Node, {
        _init: function(config) {
            var that = this;
            this._id = Konva.idCounter++;
            this.eventListeners = {};
            this.attrs = {};
            this._cache = {};
            this._filterUpToDate = false;
            this.setAttrs(config);

            // event bindings for cache handling
            this.on(TRANSFORM_CHANGE_STR, function() {
                this._clearCache(TRANSFORM);
                that._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
            });
            this.on('visibleChange.konva', function() {
                that._clearSelfAndDescendantCache(VISIBLE);
            });
            this.on('listeningChange.konva', function() {
                that._clearSelfAndDescendantCache(LISTENING);
            });
            this.on('opacityChange.konva', function() {
                that._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
            });
        },
        _clearCache: function(attr){
            if (attr) {
                delete this._cache[attr];
            }
            else {
                this._cache = {};
            }
        },
        _getCache: function(attr, privateGetter){
            var cache = this._cache[attr];

            // if not cached, we need to set it using the private getter method.
            if (cache === undefined) {
                this._cache[attr] = privateGetter.call(this);
            }

            return this._cache[attr];
        },
        /*
         * when the logic for a cached result depends on ancestor propagation, use this
         * method to clear self and children cache
         */
        _clearSelfAndDescendantCache: function(attr) {
            this._clearCache(attr);

            if (this.children) {
                this.getChildren().each(function(node) {
                    node._clearSelfAndDescendantCache(attr);
                });
            }
        },
        /**
        * clear cached canvas
        * @method
        * @memberof Konva.Node.prototype
        * @returns {Konva.Node}
        * @example
        * node.clearCache();
        */
        clearCache: function() {
            delete this._cache.canvas;
            this._filterUpToDate = false;
            return this;
        },
        /**
        *  cache node to improve drawing performance, apply filters, or create more accurate
        *  hit regions. For all basic shapes size of cache canvas will be automatically detected.
        *  If you need to cache your custom `Konva.Shape` instance you have to pass shape's bounding box
        *  properties. Look at [link to demo page](link to demo page) for more information.
        * @method
        * @memberof Konva.Node.prototype
        * @param {Object} [config]
        * @param {Number} [config.x]
        * @param {Number} [config.y]
        * @param {Number} [config.width]
        * @param {Number} [config.height]
        * @param {Number} [config.offset]  increase canvas size by `offset` pixel in all directions.
        * @param {Boolean} [config.drawBorder] when set to true, a red border will be drawn around the cached
        *  region for debugging purposes
        * @returns {Konva.Node}
        * @example
        * // cache a shape with the x,y position of the bounding box at the center and
        * // the width and height of the bounding box equal to the width and height of
        * // the shape obtained from shape.width() and shape.height()
        * image.cache();
        *
        * // cache a node and define the bounding box position and size
        * node.cache({
        *   x: -30,
        *   y: -30,
        *   width: 100,
        *   height: 200
        * });
        *
        * // cache a node and draw a red border around the bounding box
        * // for debugging purposes
        * node.cache({
        *   x: -30,
        *   y: -30,
        *   width: 100,
        *   height: 200,
        *   offset : 10,
        *   drawBorder: true
        * });
        */
        cache: function(config) {
            var conf = config || {},
                rect = this.getClientRect(true),
                width = conf.width || rect.width,
                height = conf.height || rect.height,
                x = conf.x || rect.x,
                y = conf.y || rect.y,
                offset = conf.offset || 0,
                drawBorder = conf.drawBorder || false;

            if (!width || !height) {
                throw new Error('Width or height of caching configuration equals 0.');
            }

            width += offset * 2;
            height += offset * 2;

            x -= offset;
            y -= offset;


            var cachedSceneCanvas = new Konva.SceneCanvas({
                width: width,
                height: height
            }),
            cachedFilterCanvas = new Konva.SceneCanvas({
                width: width,
                height: height
            }),
            cachedHitCanvas = new Konva.HitCanvas({
                pixelRatio: 1,
                width: width,
                height: height
            }),
            sceneContext = cachedSceneCanvas.getContext(),
            hitContext = cachedHitCanvas.getContext();

            cachedHitCanvas.isCache = true;

            this.clearCache();

            sceneContext.save();
            hitContext.save();

            sceneContext.translate(-x, -y);
            hitContext.translate(-x, -y);

            this.drawScene(cachedSceneCanvas, this, true);
            this.drawHit(cachedHitCanvas, this, true);

            sceneContext.restore();
            hitContext.restore();

            // this will draw a red border around the cached box for
            // debugging purposes
            if (drawBorder) {
                sceneContext.save();
                sceneContext.beginPath();
                sceneContext.rect(0, 0, width, height);
                sceneContext.closePath();
                sceneContext.setAttr('strokeStyle', 'red');
                sceneContext.setAttr('lineWidth', 5);
                sceneContext.stroke();
                sceneContext.restore();
            }

            this._cache.canvas = {
                scene: cachedSceneCanvas,
                filter: cachedFilterCanvas,
                hit: cachedHitCanvas,
                x: x,
                y: y
            };

            return this;
        },
        /**
         * Return client rectangle {x, y, width, height} of node. This rectangle also include all styling (strokes, shadows, etc).
         * The rectangle position is relative to parent container.
         * @method
         * @memberof Konva.Node.prototype
         * @param {Boolean} [skipTransform] flag should we skip transformation to rectangle
         * @returns {Object} rect with {x, y, width, height} properties
         * @example
         * var rect = new Konva.Rect({
         *      width : 100,
         *      height : 100,
         *      x : 50,
         *      y : 50,
         *      strokeWidth : 4,
         *      stroke : 'black',
         *      offsetX : 50,
         *      scaleY : 2
         * });
         *
         * // get client rect without think off transformations (position, rotation, scale, offset, etc)
         * rect.getClientRect(true);
         * // returns {
         * //     x : -2,   // two pixels for stroke / 2
         * //     y : -2,
         * //     width : 104, // increased by 4 for stroke
         * //     height : 104
         * //}
         *
         * // get client rect with transformation applied
         * rect.getClientRect();
         * // returns Object {x: -2, y: 46, width: 104, height: 208}
         */
        getClientRect: function() {
            // abstract method
            // redefine in Container and Shape
            throw new Error('abstract "getClientRect" method call');
        },
        _transformedRect: function(rect) {
            var points = [
                {x: rect.x, y: rect.y},
                {x: rect.x + rect.width, y: rect.y},
                {x: rect.x + rect.width, y: rect.y + rect.height},
                {x: rect.x, y: rect.y + rect.height}
            ];
            var minX, minY, maxX, maxY;
            var trans = this.getTransform();
            points.forEach(function(point) {
                var transformed = trans.point(point);
                if (minX === undefined) {
                    minX = maxX = transformed.x;
                    minY = maxY = transformed.y;
                }
                minX = Math.min(minX, transformed.x);
                minY = Math.min(minY, transformed.y);
                maxX = Math.max(maxX, transformed.x);
                maxY = Math.max(maxY, transformed.y);
            });
            return {
                x: Math.round(minX),
                y: Math.round(minY),
                width: Math.round(maxX - minX),
                height: Math.round(maxY - minY)
            };
        },
        _drawCachedSceneCanvas: function(context) {
            context.save();
            context._applyOpacity(this);
            context.translate(
                this._cache.canvas.x,
                this._cache.canvas.y
            );

            var cacheCanvas = this._getCachedSceneCanvas();
            var ratio = cacheCanvas.pixelRatio;

            context.drawImage(cacheCanvas._canvas, 0, 0, cacheCanvas.width / ratio, cacheCanvas.height / ratio);
            context.restore();
        },
        _drawCachedHitCanvas: function(context) {
            var cachedCanvas = this._cache.canvas,
                hitCanvas = cachedCanvas.hit;
            context.save();
            context.translate(
                this._cache.canvas.x,
                this._cache.canvas.y
            );
            context.drawImage(hitCanvas._canvas, 0, 0);
            context.restore();
        },
        _getCachedSceneCanvas: function() {
            var filters = this.filters(),
                cachedCanvas = this._cache.canvas,
                sceneCanvas = cachedCanvas.scene,
                filterCanvas = cachedCanvas.filter,
                filterContext = filterCanvas.getContext(),
                len, imageData, n, filter;

            if (filters) {
                if (!this._filterUpToDate) {
                    var ratio = sceneCanvas.pixelRatio;

                    try {
                        len = filters.length;
                        filterContext.clear();

                        // copy cached canvas onto filter context
                        filterContext.drawImage(sceneCanvas._canvas, 0, 0, sceneCanvas.getWidth() / ratio, sceneCanvas.getHeight() / ratio);
                        imageData = filterContext.getImageData(0, 0, filterCanvas.getWidth(), filterCanvas.getHeight());

                        // apply filters to filter context
                        for (n = 0; n < len; n++) {
                            filter = filters[n];
                            filter.call(this, imageData);
                            filterContext.putImageData(imageData, 0, 0);
                        }
                    }
                    catch(e) {
                        Konva.Util.warn('Unable to apply filter. ' + e.message);
                    }

                    this._filterUpToDate = true;
                }

                return filterCanvas;
            }
            return sceneCanvas;
        },
        /**
         * bind events to the node. KonvaJS supports mouseover, mousemove,
         *  mouseout, mouseenter, mouseleave, mousedown, mouseup, mousewheel, click, dblclick, touchstart, touchmove,
         *  touchend, tap, dbltap, dragstart, dragmove, and dragend events. The Konva Stage supports
         *  contentMouseover, contentMousemove, contentMouseout, contentMousedown, contentMouseup,
         *  contentClick, contentDblclick, contentTouchstart, contentTouchmove, contentTouchend, contentTap,
         *  and contentDblTap.  Pass in a string of events delimmited by a space to bind multiple events at once
         *  such as 'mousedown mouseup mousemove'. Include a namespace to bind an
         *  event by name such as 'click.foobar'.
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} evtStr e.g. 'click', 'mousedown touchstart', 'mousedown.foo touchstart.foo'
         * @param {Function} handler The handler function is passed an event object
         * @returns {Konva.Node}
         * @example
         * // add click listener
         * node.on('click', function() {
         *   console.log('you clicked me!');
         * });
         *
         * // get the target node
         * node.on('click', function(evt) {
         *   console.log(evt.target);
         * });
         *
         * // stop event propagation
         * node.on('click', function(evt) {
         *   evt.cancelBubble = true;
         * });
         *
         * // bind multiple listeners
         * node.on('click touchstart', function() {
         *   console.log('you clicked/touched me!');
         * });
         *
         * // namespace listener
         * node.on('click.foo', function() {
         *   console.log('you clicked/touched me!');
         * });
         *
         * // get the event type
         * node.on('click tap', function(evt) {
         *   var eventType = evt.type;
         * });
         *
         * // get native event object
         * node.on('click tap', function(evt) {
         *   var nativeEvent = evt.evt;
         * });
         *
         * // for change events, get the old and new val
         * node.on('xChange', function(evt) {
         *   var oldVal = evt.oldVal;
         *   var newVal = evt.newVal;
         * });
         */
        on: function(evtStr, handler) {
            var events = evtStr.split(SPACE),
                len = events.length,
                n, event, parts, baseEvent, name;

             /*
             * loop through types and attach event listeners to
             * each one.  eg. 'click mouseover.namespace mouseout'
             * will create three event bindings
             */
            for(n = 0; n < len; n++) {
                event = events[n];
                parts = event.split(DOT);
                baseEvent = parts[0];
                name = parts[1] || EMPTY_STRING;

                // create events array if it doesn't exist
                if(!this.eventListeners[baseEvent]) {
                    this.eventListeners[baseEvent] = [];
                }

                this.eventListeners[baseEvent].push({
                    name: name,
                    handler: handler
                });
            }

            return this;
        },
        /**
         * remove event bindings from the node. Pass in a string of
         *  event types delimmited by a space to remove multiple event
         *  bindings at once such as 'mousedown mouseup mousemove'.
         *  include a namespace to remove an event binding by name
         *  such as 'click.foobar'. If you only give a name like '.foobar',
         *  all events in that namespace will be removed.
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} evtStr e.g. 'click', 'mousedown touchstart', '.foobar'
         * @returns {Konva.Node}
         * @example
         * // remove listener
         * node.off('click');
         *
         * // remove multiple listeners
         * node.off('click touchstart');
         *
         * // remove listener by name
         * node.off('click.foo');
         */
        off: function(evtStr) {
            var events = (evtStr || '').split(SPACE),
                len = events.length,
                n, t, event, parts, baseEvent, name;

            if (!evtStr) {
                // remove all events
                for(t in this.eventListeners) {
                    this._off(t);
                }
            }
            for(n = 0; n < len; n++) {
                event = events[n];
                parts = event.split(DOT);
                baseEvent = parts[0];
                name = parts[1];

                if(baseEvent) {
                    if(this.eventListeners[baseEvent]) {
                        this._off(baseEvent, name);
                    }
                }
                else {
                    for(t in this.eventListeners) {
                        this._off(t, name);
                    }
                }
            }
            return this;
        },
        // some event aliases for third party integration like HammerJS
        dispatchEvent: function(evt) {
            var e = {
              target: this,
              type: evt.type,
              evt: evt
            };
            this.fire(evt.type, e);
        },
        addEventListener: function(type, handler) {
            // we have to pass native event to handler
            this.on(type, function(evt){
                handler.call(this, evt.evt);
            });
        },
        removeEventListener: function(type) {
            this.off(type);
        },
        /**
         * remove self from parent, but don't destroy
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Node}
         * @example
         * node.remove();
         */
        remove: function() {
            var parent = this.getParent();

            if(parent && parent.children) {
                parent.children.splice(this.index, 1);
                parent._setChildrenIndices();
                delete this.parent;
            }

            // every cached attr that is calculated via node tree
            // traversal must be cleared when removing a node
            this._clearSelfAndDescendantCache(STAGE);
            this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
            this._clearSelfAndDescendantCache(VISIBLE);
            this._clearSelfAndDescendantCache(LISTENING);
            this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);

            return this;
        },
        /**
         * remove and destroy self
         * @method
         * @memberof Konva.Node.prototype
         * @example
         * node.destroy();
         */
        destroy: function() {
            // remove from ids and names hashes
            Konva._removeId(this.getId());
            Konva._removeName(this.getName(), this._id);

            this.remove();
        },
        /**
         * get attr
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} attr
         * @returns {Integer|String|Object|Array}
         * @example
         * var x = node.getAttr('x');
         */
        getAttr: function(attr) {
            var method = GET + Konva.Util._capitalize(attr);
            if(Konva.Util._isFunction(this[method])) {
                return this[method]();
            }
            // otherwise get directly
            return this.attrs[attr];
        },
        /**
        * get ancestors
        * @method
        * @memberof Konva.Node.prototype
        * @returns {Konva.Collection}
        * @example
        * shape.getAncestors().each(function(node) {
        *   console.log(node.getId());
        * })
        */
        getAncestors: function() {
            var parent = this.getParent(),
                ancestors = new Konva.Collection();

            while (parent) {
                ancestors.push(parent);
                parent = parent.getParent();
            }

            return ancestors;
        },
        /**
         * get attrs object literal
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Object}
         */
        getAttrs: function() {
            return this.attrs || {};
        },
        /**
         * set multiple attrs at once using an object literal
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} config object containing key value pairs
         * @returns {Konva.Node}
         * @example
         * node.setAttrs({
         *   x: 5,
         *   fill: 'red'
         * });
         */
        setAttrs: function(config) {
            var key, method;

            if(!config) {
                return this;
            }
            for(key in config) {
                if (key === CHILDREN) {
                    continue;
                }
                method = SET + Konva.Util._capitalize(key);
                // use setter if available
                if(Konva.Util._isFunction(this[method])) {
                    this[method](config[key]);
                }
                // otherwise set directly
                else {
                    this._setAttr(key, config[key]);
                }
            }
            return this;
        },
        /**
         * determine if node is listening for events by taking into account ancestors.
         *
         * Parent    | Self      | isListening
         * listening | listening |
         * ----------+-----------+------------
         * T         | T         | T
         * T         | F         | F
         * F         | T         | T
         * F         | F         | F
         * ----------+-----------+------------
         * T         | I         | T
         * F         | I         | F
         * I         | I         | T
         *
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
        isListening: function() {
            return this._getCache(LISTENING, this._isListening);
        },
        _isListening: function() {
            var listening = this.getListening(),
                parent = this.getParent();

            // the following conditions are a simplification of the truth table above.
            // please modify carefully
            if (listening === 'inherit') {
                if (parent) {
                    return parent.isListening();
                }
                else {
                    return true;
                }
            }
            else {
                return listening;
            }
        },
        /**
         * determine if node is visible by taking into account ancestors.
         *
         * Parent    | Self      | isVisible
         * visible   | visible   |
         * ----------+-----------+------------
         * T         | T         | T
         * T         | F         | F
         * F         | T         | T
         * F         | F         | F
         * ----------+-----------+------------
         * T         | I         | T
         * F         | I         | F
         * I         | I         | T

         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
        isVisible: function() {
            return this._getCache(VISIBLE, this._isVisible);
        },
        _isVisible: function() {
            var visible = this.getVisible(),
                parent = this.getParent();

            // the following conditions are a simplification of the truth table above.
            // please modify carefully
            if (visible === 'inherit') {
                if (parent) {
                    return parent.isVisible();
                }
                else {
                    return true;
                }
            }
            else {
                return visible;
            }
        },
        /**
         * determine if listening is enabled by taking into account descendants.  If self or any children
         * have _isListeningEnabled set to true, then self also has listening enabled.
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
        shouldDrawHit: function(canvas) {
            var layer = this.getLayer();
            return (canvas && canvas.isCache) || (layer && layer.hitGraphEnabled())
                && this.isListening() && this.isVisible();
        },
        /**
         * show node
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Node}
         */
        show: function() {
            this.setVisible(true);
            return this;
        },
        /**
         * hide node.  Hidden nodes are no longer detectable
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Node}
         */
        hide: function() {
            this.setVisible(false);
            return this;
        },
        /**
         * get zIndex relative to the node's siblings who share the same parent
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Integer}
         */
        getZIndex: function() {
            return this.index || 0;
        },
        /**
         * get absolute z-index which takes into account sibling
         *  and ancestor indices
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Integer}
         */
        getAbsoluteZIndex: function() {
            var depth = this.getDepth(),
                that = this,
                index = 0,
                nodes, len, n, child;

            function addChildren(children) {
                nodes = [];
                len = children.length;
                for(n = 0; n < len; n++) {
                    child = children[n];
                    index++;

                    if(child.nodeType !== SHAPE) {
                        nodes = nodes.concat(child.getChildren().toArray());
                    }

                    if(child._id === that._id) {
                        n = len;
                    }
                }

                if(nodes.length > 0 && nodes[0].getDepth() <= depth) {
                    addChildren(nodes);
                }
            }
            if(that.nodeType !== UPPER_STAGE) {
                addChildren(that.getStage().getChildren());
            }

            return index;
        },
        /**
         * get node depth in node tree.  Returns an integer.
         *  e.g. Stage depth will always be 0.  Layers will always be 1.  Groups and Shapes will always
         *  be >= 2
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Integer}
         */
        getDepth: function() {
            var depth = 0,
                parent = this.parent;

            while(parent) {
                depth++;
                parent = parent.parent;
            }
            return depth;
        },
        setPosition: function(pos) {
            this.setX(pos.x);
            this.setY(pos.y);
            return this;
        },
        getPosition: function() {
            return {
                x: this.getX(),
                y: this.getY()
            };
        },
        /**
         * get absolute position relative to the top left corner of the stage container div
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Object}
         */
        getAbsolutePosition: function() {
            var absoluteMatrix = this.getAbsoluteTransform().getMatrix(),
                absoluteTransform = new Konva.Transform(),
                offset = this.offset();

            // clone the matrix array
            absoluteTransform.m = absoluteMatrix.slice();
            absoluteTransform.translate(offset.x, offset.y);

            return absoluteTransform.getTranslation();
        },
        /**
         * set absolute position
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} pos
         * @param {Number} pos.x
         * @param {Number} pos.y
         * @returns {Konva.Node}
         */
        setAbsolutePosition: function(pos) {
            var origTrans = this._clearTransform(),
                it;

            // don't clear translation
            this.attrs.x = origTrans.x;
            this.attrs.y = origTrans.y;
            delete origTrans.x;
            delete origTrans.y;

            // unravel transform
            it = this.getAbsoluteTransform();

            it.invert();
            it.translate(pos.x, pos.y);
            pos = {
                x: this.attrs.x + it.getTranslation().x,
                y: this.attrs.y + it.getTranslation().y
            };

            this.setPosition({x: pos.x, y: pos.y});
            this._setTransform(origTrans);

            return this;
        },
        _setTransform: function(trans) {
            var key;

            for(key in trans) {
                this.attrs[key] = trans[key];
            }

            this._clearCache(TRANSFORM);
            this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
        },
        _clearTransform: function() {
            var trans = {
                x: this.getX(),
                y: this.getY(),
                rotation: this.getRotation(),
                scaleX: this.getScaleX(),
                scaleY: this.getScaleY(),
                offsetX: this.getOffsetX(),
                offsetY: this.getOffsetY(),
                skewX: this.getSkewX(),
                skewY: this.getSkewY()
            };

            this.attrs.x = 0;
            this.attrs.y = 0;
            this.attrs.rotation = 0;
            this.attrs.scaleX = 1;
            this.attrs.scaleY = 1;
            this.attrs.offsetX = 0;
            this.attrs.offsetY = 0;
            this.attrs.skewX = 0;
            this.attrs.skewY = 0;

            this._clearCache(TRANSFORM);
            this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);

            // return original transform
            return trans;
        },
        /**
         * move node by an amount relative to its current position
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} change
         * @param {Number} change.x
         * @param {Number} change.y
         * @returns {Konva.Node}
         * @example
         * // move node in x direction by 1px and y direction by 2px
         * node.move({
         *   x: 1,
         *   y: 2)
         * });
         */
        move: function(change) {
            var changeX = change.x,
                changeY = change.y,
                x = this.getX(),
                y = this.getY();

            if(changeX !== undefined) {
                x += changeX;
            }

            if(changeY !== undefined) {
                y += changeY;
            }

            this.setPosition({x: x, y: y});
            return this;
        },
        _eachAncestorReverse: function(func, top) {
            var family = [],
                parent = this.getParent(),
                len, n;

            // if top node is defined, and this node is top node,
            // there's no need to build a family tree.  just execute
            // func with this because it will be the only node
            if (top && top._id === this._id) {
                func(this);
                return true;
            }

            family.unshift(this);

            while(parent && (!top || parent._id !== top._id)) {
                family.unshift(parent);
                parent = parent.parent;
            }

            len = family.length;
            for(n = 0; n < len; n++) {
                func(family[n]);
            }
        },
        /**
         * rotate node by an amount in degrees relative to its current rotation
         * @method
         * @memberof Konva.Node.prototype
         * @param {Number} theta
         * @returns {Konva.Node}
         */
        rotate: function(theta) {
            this.setRotation(this.getRotation() + theta);
            return this;
        },
        /**
         * move node to the top of its siblings
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
        moveToTop: function() {
            if (!this.parent) {
                Konva.Util.warn('Node has no parent. moveToTop function is ignored.');
                return false;
            }
            var index = this.index;
            this.parent.children.splice(index, 1);
            this.parent.children.push(this);
            this.parent._setChildrenIndices();
            return true;
        },
        /**
         * move node up
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean} flag is moved or not
         */
        moveUp: function() {
            if (!this.parent) {
                Konva.Util.warn('Node has no parent. moveUp function is ignored.');
                return false;
            }
            var index = this.index,
                len = this.parent.getChildren().length;
            if(index < len - 1) {
                this.parent.children.splice(index, 1);
                this.parent.children.splice(index + 1, 0, this);
                this.parent._setChildrenIndices();
                return true;
            }
            return false;
        },
        /**
         * move node down
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
        moveDown: function() {
            if (!this.parent) {
                Konva.Util.warn('Node has no parent. moveDown function is ignored.');
                return false;
            }
            var index = this.index;
            if(index > 0) {
                this.parent.children.splice(index, 1);
                this.parent.children.splice(index - 1, 0, this);
                this.parent._setChildrenIndices();
                return true;
            }
            return false;
        },
        /**
         * move node to the bottom of its siblings
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
        moveToBottom: function() {
            if (!this.parent) {
                Konva.Util.warn('Node has no parent. moveToBottom function is ignored.');
                return false;
            }
            var index = this.index;
            if(index > 0) {
                this.parent.children.splice(index, 1);
                this.parent.children.unshift(this);
                this.parent._setChildrenIndices();
                return true;
            }
            return false;
        },
        /**
         * set zIndex relative to siblings
         * @method
         * @memberof Konva.Node.prototype
         * @param {Integer} zIndex
         * @returns {Konva.Node}
         */
        setZIndex: function(zIndex) {
            if (!this.parent) {
                Konva.Util.warn('Node has no parent. zIndex parameter is ignored.');
                return false;
            }
            var index = this.index;
            this.parent.children.splice(index, 1);
            this.parent.children.splice(zIndex, 0, this);
            this.parent._setChildrenIndices();
            return this;
        },
        /**
         * get absolute opacity
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Number}
         */
        getAbsoluteOpacity: function() {
            return this._getCache(ABSOLUTE_OPACITY, this._getAbsoluteOpacity);
        },
        _getAbsoluteOpacity: function() {
            var absOpacity = this.getOpacity();
            if(this.getParent()) {
                absOpacity *= this.getParent().getAbsoluteOpacity();
            }
            return absOpacity;
        },
        /**
         * move node to another container
         * @method
         * @memberof Konva.Node.prototype
         * @param {Container} newContainer
         * @returns {Konva.Node}
         * @example
         * // move node from current layer into layer2
         * node.moveTo(layer2);
         */
        moveTo: function(newContainer) {
            // do nothing if new container is already parent
            if (this.getParent() !== newContainer) {
                this.remove();
                newContainer.add(this);
            }
            return this;
        },
        /**
         * convert Node into an object for serialization.  Returns an object.
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Object}
         */
        toObject: function() {
            var obj = {},
                attrs = this.getAttrs(),
                key, val, getter, defaultValue;

            obj.attrs = {};

            for(key in attrs) {
                val = attrs[key];
                // serialize only attributes that are not function, image, DOM, or objects with methods
                if (Konva.Util._isFunction(val) || Konva.Util._isElement(val) ||
                    (Konva.Util._isObject(val) || Konva.Util._hasMethods(val))) {
                    continue;
                }
                getter = this[key];
                // remove attr value so that we can extract the default value from the getter
                delete attrs[key];
                defaultValue = getter ? getter.call(this) : null;
                // restore attr value
                attrs[key] = val;
                if (defaultValue !== val) {
                    obj.attrs[key] = val;
                }
            }

            obj.className = this.getClassName();
            return obj;
        },
        /**
         * convert Node into a JSON string.  Returns a JSON string.
         * @method
         * @memberof Konva.Node.prototype
         * @returns {String}}
         */
        toJSON: function() {
            return JSON.stringify(this.toObject());
        },
        /**
         * get parent container
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Node}
         */
        getParent: function() {
            return this.parent;
        },
        /**
         * get layer ancestor
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Layer}
         */
        getLayer: function() {
            var parent = this.getParent();
            return parent ? parent.getLayer() : null;
        },
        /**
         * get stage ancestor
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Stage}
         */
        getStage: function() {
            return this._getCache(STAGE, this._getStage);
        },
        _getStage: function() {
            var parent = this.getParent();
            if(parent) {
                return parent.getStage();
            }
            else {
                return undefined;
            }
        },
        /**
         * fire event
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} eventType event type.  can be a regular event, like click, mouseover, or mouseout, or it can be a custom event, like myCustomEvent
         * @param {Event} [evt] event object
         * @param {Boolean} [bubble] setting the value to false, or leaving it undefined, will result in the event
         *  not bubbling.  Setting the value to true will result in the event bubbling.
         * @returns {Konva.Node}
         * @example
         * // manually fire click event
         * node.fire('click');
         *
         * // fire custom event
         * node.fire('foo');
         *
         * // fire custom event with custom event object
         * node.fire('foo', {
         *   bar: 10
         * });
         *
         * // fire click event that bubbles
         * node.fire('click', null, true);
         */
        fire: function(eventType, evt, bubble) {
            // bubble
            if (bubble) {
                this._fireAndBubble(eventType, evt || {});
            }
            // no bubble
            else {
                this._fire(eventType, evt || {});
            }
            return this;
        },
        /**
         * get absolute transform of the node which takes into
         *  account its ancestor transforms
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Transform}
         */
        getAbsoluteTransform: function(top) {
            // if using an argument, we can't cache the result.
            if (top) {
                return this._getAbsoluteTransform(top);
            }
            // if no argument, we can cache the result
            else {
                return this._getCache(ABSOLUTE_TRANSFORM, this._getAbsoluteTransform);
            }
        },
        _getAbsoluteTransform: function(top) {
            var at = new Konva.Transform(),
                transformsEnabled, trans;

            // start with stage and traverse downwards to self
            this._eachAncestorReverse(function(node) {
                transformsEnabled = node.transformsEnabled();
                trans = node.getTransform();

                if (transformsEnabled === 'all') {
                    at.multiply(trans);
                }
                else if (transformsEnabled === 'position') {
                    at.translate(node.x(), node.y());
                }
            }, top);
            return at;
        },
        /**
         * get transform of the node
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Transform}
         */
        getTransform: function() {
            return this._getCache(TRANSFORM, this._getTransform);
        },
        _getTransform: function() {
            var m = new Konva.Transform(),
                x = this.getX(),
                y = this.getY(),
                rotation = Konva.getAngle(this.getRotation()),
                scaleX = this.getScaleX(),
                scaleY = this.getScaleY(),
                skewX = this.getSkewX(),
                skewY = this.getSkewY(),
                offsetX = this.getOffsetX(),
                offsetY = this.getOffsetY();

            if(x !== 0 || y !== 0) {
                m.translate(x, y);
            }
            if(rotation !== 0) {
                m.rotate(rotation);
            }
            if(skewX !== 0 || skewY !== 0) {
                m.skew(skewX, skewY);
            }
            if(scaleX !== 1 || scaleY !== 1) {
                m.scale(scaleX, scaleY);
            }
            if(offsetX !== 0 || offsetY !== 0) {
                m.translate(-1 * offsetX, -1 * offsetY);
            }

            return m;
        },
        /**
         * clone node.  Returns a new Node instance with identical attributes.  You can also override
         *  the node properties with an object literal, enabling you to use an existing node as a template
         *  for another node
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} obj override attrs
         * @returns {Konva.Node}
         * @example
         * // simple clone
         * var clone = node.clone();
         *
         * // clone a node and override the x position
         * var clone = rect.clone({
         *   x: 5
         * });
         */
        clone: function(obj) {
            // instantiate new node
            var attrs = Konva.Util.cloneObject(this.attrs),
                key, allListeners, len, n, listener;
            // filter black attrs
            for (var i in CLONE_BLACK_LIST) {
                var blockAttr = CLONE_BLACK_LIST[i];
                delete attrs[blockAttr];
            }
            // apply attr overrides
            for (key in obj) {
                attrs[key] = obj[key];
            }

            var node = new this.constructor(attrs);
            // copy over listeners
            for(key in this.eventListeners) {
                allListeners = this.eventListeners[key];
                len = allListeners.length;
                for(n = 0; n < len; n++) {
                    listener = allListeners[n];
                    /*
                     * don't include konva namespaced listeners because
                     *  these are generated by the constructors
                     */
                    if(listener.name.indexOf(KONVA) < 0) {
                        // if listeners array doesn't exist, then create it
                        if(!node.eventListeners[key]) {
                            node.eventListeners[key] = [];
                        }
                        node.eventListeners[key].push(listener);
                    }
                }
            }
            return node;
        },
        /**
         * Creates a composite data URL. If MIME type is not
         * specified, then "image/png" will result. For "image/jpeg", specify a quality
         * level as quality (range 0.0 - 1.0)
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} config
         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
         *  "image/png" is the default
         * @param {Number} [config.x] x position of canvas section
         * @param {Number} [config.y] y position of canvas section
         * @param {Number} [config.width] width of canvas section
         * @param {Number} [config.height] height of canvas section
         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
         *  is very high quality
         * @paremt {Number} [config.pixelRatio] pixelRatio of ouput image url. Default is 1
         * @returns {String}
         */
        toDataURL: function(config) {
            config = config || {};

            var mimeType = config.mimeType || null,
                quality = config.quality || null,
                stage = this.getStage(),
                x = config.x || 0,
                y = config.y || 0,
                pixelRatio = config.pixelRatio || 1,
                canvas = new Konva.SceneCanvas({
                    width: config.width || this.getWidth() || (stage ? stage.getWidth() : 0),
                    height: config.height || this.getHeight() || (stage ? stage.getHeight() : 0),
                    pixelRatio: pixelRatio
                }),
                context = canvas.getContext();

            context.save();

            if(x || y) {
                context.translate(-1 * x, -1 * y);
            }

            this.drawScene(canvas);
            context.restore();

            return canvas.toDataURL(mimeType, quality);
        },
        /**
         * converts node into an image.  Since the toImage
         *  method is asynchronous, a callback is required.  toImage is most commonly used
         *  to cache complex drawings as an image so that they don't have to constantly be redrawn
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} config
         * @param {Function} config.callback function executed when the composite has completed
         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
         *  "image/png" is the default
         * @param {Number} [config.x] x position of canvas section
         * @param {Number} [config.y] y position of canvas section
         * @param {Number} [config.width] width of canvas section
         * @param {Number} [config.height] height of canvas section
         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
         *  is very high quality
         * @paremt {Number} [config.pixelRatio] pixelRatio of ouput image.  Default is 1.
         * @example
         * var image = node.toImage({
         *   callback: function(img) {
         *     // do stuff with img
         *   }
         * });
         */
        toImage: function(config) {
            if (!config || !config.callback) {
                throw 'callback required for toImage method config argument';
            }
            Konva.Util._getImage(this.toDataURL(config), function(img) {
                config.callback(img);
            });
        },
        setSize: function(size) {
            this.setWidth(size.width);
            this.setHeight(size.height);
            return this;
        },
        getSize: function() {
            return {
                width: this.getWidth(),
                height: this.getHeight()
            };
        },
        getWidth: function() {
            return this.attrs.width || 0;
        },
        getHeight: function() {
            return this.attrs.height || 0;
        },
        /**
         * get class name, which may return Stage, Layer, Group, or shape class names like Rect, Circle, Text, etc.
         * @method
         * @memberof Konva.Node.prototype
         * @returns {String}
         */
        getClassName: function() {
            return this.className || this.nodeType;
        },
        /**
         * get the node type, which may return Stage, Layer, Group, or Node
         * @method
         * @memberof Konva.Node.prototype
         * @returns {String}
         */
        getType: function() {
            return this.nodeType;
        },
        getDragDistance: function() {
            // compare with undefined because we need to track 0 value
            if (this.attrs.dragDistance !== undefined) {
                return this.attrs.dragDistance;
            } else if (this.parent) {
                return this.parent.getDragDistance();
            } else {
                return Konva.dragDistance;
            }
        },
        _get: function(selector) {
            return this.className === selector || this.nodeType === selector ? [this] : [];
        },
        _off: function(type, name) {
            var evtListeners = this.eventListeners[type],
                i, evtName;

            for(i = 0; i < evtListeners.length; i++) {
                evtName = evtListeners[i].name;
                // the following two conditions must be true in order to remove a handler:
                // 1) the current event name cannot be konva unless the event name is konva
                //    this enables developers to force remove a konva specific listener for whatever reason
                // 2) an event name is not specified, or if one is specified, it matches the current event name
                if((evtName !== 'konva' || name === 'konva') && (!name || evtName === name)) {
                    evtListeners.splice(i, 1);
                    if(evtListeners.length === 0) {
                        delete this.eventListeners[type];
                        break;
                    }
                    i--;
                }
            }
        },
        _fireChangeEvent: function(attr, oldVal, newVal) {
            this._fire(attr + CHANGE, {
                oldVal: oldVal,
                newVal: newVal
            });
        },
        setId: function(id) {
            var oldId = this.getId();

            Konva._removeId(oldId);
            Konva._addId(this, id);
            this._setAttr(ID, id);
            return this;
        },
        setName: function(name) {
            var oldNames = (this.getName() || '').split(/\s/g);
            var newNames = (name || '').split(/\s/g);
            var subname, i;
            // remove all subnames
            for(i = 0; i < oldNames.length; i++) {
                subname = oldNames[i];
                if ((newNames.indexOf(subname)) === -1 && subname) {
                    Konva._removeName(subname, this._id);
                }
            }

            // add new names
            for(i = 0; i < newNames.length; i++) {
                subname = newNames[i];
                if ((oldNames.indexOf(subname) === -1) && subname) {
                    Konva._addName(this, subname);
                }
            }

            this._setAttr(NAME, name);
            return this;
        },
        // naming methods
        /**
         * add name to node
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} name
         * @returns {Konva.Node}
         * @example
         * node.name('red');
         * node.addName('selected');
         * node.name(); // return 'red selected'
         */
        addName: function(name) {
            if (!this.hasName(name)) {
                var oldName = this.name();
                var newName = oldName ? (oldName + ' ' + name) : name;
                this.setName(newName);
            }
            return this;
        },
        /**
         * check is node has name
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} name
         * @returns {Boolean}
         * @example
         * node.name('red');
         * node.hasName('red');   // return true
         * node.hasName('selected'); // return false
         */
        hasName: function(name) {
            var names = (this.name() || '').split(/\s/g);
            return names.indexOf(name) !== -1;
        },
        /**
         * remove name from node
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} name
         * @returns {Konva.Node}
         * @example
         * node.name('red selected');
         * node.removeName('selected');
         * node.hasName('selected'); // return false
         * node.name(); // return 'red'
         */
        removeName: function(name) {
            var names = (this.name() || '').split(/\s/g);
            var index = names.indexOf(name);
            if (index !== -1) {
                names.splice(index, 1);
                this.setName(names.join(' '));
            }
        },
        /**
         * set attr
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} attr
         * @param {*} val
         * @returns {Konva.Node}
         * @example
         * node.setAttr('x', 5);
         */
        setAttr: function(attr, val) {
            var method = SET + Konva.Util._capitalize(attr),
                func = this[method];

            if(Konva.Util._isFunction(func)) {
                func.call(this, val);
            }
            // otherwise set directly
            else {
                this._setAttr(attr, val);
            }
            return this;
        },
        _setAttr: function(key, val) {
            var oldVal;
            if(val !== undefined) {
                oldVal = this.attrs[key];
                this.attrs[key] = val;
                this._fireChangeEvent(key, oldVal, val);
            }
        },
        _setComponentAttr: function(key, component, val) {
            var oldVal;
            if(val !== undefined) {
                oldVal = this.attrs[key];

                if (!oldVal) {
                    // set value to default value using getAttr
                    this.attrs[key] = this.getAttr(key);
                }

                this.attrs[key][component] = val;
                this._fireChangeEvent(key, oldVal, val);
            }
        },
        _fireAndBubble: function(eventType, evt, compareShape) {
            var okayToRun = true;

            if(evt && this.nodeType === SHAPE) {
                evt.target = this;
            }

            if(eventType === MOUSEENTER && compareShape && (this._id === compareShape._id || (this.isAncestorOf && this.isAncestorOf(compareShape)))) {
                okayToRun = false;
            }
            else if(eventType === MOUSELEAVE && compareShape && (this._id === compareShape._id || (this.isAncestorOf && this.isAncestorOf(compareShape)))) {
                okayToRun = false;
            }
            if(okayToRun) {
                this._fire(eventType, evt);

                // simulate event bubbling
                var stopBubble = (eventType === MOUSEENTER || eventType === MOUSELEAVE) && ((compareShape && compareShape.isAncestorOf && compareShape.isAncestorOf(this)) || !!(compareShape && compareShape.isAncestorOf));
                if(evt && !evt.cancelBubble && this.parent && this.parent.isListening() && (!stopBubble)) {
                    if(compareShape && compareShape.parent) {
                        this._fireAndBubble.call(this.parent, eventType, evt, compareShape.parent);
                    }
                    else {
                        this._fireAndBubble.call(this.parent, eventType, evt);
                    }
                }
            }
        },
        _fire: function(eventType, evt) {
            var events = this.eventListeners[eventType],
                i;

            evt.type = eventType;

            if (events) {
                for(i = 0; i < events.length; i++) {
                    events[i].handler.call(this, evt);
                }
            }
        },
        /**
         * draw both scene and hit graphs.  If the node being drawn is the stage, all of the layers will be cleared and redrawn
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Node}
         */
        draw: function() {
            this.drawScene();
            this.drawHit();
            return this;
        }
    });

    /**
     * create node with JSON string or an Object.  De-serializtion does not generate custom
     *  shape drawing functions, images, or event handlers (this would make the
     *  serialized object huge).  If your app uses custom shapes, images, and
     *  event handlers (it probably does), then you need to select the appropriate
     *  shapes after loading the stage and set these properties via on(), setDrawFunc(),
     *  and setImage() methods
     * @method
     * @memberof Konva.Node
     * @param {String|Object} json string or object
     * @param {Element} [container] optional container dom element used only if you're
     *  creating a stage node
     */
    Konva.Node.create = function(data, container) {
        if (Konva.Util._isString(data)) {
            data = JSON.parse(data);
        }
        return this._createNode(data, container);
    };
    Konva.Node._createNode = function(obj, container) {
        var className = Konva.Node.prototype.getClassName.call(obj),
            children = obj.children,
            no, len, n;

        // if container was passed in, add it to attrs
        if(container) {
            obj.attrs.container = container;
        }

        no = new Konva[className](obj.attrs);
        if(children) {
            len = children.length;
            for(n = 0; n < len; n++) {
                no.add(this._createNode(children[n]));
            }
        }

        return no;
    };


    // =========================== add getters setters ===========================

    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'position');
    /**
     * get/set node position relative to parent
     * @name position
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} pos
     * @param {Number} pos.x
     * @param {Number} pos.y
     * @returns {Object}
     * @example
     * // get position
     * var position = node.position();
     *
     * // set position
     * node.position({
     *   x: 5
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'x', 0);

    /**
     * get/set x position
     * @name x
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} x
     * @returns {Object}
     * @example
     * // get x
     * var x = node.x();
     *
     * // set x
     * node.x(5);
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'y', 0);

    /**
     * get/set y position
     * @name y
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} y
     * @returns {Integer}
     * @example
     * // get y
     * var y = node.y();
     *
     * // set y
     * node.y(5);
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'opacity', 1);

    /**
     * get/set opacity.  Opacity values range from 0 to 1.
     *  A node with an opacity of 0 is fully transparent, and a node
     *  with an opacity of 1 is fully opaque
     * @name opacity
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} opacity
     * @returns {Number}
     * @example
     * // get opacity
     * var opacity = node.opacity();
     *
     * // set opacity
     * node.opacity(0.5);
     */

    Konva.Factory.addGetter(Konva.Node, 'name');
    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'name');

    /**
     * get/set name
     * @name name
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} name
     * @returns {String}
     * @example
     * // get name
     * var name = node.name();
     *
     * // set name
     * node.name('foo');
     *
     * // also node may have multiple names (as css classes)
     * node.name('foo bar');
     */

    Konva.Factory.addGetter(Konva.Node, 'id');
    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'id');

    /**
     * get/set id. Id is global for whole page.
     * @name id
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} id
     * @returns {String}
     * @example
     * // get id
     * var name = node.id();
     *
     * // set id
     * node.id('foo');
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'rotation', 0);

    /**
     * get/set rotation in degrees
     * @name rotation
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} rotation
     * @returns {Number}
     * @example
     * // get rotation in degrees
     * var rotation = node.rotation();
     *
     * // set rotation in degrees
     * node.rotation(45);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Node, 'scale', ['x', 'y']);

    /**
     * get/set scale
     * @name scale
     * @param {Object} scale
     * @param {Number} scale.x
     * @param {Number} scale.y
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Object}
     * @example
     * // get scale
     * var scale = node.scale();
     *
     * // set scale
     * shape.scale({
     *   x: 2
     *   y: 3
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'scaleX', 1);

    /**
     * get/set scale x
     * @name scaleX
     * @param {Number} x
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Number}
     * @example
     * // get scale x
     * var scaleX = node.scaleX();
     *
     * // set scale x
     * node.scaleX(2);
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'scaleY', 1);

    /**
     * get/set scale y
     * @name scaleY
     * @param {Number} y
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Number}
     * @example
     * // get scale y
     * var scaleY = node.scaleY();
     *
     * // set scale y
     * node.scaleY(2);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Node, 'skew', ['x', 'y']);

    /**
     * get/set skew
     * @name skew
     * @param {Object} skew
     * @param {Number} skew.x
     * @param {Number} skew.y
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Object}
     * @example
     * // get skew
     * var skew = node.skew();
     *
     * // set skew
     * node.skew({
     *   x: 20
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'skewX', 0);

    /**
     * get/set skew x
     * @name skewX
     * @param {Number} x
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Number}
     * @example
     * // get skew x
     * var skewX = node.skewX();
     *
     * // set skew x
     * node.skewX(3);
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'skewY', 0);

    /**
     * get/set skew y
     * @name skewY
     * @param {Number} y
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Number}
     * @example
     * // get skew y
     * var skewY = node.skewY();
     *
     * // set skew y
     * node.skewY(3);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Node, 'offset', ['x', 'y']);

    /**
     * get/set offset.  Offsets the default position and rotation point
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} offset
     * @param {Number} offset.x
     * @param {Number} offset.y
     * @returns {Object}
     * @example
     * // get offset
     * var offset = node.offset();
     *
     * // set offset
     * node.offset({
     *   x: 20
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'offsetX', 0);

    /**
     * get/set offset x
     * @name offsetX
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get offset x
     * var offsetX = node.offsetX();
     *
     * // set offset x
     * node.offsetX(3);
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'offsetY', 0);

    /**
     * get/set offset y
     * @name offsetY
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get offset y
     * var offsetY = node.offsetY();
     *
     * // set offset y
     * node.offsetY(3);
     */

    Konva.Factory.addSetter(Konva.Node, 'dragDistance');
    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'dragDistance');

    /**
     * get/set drag distance
     * @name dragDistance
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} distance
     * @returns {Number}
     * @example
     * // get drag distance
     * var dragDistance = node.dragDistance();
     *
     * // set distance
     * // node starts dragging only if pointer moved more then 3 pixels
     * node.dragDistance(3);
     * // or set globally
     * Konva.dragDistance = 3;
     */


    Konva.Factory.addSetter(Konva.Node, 'width', 0);
    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'width');
    /**
     * get/set width
     * @name width
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} width
     * @returns {Number}
     * @example
     * // get width
     * var width = node.width();
     *
     * // set width
     * node.width(100);
     */

    Konva.Factory.addSetter(Konva.Node, 'height', 0);
    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'height');
    /**
     * get/set height
     * @name height
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} height
     * @returns {Number}
     * @example
     * // get height
     * var height = node.height();
     *
     * // set height
     * node.height(100);
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'listening', 'inherit');
    /**
     * get/set listenig attr.  If you need to determine if a node is listening or not
     *   by taking into account its parents, use the isListening() method
     * @name listening
     * @method
     * @memberof Konva.Node.prototype
     * @param {Boolean|String} listening Can be "inherit", true, or false.  The default is "inherit".
     * @returns {Boolean|String}
     * @example
     * // get listening attr
     * var listening = node.listening();
     *
     * // stop listening for events
     * node.listening(false);
     *
     * // listen for events
     * node.listening(true);
     *
     * // listen to events according to the parent
     * node.listening('inherit');
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'filters', undefined, function(val) {this._filterUpToDate = false; return val; });
    /**
     * get/set filters.  Filters are applied to cached canvases
     * @name filters
     * @method
     * @memberof Konva.Node.prototype
     * @param {Array} filters array of filters
     * @returns {Array}
     * @example
     * // get filters
     * var filters = node.filters();
     *
     * // set a single filter
     * node.cache();
     * node.filters([Konva.Filters.Blur]);
     *
     * // set multiple filters
     * node.cache();
     * node.filters([
     *   Konva.Filters.Blur,
     *   Konva.Filters.Sepia,
     *   Konva.Filters.Invert
     * ]);
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'visible', 'inherit');
    /**
     * get/set visible attr.  Can be "inherit", true, or false.  The default is "inherit".
     *   If you need to determine if a node is visible or not
     *   by taking into account its parents, use the isVisible() method
     * @name visible
     * @method
     * @memberof Konva.Node.prototype
     * @param {Boolean|String} visible
     * @returns {Boolean|String}
     * @example
     * // get visible attr
     * var visible = node.visible();
     *
     * // make invisible
     * node.visible(false);
     *
     * // make visible
     * node.visible(true);
     *
     * // make visible according to the parent
     * node.visible('inherit');
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'transformsEnabled', 'all');

    /**
     * get/set transforms that are enabled.  Can be "all", "none", or "position".  The default
     *  is "all"
     * @name transformsEnabled
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} enabled
     * @returns {String}
     * @example
     * // enable position transform only to improve draw performance
     * node.transformsEnabled('position');
     *
     * // enable all transforms
     * node.transformsEnabled('all');
     */



    /**
     * get/set node size
     * @name size
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} size
     * @param {Number} size.width
     * @param {Number} size.height
     * @returns {Object}
     * @example
     * // get node size
     * var size = node.size();
     * var x = size.x;
     * var y = size.y;
     *
     * // set size
     * node.size({
     *   width: 100,
     *   height: 200
     * });
     */
    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'size');

    Konva.Factory.backCompat(Konva.Node, {
        rotateDeg: 'rotate',
        setRotationDeg: 'setRotation',
        getRotationDeg: 'getRotation'
    });

    Konva.Collection.mapMethods(Konva.Node);
})(Konva);

(function() {
    'use strict';
    /**
    * Grayscale Filter
    * @function
    * @memberof Konva.Filters
    * @param {Object} imageData
    * @example
    * node.cache();
    * node.filters([Konva.Filters.Grayscale]);
    */
    Konva.Filters.Grayscale = function(imageData) {
        var data = imageData.data,
            len = data.length,
            i, brightness;

        for(i = 0; i < len; i += 4) {
            brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];
            // red
            data[i] = brightness;
            // green
            data[i + 1] = brightness;
            // blue
            data[i + 2] = brightness;
        }
    };
})();

(function() {
    'use strict';
    /**
     * Brighten Filter.
     * @function
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Brighten]);
     * node.brightness(0.8);
     */
    Konva.Filters.Brighten = function(imageData) {
        var brightness = this.brightness() * 255,
            data = imageData.data,
            len = data.length,
            i;

        for(i = 0; i < len; i += 4) {
            // red
            data[i] += brightness;
            // green
            data[i + 1] += brightness;
            // blue
            data[i + 2] += brightness;
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'brightness', 0, null, Konva.Factory.afterSetFilter);
    /**
    * get/set filter brightness.  The brightness is a number between -1 and 1.&nbsp; Positive values
    *  brighten the pixels and negative values darken them. Use with {@link Konva.Filters.Brighten} filter.
    * @name brightness
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} brightness value between -1 and 1
    * @returns {Number}
    */

})();

(function() {
    'use strict';
    /**
    * Invert Filter
    * @function
    * @memberof Konva.Filters
    * @param {Object} imageData
    * @example
    * node.cache();
    * node.filters([Konva.Filters.Invert]);
    */
    Konva.Filters.Invert = function(imageData) {
        var data = imageData.data,
            len = data.length,
            i;

        for(i = 0; i < len; i += 4) {
            // red
            data[i] = 255 - data[i];
            // green
            data[i + 1] = 255 - data[i + 1];
            // blue
            data[i + 2] = 255 - data[i + 2];
        }
    };
})();

/*
 the Gauss filter
 master repo: https://github.com/pavelpower/kineticjsGaussFilter
*/
(function() {
    'use strict';
    /*

     StackBlur - a fast almost Gaussian Blur For Canvas

     Version:   0.5
     Author:    Mario Klingemann
     Contact:   mario@quasimondo.com
     Website:   http://www.quasimondo.com/StackBlurForCanvas
     Twitter:   @quasimondo

     In case you find this class useful - especially in commercial projects -
     I am not totally unhappy for a small donation to my PayPal account
     mario@quasimondo.de

     Or support me on flattr:
     https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

     Copyright (c) 2010 Mario Klingemann

     Permission is hereby granted, free of charge, to any person
     obtaining a copy of this software and associated documentation
     files (the "Software"), to deal in the Software without
     restriction, including without limitation the rights to use,
     copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the
     Software is furnished to do so, subject to the following
     conditions:

     The above copyright notice and this permission notice shall be
     included in all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
     OTHER DEALINGS IN THE SOFTWARE.
     */

    function BlurStack() {
        this.r = 0;
        this.g = 0;
        this.b = 0;
        this.a = 0;
        this.next = null;
    }

    var mul_table = [
        512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512,
        454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512,
        482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456,
        437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512,
        497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328,
        320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456,
        446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335,
        329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512,
        505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405,
        399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328,
        324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271,
        268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456,
        451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388,
        385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335,
        332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292,
        289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259
    ];

    var shg_table = [
        9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17,
        17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19,
        19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
        20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
        21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
        21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,
        22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
        22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23,
        23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
        23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
        23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
        23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24
    ];

    function filterGaussBlurRGBA( imageData, radius) {

        var pixels = imageData.data,
            width = imageData.width,
            height = imageData.height;

        var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum,
            r_out_sum, g_out_sum, b_out_sum, a_out_sum,
            r_in_sum, g_in_sum, b_in_sum, a_in_sum,
            pr, pg, pb, pa, rbs;

        var div = radius + radius + 1,
            widthMinus1 = width - 1,
            heightMinus1 = height - 1,
            radiusPlus1 = radius + 1,
            sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2,
            stackStart = new BlurStack(),
            stackEnd = null,
            stack = stackStart,
            stackIn = null,
            stackOut = null,
            mul_sum = mul_table[radius],
            shg_sum = shg_table[radius];

        for ( i = 1; i < div; i++ ) {
            stack = stack.next = new BlurStack();
            if ( i === radiusPlus1 ){
                stackEnd = stack;
            }
        }

        stack.next = stackStart;

        yw = yi = 0;

        for ( y = 0; y < height; y++ )
        {
            r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;

            r_out_sum = radiusPlus1 * ( pr = pixels[yi] );
            g_out_sum = radiusPlus1 * ( pg = pixels[yi + 1] );
            b_out_sum = radiusPlus1 * ( pb = pixels[yi + 2] );
            a_out_sum = radiusPlus1 * ( pa = pixels[yi + 3] );

            r_sum += sumFactor * pr;
            g_sum += sumFactor * pg;
            b_sum += sumFactor * pb;
            a_sum += sumFactor * pa;

            stack = stackStart;

            for( i = 0; i < radiusPlus1; i++ )
            {
                stack.r = pr;
                stack.g = pg;
                stack.b = pb;
                stack.a = pa;
                stack = stack.next;
            }

            for( i = 1; i < radiusPlus1; i++ )
            {
                p = yi + (( widthMinus1 < i ? widthMinus1 : i ) << 2 );
                r_sum += ( stack.r = ( pr = pixels[p])) * ( rbs = radiusPlus1 - i );
                g_sum += ( stack.g = ( pg = pixels[p + 1])) * rbs;
                b_sum += ( stack.b = ( pb = pixels[p + 2])) * rbs;
                a_sum += ( stack.a = ( pa = pixels[p + 3])) * rbs;

                r_in_sum += pr;
                g_in_sum += pg;
                b_in_sum += pb;
                a_in_sum += pa;

                stack = stack.next;
            }


            stackIn = stackStart;
            stackOut = stackEnd;
            for ( x = 0; x < width; x++ )
            {
                pixels[yi + 3] = pa = (a_sum * mul_sum) >> shg_sum;
                if ( pa !== 0 )
                {
                    pa = 255 / pa;
                    pixels[yi] = ((r_sum * mul_sum) >> shg_sum) * pa;
                    pixels[yi + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
                    pixels[yi + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
                } else {
                    pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
                }

                r_sum -= r_out_sum;
                g_sum -= g_out_sum;
                b_sum -= b_out_sum;
                a_sum -= a_out_sum;

                r_out_sum -= stackIn.r;
                g_out_sum -= stackIn.g;
                b_out_sum -= stackIn.b;
                a_out_sum -= stackIn.a;

                p = (yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;

                r_in_sum += ( stackIn.r = pixels[p]);
                g_in_sum += ( stackIn.g = pixels[p + 1]);
                b_in_sum += ( stackIn.b = pixels[p + 2]);
                a_in_sum += ( stackIn.a = pixels[p + 3]);

                r_sum += r_in_sum;
                g_sum += g_in_sum;
                b_sum += b_in_sum;
                a_sum += a_in_sum;

                stackIn = stackIn.next;

                r_out_sum += ( pr = stackOut.r );
                g_out_sum += ( pg = stackOut.g );
                b_out_sum += ( pb = stackOut.b );
                a_out_sum += ( pa = stackOut.a );

                r_in_sum -= pr;
                g_in_sum -= pg;
                b_in_sum -= pb;
                a_in_sum -= pa;

                stackOut = stackOut.next;

                yi += 4;
            }
            yw += width;
        }


        for ( x = 0; x < width; x++ )
        {
            g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;

            yi = x << 2;
            r_out_sum = radiusPlus1 * ( pr = pixels[yi]);
            g_out_sum = radiusPlus1 * ( pg = pixels[yi + 1]);
            b_out_sum = radiusPlus1 * ( pb = pixels[yi + 2]);
            a_out_sum = radiusPlus1 * ( pa = pixels[yi + 3]);

            r_sum += sumFactor * pr;
            g_sum += sumFactor * pg;
            b_sum += sumFactor * pb;
            a_sum += sumFactor * pa;

            stack = stackStart;

            for( i = 0; i < radiusPlus1; i++ )
            {
                stack.r = pr;
                stack.g = pg;
                stack.b = pb;
                stack.a = pa;
                stack = stack.next;
            }

            yp = width;

            for( i = 1; i <= radius; i++ )
            {
                yi = ( yp + x ) << 2;

                r_sum += ( stack.r = ( pr = pixels[yi])) * ( rbs = radiusPlus1 - i );
                g_sum += ( stack.g = ( pg = pixels[yi + 1])) * rbs;
                b_sum += ( stack.b = ( pb = pixels[yi + 2])) * rbs;
                a_sum += ( stack.a = ( pa = pixels[yi + 3])) * rbs;

                r_in_sum += pr;
                g_in_sum += pg;
                b_in_sum += pb;
                a_in_sum += pa;

                stack = stack.next;

                if( i < heightMinus1 )
                {
                    yp += width;
                }
            }

            yi = x;
            stackIn = stackStart;
            stackOut = stackEnd;
            for ( y = 0; y < height; y++ )
            {
                p = yi << 2;
                pixels[p + 3] = pa = (a_sum * mul_sum) >> shg_sum;
                if ( pa > 0 )
                {
                    pa = 255 / pa;
                    pixels[p] = ((r_sum * mul_sum) >> shg_sum ) * pa;
                    pixels[p + 1] = ((g_sum * mul_sum) >> shg_sum ) * pa;
                    pixels[p + 2] = ((b_sum * mul_sum) >> shg_sum ) * pa;
                } else {
                    pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
                }

                r_sum -= r_out_sum;
                g_sum -= g_out_sum;
                b_sum -= b_out_sum;
                a_sum -= a_out_sum;

                r_out_sum -= stackIn.r;
                g_out_sum -= stackIn.g;
                b_out_sum -= stackIn.b;
                a_out_sum -= stackIn.a;

                p = ( x + (( ( p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1 ) * width )) << 2;

                r_sum += ( r_in_sum += ( stackIn.r = pixels[p]));
                g_sum += ( g_in_sum += ( stackIn.g = pixels[p + 1]));
                b_sum += ( b_in_sum += ( stackIn.b = pixels[p + 2]));
                a_sum += ( a_in_sum += ( stackIn.a = pixels[p + 3]));

                stackIn = stackIn.next;

                r_out_sum += ( pr = stackOut.r );
                g_out_sum += ( pg = stackOut.g );
                b_out_sum += ( pb = stackOut.b );
                a_out_sum += ( pa = stackOut.a );

                r_in_sum -= pr;
                g_in_sum -= pg;
                b_in_sum -= pb;
                a_in_sum -= pa;

                stackOut = stackOut.next;

                yi += width;
            }
        }
    }

    /**
     * Blur Filter
     * @function
     * @name Blur
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Blur]);
     * node.blurRadius(10);
     */
    Konva.Filters.Blur = function Blur(imageData) {
        var radius = Math.round(this.blurRadius());

        if (radius > 0) {
            filterGaussBlurRGBA(imageData, radius);
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'blurRadius', 0, null, Konva.Factory.afterSetFilter);

    /**
    * get/set blur radius. Use with {@link Konva.Filters.Blur} filter
    * @name blurRadius
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} radius
    * @returns {Integer}
    */
})();

/*eslint-disable  max-depth */
(function() {
	'use strict';
	function pixelAt(idata, x, y) {
		var idx = (y * idata.width + x) * 4;
		var d = [];
		d.push(idata.data[idx++], idata.data[idx++], idata.data[idx++], idata.data[idx++]);
		return d;
	}

	function rgbDistance(p1, p2) {
		return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2) + Math.pow(p1[2] - p2[2], 2));
	}

	function rgbMean(pTab) {
		var m = [0, 0, 0];

		for (var i = 0; i < pTab.length; i++) {
			m[0] += pTab[i][0];
			m[1] += pTab[i][1];
			m[2] += pTab[i][2];
		}

		m[0] /= pTab.length;
		m[1] /= pTab.length;
		m[2] /= pTab.length;

		return m;
	}

	function backgroundMask(idata, threshold) {
		var rgbv_no = pixelAt(idata, 0, 0);
		var rgbv_ne = pixelAt(idata, idata.width - 1, 0);
		var rgbv_so = pixelAt(idata, 0, idata.height - 1);
		var rgbv_se = pixelAt(idata, idata.width - 1, idata.height - 1);


		var thres = threshold || 10;
		if (rgbDistance(rgbv_no, rgbv_ne) < thres && rgbDistance(rgbv_ne, rgbv_se) < thres && rgbDistance(rgbv_se, rgbv_so) < thres && rgbDistance(rgbv_so, rgbv_no) < thres) {

			// Mean color
			var mean = rgbMean([rgbv_ne, rgbv_no, rgbv_se, rgbv_so]);

			// Mask based on color distance
			var mask = [];
			for (var i = 0; i < idata.width * idata.height; i++) {
				var d = rgbDistance(mean, [idata.data[i * 4], idata.data[i * 4 + 1], idata.data[i * 4 + 2]]);
				mask[i] = (d < thres) ? 0 : 255;
			}

			return mask;
		}
	}

	function applyMask(idata, mask) {
		for (var i = 0; i < idata.width * idata.height; i++) {
			idata.data[4 * i + 3] = mask[i];
		}
	}

	function erodeMask(mask, sw, sh) {

		var weights = [1, 1, 1, 1, 0, 1, 1, 1, 1];
		var side = Math.round(Math.sqrt(weights.length));
		var halfSide = Math.floor(side / 2);

		var maskResult = [];
		for (var y = 0; y < sh; y++) {
			for (var x = 0; x < sw; x++) {

				var so = y * sw + x;
				var a = 0;
				for (var cy = 0; cy < side; cy++) {
					for (var cx = 0; cx < side; cx++) {
						var scy = y + cy - halfSide;
						var scx = x + cx - halfSide;

						if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {

							var srcOff = scy * sw + scx;
							var wt = weights[cy * side + cx];

							a += mask[srcOff] * wt;
						}
					}
				}

				maskResult[so] = (a === 255 * 8) ? 255 : 0;
			}
		}

		return maskResult;
	}

	function dilateMask(mask, sw, sh) {

		var weights = [1, 1, 1, 1, 1, 1, 1, 1, 1];
		var side = Math.round(Math.sqrt(weights.length));
		var halfSide = Math.floor(side / 2);

		var maskResult = [];
		for (var y = 0; y < sh; y++) {
			for (var x = 0; x < sw; x++) {

				var so = y * sw + x;
				var a = 0;
				for (var cy = 0; cy < side; cy++) {
					for (var cx = 0; cx < side; cx++) {
						var scy = y + cy - halfSide;
						var scx = x + cx - halfSide;

						if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {

							var srcOff = scy * sw + scx;
							var wt = weights[cy * side + cx];

							a += mask[srcOff] * wt;
						}
					}
				}

				maskResult[so] = (a >= 255 * 4) ? 255 : 0;
			}
		}

		return maskResult;
	}

	function smoothEdgeMask(mask, sw, sh) {

		var weights = [1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9];
		var side = Math.round(Math.sqrt(weights.length));
		var halfSide = Math.floor(side / 2);

		var maskResult = [];
		for (var y = 0; y < sh; y++) {
			for (var x = 0; x < sw; x++) {

				var so = y * sw + x;
				var a = 0;
				for (var cy = 0; cy < side; cy++) {
					for (var cx = 0; cx < side; cx++) {
						var scy = y + cy - halfSide;
						var scx = x + cx - halfSide;

						if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {

							var srcOff = scy * sw + scx;
							var wt = weights[cy * side + cx];

							a += mask[srcOff] * wt;
						}
					}
				}

				maskResult[so] = a;
			}
		}

		return maskResult;
	}

	/**
	 * Mask Filter
	 * @function
	 * @name Mask
	 * @memberof Konva.Filters
	 * @param {Object} imageData
	 * @example
     * node.cache();
     * node.filters([Konva.Filters.Mask]);
     * node.threshold(200);
	 */
	Konva.Filters.Mask = function(imageData) {
		// Detect pixels close to the background color
		var threshold = this.threshold(),
        mask = backgroundMask(imageData, threshold);
		if (mask) {
			// Erode
			mask = erodeMask(mask, imageData.width, imageData.height);

			// Dilate
			mask = dilateMask(mask, imageData.width, imageData.height);

			// Gradient
			mask = smoothEdgeMask(mask, imageData.width, imageData.height);

			// Apply mask
			applyMask(imageData, mask);

			// todo : Update hit region function according to mask
		}

		return imageData;
	};

	Konva.Factory.addGetterSetter(Konva.Node, 'threshold', 0, null, Konva.Factory.afterSetFilter);
})();

(function () {
    'use strict';
    /**
     * RGB Filter
     * @function
     * @name RGB
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author ippo615
     * @example
     * node.cache();
     * node.filters([Konva.Filters.RGB]);
     * node.blue(120);
     * node.green(200);
     */
    Konva.Filters.RGB = function (imageData) {
        var data = imageData.data,
            nPixels = data.length,
            red = this.red(),
            green = this.green(),
            blue = this.blue(),
            i, brightness;

        for (i = 0; i < nPixels; i += 4) {
            brightness = (0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2]) / 255;
            data[i] = brightness * red; // r
            data[i + 1] = brightness * green; // g
            data[i + 2] = brightness * blue; // b
            data[i + 3] = data[i + 3]; // alpha
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'red', 0, function(val) {
        this._filterUpToDate = false;
        if (val > 255) {
            return 255;
        }
        else if (val < 0) {
            return 0;
        }
        else {
            return Math.round(val);
        }
    });
    /**
    * get/set filter red value. Use with {@link Konva.Filters.RGB} filter.
    * @name red
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} red value between 0 and 255
    * @returns {Integer}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'green', 0, function(val) {
        this._filterUpToDate = false;
        if (val > 255) {
            return 255;
        }
        else if (val < 0) {
            return 0;
        }
        else {
            return Math.round(val);
        }
    });
    /**
    * get/set filter green value. Use with {@link Konva.Filters.RGB} filter.
    * @name green
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} green value between 0 and 255
    * @returns {Integer}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'blue', 0, Konva.Validators.RGBComponent, Konva.Factory.afterSetFilter);
    /**
    * get/set filter blue value. Use with {@link Konva.Filters.RGB} filter.
    * @name blue
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} blue value between 0 and 255
    * @returns {Integer}
    */
})();

(function () {
    'use strict';
    /**
     * RGBA Filter
     * @function
     * @name RGBA
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author codefo
     * @example
     * node.cache();
     * node.filters([Konva.Filters.RGBA]);
     * node.blue(120);
     * node.green(200);
     * node.alpha(0.3);
     */
    Konva.Filters.RGBA = function (imageData) {
        var data = imageData.data,
            nPixels = data.length,
            red = this.red(),
            green = this.green(),
            blue = this.blue(),
            alpha = this.alpha(),
            i, ia;

        for (i = 0; i < nPixels; i += 4) {
            ia = 1 - alpha;

            data[i] = red * alpha + data[i] * ia; // r
            data[i + 1] = green * alpha + data[i + 1] * ia; // g
            data[i + 2] = blue * alpha + data[i + 2] * ia; // b
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'red', 0, function(val) {
        this._filterUpToDate = false;
        if (val > 255) {
            return 255;
        }
        else if (val < 0) {
            return 0;
        }
        else {
            return Math.round(val);
        }
    });
    /**
    * get/set filter red value. Use with {@link Konva.Filters.RGBA} filter.
    * @name red
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} red value between 0 and 255
    * @returns {Integer}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'green', 0, function(val) {
        this._filterUpToDate = false;
        if (val > 255) {
            return 255;
        }
        else if (val < 0) {
            return 0;
        }
        else {
            return Math.round(val);
        }
    });
    /**
    * get/set filter green value. Use with {@link Konva.Filters.RGBA} filter.
    * @name green
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} green value between 0 and 255
    * @returns {Integer}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'blue', 0, Konva.Validators.RGBComponent, Konva.Factory.afterSetFilter);
    /**
    * get/set filter blue value. Use with {@link Konva.Filters.RGBA} filter.
    * @name blue
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} blue value between 0 and 255
    * @returns {Integer}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'alpha', 1, function(val) {
        this._filterUpToDate = false;
        if (val > 1) {
            return 1;
        }
        else if (val < 0) {
            return 0;
        }
        else {
            return val;
        }
    });
    /**
     * get/set filter alpha value. Use with {@link Konva.Filters.RGBA} filter.
     * @name alpha
     * @method
     * @memberof Konva.Node.prototype
     * @param {Float} alpha value between 0 and 1
     * @returns {Float}
     */
})();

(function () {
    'use strict';
    /**
    * HSV Filter. Adjusts the hue, saturation and value
    * @function
    * @name HSV
    * @memberof Konva.Filters
    * @param {Object} imageData
    * @author ippo615
    * @example
    * image.filters([Konva.Filters.HSV]);
    * image.value(200);
    */

    Konva.Filters.HSV = function (imageData) {
        var data = imageData.data,
            nPixels = data.length,
            v = Math.pow(2, this.value()),
            s = Math.pow(2, this.saturation()),
            h = Math.abs((this.hue()) + 360) % 360,
            i;

        // Basis for the technique used:
        // http://beesbuzz.biz/code/hsv_color_transforms.php
        // V is the value multiplier (1 for none, 2 for double, 0.5 for half)
        // S is the saturation multiplier (1 for none, 2 for double, 0.5 for half)
        // H is the hue shift in degrees (0 to 360)
        // vsu = V*S*cos(H*PI/180);
        // vsw = V*S*sin(H*PI/180);
        //[ .299V+.701vsu+.168vsw    .587V-.587vsu+.330vsw    .114V-.114vsu-.497vsw ] [R]
        //[ .299V-.299vsu-.328vsw    .587V+.413vsu+.035vsw    .114V-.114vsu+.292vsw ]*[G]
        //[ .299V-.300vsu+1.25vsw    .587V-.588vsu-1.05vsw    .114V+.886vsu-.203vsw ] [B]

        // Precompute the values in the matrix:
        var vsu = v * s * Math.cos(h * Math.PI / 180),
            vsw = v * s * Math.sin(h * Math.PI / 180);
        // (result spot)(source spot)
        var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw,
            rg = 0.587 * v - 0.587 * vsu + 0.330 * vsw,
            rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
        var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw,
            gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw,
            gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
        var br = 0.299 * v - 0.300 * vsu + 1.250 * vsw,
            bg = 0.587 * v - 0.586 * vsu - 1.050 * vsw,
            bb = 0.114 * v + 0.886 * vsu - 0.200 * vsw;

        var r, g, b, a;

        for (i = 0; i < nPixels; i += 4) {
            r = data[i + 0];
            g = data[i + 1];
            b = data[i + 2];
            a = data[i + 3];

            data[i + 0] = rr * r + rg * g + rb * b;
            data[i + 1] = gr * r + gg * g + gb * b;
            data[i + 2] = br * r + bg * g + bb * b;
            data[i + 3] = a; // alpha
        }

    };

    Konva.Factory.addGetterSetter(Konva.Node, 'hue', 0, null, Konva.Factory.afterSetFilter);
    /**
    * get/set hsv hue in degrees. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
    * @name hue
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} hue value between 0 and 359
    * @returns {Number}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'saturation', 0, null, Konva.Factory.afterSetFilter);
    /**
    * get/set hsv saturation. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
    * @name saturation
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} saturation 0 is no change, -1.0 halves the saturation, 1.0 doubles, etc..
    * @returns {Number}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'value', 0, null, Konva.Factory.afterSetFilter);
    /**
    * get/set hsv value. Use with {@link Konva.Filters.HSV} filter.
    * @name value
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} value 0 is no change, -1.0 halves the value, 1.0 doubles, etc..
    * @returns {Number}
    */

})();

(function () {
    'use strict';

    Konva.Factory.addGetterSetter(Konva.Node, 'hue', 0, null, Konva.Factory.afterSetFilter);
    /**
    * get/set hsv hue in degrees. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
    * @name hue
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} hue value between 0 and 359
    * @returns {Number}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'saturation', 0, null, Konva.Factory.afterSetFilter);
    /**
    * get/set hsv saturation. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
    * @name saturation
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} saturation 0 is no change, -1.0 halves the saturation, 1.0 doubles, etc..
    * @returns {Number}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'luminance', 0, null, Konva.Factory.afterSetFilter);
    /**
    * get/set hsl luminance. Use with {@link Konva.Filters.HSL} filter.
    * @name value
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} value 0 is no change, -1.0 halves the value, 1.0 doubles, etc..
    * @returns {Number}
    */

    /**
    * HSL Filter. Adjusts the hue, saturation and luminance (or lightness)
    * @function
    * @memberof Konva.Filters
    * @param {Object} imageData
    * @author ippo615
    * @example
    * image.filters([Konva.Filters.HSL]);
    * image.luminance(200);
    */

    Konva.Filters.HSL = function (imageData) {
        var data = imageData.data,
            nPixels = data.length,
            v = 1,
            s = Math.pow(2, this.saturation()),
            h = Math.abs((this.hue()) + 360) % 360,
            l = this.luminance() * 127,
            i;

        // Basis for the technique used:
        // http://beesbuzz.biz/code/hsv_color_transforms.php
        // V is the value multiplier (1 for none, 2 for double, 0.5 for half)
        // S is the saturation multiplier (1 for none, 2 for double, 0.5 for half)
        // H is the hue shift in degrees (0 to 360)
        // vsu = V*S*cos(H*PI/180);
        // vsw = V*S*sin(H*PI/180);
        //[ .299V+.701vsu+.168vsw    .587V-.587vsu+.330vsw    .114V-.114vsu-.497vsw ] [R]
        //[ .299V-.299vsu-.328vsw    .587V+.413vsu+.035vsw    .114V-.114vsu+.292vsw ]*[G]
        //[ .299V-.300vsu+1.25vsw    .587V-.588vsu-1.05vsw    .114V+.886vsu-.203vsw ] [B]

        // Precompute the values in the matrix:
        var vsu = v * s * Math.cos(h * Math.PI / 180),
            vsw = v * s * Math.sin(h * Math.PI / 180);
        // (result spot)(source spot)
        var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw,
            rg = 0.587 * v - 0.587 * vsu + 0.330 * vsw,
            rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
        var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw,
            gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw,
            gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
        var br = 0.299 * v - 0.300 * vsu + 1.250 * vsw,
            bg = 0.587 * v - 0.586 * vsu - 1.050 * vsw,
            bb = 0.114 * v + 0.886 * vsu - 0.200 * vsw;

        var r, g, b, a;

        for (i = 0; i < nPixels; i += 4) {
            r = data[i + 0];
            g = data[i + 1];
            b = data[i + 2];
            a = data[i + 3];

            data[i + 0] = rr * r + rg * g + rb * b + l;
            data[i + 1] = gr * r + gg * g + gb * b + l;
            data[i + 2] = br * r + bg * g + bb * b + l;
            data[i + 3] = a; // alpha
        }
    };
})();

(function () {
    'use strict';
    /**
     * Emboss Filter.
     * Pixastic Lib - Emboss filter - v0.1.0
     * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
     * License: [http://www.pixastic.com/lib/license.txt]
     * @function
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Emboss]);
     * node.embossStrength(0.8);
     * node.embossWhiteLevel(0.3);
     * node.embossDirection('right');
     * node.embossBlend(true);
     */
    Konva.Filters.Emboss = function (imageData) {

        // pixastic strength is between 0 and 10.  I want it between 0 and 1
        // pixastic greyLevel is between 0 and 255.  I want it between 0 and 1.  Also,
        // a max value of greyLevel yields a white emboss, and the min value yields a black
        // emboss.  Therefore, I changed greyLevel to whiteLevel
        var strength = this.embossStrength() * 10,
            greyLevel = this.embossWhiteLevel() * 255,
            direction = this.embossDirection(),
            blend = this.embossBlend(),
            dirY = 0,
            dirX = 0,
            data = imageData.data,
            w = imageData.width,
            h = imageData.height,
            w4 = w * 4,
            y = h;

        switch (direction) {
            case 'top-left':
                dirY = -1;
                dirX = -1;
                break;
            case 'top':
                dirY = -1;
                dirX = 0;
                break;
            case 'top-right':
                dirY = -1;
                dirX = 1;
                break;
            case 'right':
                dirY = 0;
                dirX = 1;
                break;
            case 'bottom-right':
                dirY = 1;
                dirX = 1;
                break;
            case 'bottom':
                dirY = 1;
                dirX = 0;
                break;
            case 'bottom-left':
                dirY = 1;
                dirX = -1;
                break;
            case 'left':
                dirY = 0;
                dirX = -1;
                break;
        }

        do {
            var offsetY = (y - 1) * w4;

            var otherY = dirY;
            if (y + otherY < 1){
                otherY = 0;
            }
            if (y + otherY > h) {
                otherY = 0;
            }

            var offsetYOther = (y - 1 + otherY) * w * 4;

            var x = w;
            do {
                var offset = offsetY + (x - 1) * 4;

                var otherX = dirX;
                if (x + otherX < 1){
                    otherX = 0;
                }
                if (x + otherX > w) {
                    otherX = 0;
                }

                var offsetOther = offsetYOther + (x - 1 + otherX) * 4;

                var dR = data[offset] - data[offsetOther];
                var dG = data[offset + 1] - data[offsetOther + 1];
                var dB = data[offset + 2] - data[offsetOther + 2];

                var dif = dR;
                var absDif = dif > 0 ? dif : -dif;

                var absG = dG > 0 ? dG : -dG;
                var absB = dB > 0 ? dB : -dB;

                if (absG > absDif) {
                    dif = dG;
                }
                if (absB > absDif) {
                    dif = dB;
                }

                dif *= strength;

                if (blend) {
                    var r = data[offset] + dif;
                    var g = data[offset + 1] + dif;
                    var b = data[offset + 2] + dif;

                    data[offset] = (r > 255) ? 255 : (r < 0 ? 0 : r);
                    data[offset + 1] = (g > 255) ? 255 : (g < 0 ? 0 : g);
                    data[offset + 2] = (b > 255) ? 255 : (b < 0 ? 0 : b);
                } else {
                    var grey = greyLevel - dif;
                    if (grey < 0) {
                        grey = 0;
                    } else if (grey > 255) {
                        grey = 255;
                    }

                    data[offset] = data[offset + 1] = data[offset + 2] = grey;
                }

            } while (--x);
        } while (--y);
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'embossStrength', 0.5, null, Konva.Factory.afterSetFilter);
    /**
    * get/set emboss strength. Use with {@link Konva.Filters.Emboss} filter.
    * @name embossStrength
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} level between 0 and 1.  Default is 0.5
    * @returns {Number}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'embossWhiteLevel', 0.5, null, Konva.Factory.afterSetFilter);
    /**
    * get/set emboss white level. Use with {@link Konva.Filters.Emboss} filter.
    * @name embossWhiteLevel
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} embossWhiteLevel between 0 and 1.  Default is 0.5
    * @returns {Number}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'embossDirection', 'top-left', null, Konva.Factory.afterSetFilter);
    /**
    * get/set emboss direction. Use with {@link Konva.Filters.Emboss} filter.
    * @name embossDirection
    * @method
    * @memberof Konva.Node.prototype
    * @param {String} embossDirection can be top-left, top, top-right, right, bottom-right, bottom, bottom-left or left
    *   The default is top-left
    * @returns {String}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'embossBlend', false, null, Konva.Factory.afterSetFilter);
    /**
    * get/set emboss blend. Use with {@link Konva.Filters.Emboss} filter.
    * @name embossBlend
    * @method
    * @memberof Konva.Node.prototype
    * @param {Boolean} embossBlend
    * @returns {Boolean}
    */
})();

(function () {
    'use strict';
    function remap(fromValue, fromMin, fromMax, toMin, toMax) {
        // Compute the range of the data
        var fromRange = fromMax - fromMin,
          toRange = toMax - toMin,
          toValue;

        // If either range is 0, then the value can only be mapped to 1 value
        if (fromRange === 0) {
            return toMin + toRange / 2;
        }
        if (toRange === 0) {
            return toMin;
        }

        // (1) untranslate, (2) unscale, (3) rescale, (4) retranslate
        toValue = (fromValue - fromMin) / fromRange;
        toValue = (toRange * toValue) + toMin;

        return toValue;
    }


    /**
    * Enhance Filter. Adjusts the colors so that they span the widest
    *  possible range (ie 0-255). Performs w*h pixel reads and w*h pixel
    *  writes.
    * @function
    * @name Enhance
    * @memberof Konva.Filters
    * @param {Object} imageData
    * @author ippo615
    * @example
    * node.cache();
    * node.filters([Konva.Filters.Enhance]);
    * node.enhance(0.4);
    */
    Konva.Filters.Enhance = function (imageData) {
        var data = imageData.data,
            nSubPixels = data.length,
            rMin = data[0], rMax = rMin, r,
            gMin = data[1], gMax = gMin, g,
            bMin = data[2], bMax = bMin, b,
            i;

        // If we are not enhancing anything - don't do any computation
        var enhanceAmount = this.enhance();
        if( enhanceAmount === 0 ){ return; }

        // 1st Pass - find the min and max for each channel:
        for (i = 0; i < nSubPixels; i += 4) {
            r = data[i + 0];
            if (r < rMin) { rMin = r; }
            else if (r > rMax) { rMax = r; }
            g = data[i + 1];
            if (g < gMin) { gMin = g; } else
            if (g > gMax) { gMax = g; }
            b = data[i + 2];
            if (b < bMin) { bMin = b; } else
            if (b > bMax) { bMax = b; }
            //a = data[i + 3];
            //if (a < aMin) { aMin = a; } else
            //if (a > aMax) { aMax = a; }
        }

        // If there is only 1 level - don't remap
        if( rMax === rMin ){ rMax = 255; rMin = 0; }
        if( gMax === gMin ){ gMax = 255; gMin = 0; }
        if( bMax === bMin ){ bMax = 255; bMin = 0; }

        var rMid, rGoalMax, rGoalMin,
            gMid, gGoalMax, gGoalMin,
            bMid, bGoalMax, bGoalMin;

        // If the enhancement is positive - stretch the histogram
        if ( enhanceAmount > 0 ){
            rGoalMax = rMax + enhanceAmount * (255 - rMax);
            rGoalMin = rMin - enhanceAmount * (rMin - 0);
            gGoalMax = gMax + enhanceAmount * (255 - gMax);
            gGoalMin = gMin - enhanceAmount * (gMin - 0);
            bGoalMax = bMax + enhanceAmount * (255 - bMax);
            bGoalMin = bMin - enhanceAmount * (bMin - 0);
        // If the enhancement is negative -   compress the histogram
        } else {
            rMid = (rMax + rMin) * 0.5;
            rGoalMax = rMax + enhanceAmount * (rMax - rMid);
            rGoalMin = rMin + enhanceAmount * (rMin - rMid);
            gMid = (gMax + gMin) * 0.5;
            gGoalMax = gMax + enhanceAmount * (gMax - gMid);
            gGoalMin = gMin + enhanceAmount * (gMin - gMid);
            bMid = (bMax + bMin) * 0.5;
            bGoalMax = bMax + enhanceAmount * (bMax - bMid);
            bGoalMin = bMin + enhanceAmount * (bMin - bMid);
        }

        // Pass 2 - remap everything, except the alpha
        for (i = 0; i < nSubPixels; i += 4) {
            data[i + 0] = remap(data[i + 0], rMin, rMax, rGoalMin, rGoalMax);
            data[i + 1] = remap(data[i + 1], gMin, gMax, gGoalMin, gGoalMax);
            data[i + 2] = remap(data[i + 2], bMin, bMax, bGoalMin, bGoalMax);
            //data[i + 3] = remap(data[i + 3], aMin, aMax, aGoalMin, aGoalMax);
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'enhance', 0, null, Konva.Factory.afterSetFilter);

    /**
    * get/set enhance. Use with {@link Konva.Filters.Enhance} filter.
    * @name enhance
    * @method
    * @memberof Konva.Node.prototype
    * @param {Float} amount
    * @returns {Float}
    */
})();

(function () {
    'use strict';
    /**
     * Posterize Filter. Adjusts the channels so that there are no more
     *  than n different values for that channel. This is also applied
     *  to the alpha channel.
     * @function
     * @name Posterize
     * @author ippo615
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Posterize]);
     * node.levels(0.8);
     */

    Konva.Filters.Posterize = function (imageData) {
        // level must be between 1 and 255
        var levels = Math.round(this.levels() * 254) + 1,
            data = imageData.data,
            len = data.length,
            scale = (255 / levels),
            i;

        for (i = 0; i < len; i += 1) {
            data[i] = Math.floor(data[i] / scale) * scale;
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'levels', 0.5, null, Konva.Factory.afterSetFilter);

    /**
    * get/set levels.  Must be a number between 0 and 1.  Use with {@link Konva.Filters.Posterize} filter.
    * @name levels
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} level between 0 and 1
    * @returns {Number}
    */
})();

(function () {
    'use strict';

    /**
     * Noise Filter. Randomly adds or substracts to the color channels
     * @function
     * @name Noise
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author ippo615
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Noise]);
     * node.noise(0.8);
     */
    Konva.Filters.Noise = function (imageData) {
        var amount = this.noise() * 255,
            data = imageData.data,
            nPixels = data.length,
            half = amount / 2,
            i;

        for (i = 0; i < nPixels; i += 4) {
            data[i + 0] += half - 2 * half * Math.random();
            data[i + 1] += half - 2 * half * Math.random();
            data[i + 2] += half - 2 * half * Math.random();
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'noise', 0.2, null, Konva.Factory.afterSetFilter);

    /**
    * get/set noise amount.  Must be a value between 0 and 1. Use with {@link Konva.Filters.Noise} filter.
    * @name noise
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} noise
    * @returns {Number}
    */
})();

/*eslint-disable max-depth */
(function () {
    'use strict';
    /**
     * Pixelate Filter. Averages groups of pixels and redraws
     *  them as larger pixels
     * @function
     * @name Pixelate
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author ippo615
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Pixelate]);
     * node.pixelSize(10);
     */

    Konva.Filters.Pixelate = function (imageData) {

        var pixelSize = Math.ceil(this.pixelSize()),
            width = imageData.width,
            height = imageData.height,
            x, y, i,
            //pixelsPerBin = pixelSize * pixelSize,
            red, green, blue, alpha,
            nBinsX = Math.ceil(width / pixelSize),
            nBinsY = Math.ceil(height / pixelSize),
            xBinStart, xBinEnd, yBinStart, yBinEnd,
            xBin, yBin, pixelsInBin;
        imageData = imageData.data;

        for (xBin = 0; xBin < nBinsX; xBin += 1) {
            for (yBin = 0; yBin < nBinsY; yBin += 1) {

                // Initialize the color accumlators to 0
                red = 0;
                green = 0;
                blue = 0;
                alpha = 0;

                // Determine which pixels are included in this bin
                xBinStart = xBin * pixelSize;
                xBinEnd = xBinStart + pixelSize;
                yBinStart = yBin * pixelSize;
                yBinEnd = yBinStart + pixelSize;

                // Add all of the pixels to this bin!
                pixelsInBin = 0;
                for (x = xBinStart; x < xBinEnd; x += 1) {
                    if( x >= width ){ continue; }
                    for (y = yBinStart; y < yBinEnd; y += 1) {
                        if( y >= height ){ continue; }
                        i = (width * y + x) * 4;
                        red += imageData[i + 0];
                        green += imageData[i + 1];
                        blue += imageData[i + 2];
                        alpha += imageData[i + 3];
                        pixelsInBin += 1;
                    }
                }

                // Make sure the channels are between 0-255
                red = red / pixelsInBin;
                green = green / pixelsInBin;
                blue = blue / pixelsInBin;

                // Draw this bin
                for (x = xBinStart; x < xBinEnd; x += 1) {
                    if( x >= width ){ continue; }
                    for (y = yBinStart; y < yBinEnd; y += 1) {
                        if( y >= height ){ continue; }
                        i = (width * y + x) * 4;
                        imageData[i + 0] = red;
                        imageData[i + 1] = green;
                        imageData[i + 2] = blue;
                        imageData[i + 3] = alpha;
                    }
                }
            }
        }

    };

    Konva.Factory.addGetterSetter(Konva.Node, 'pixelSize', 8, null, Konva.Factory.afterSetFilter);

    /**
    * get/set pixel size. Use with {@link Konva.Filters.Pixelate} filter.
    * @name pixelSize
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} pixelSize
    * @returns {Integer}
    */
})();

(function () {
    'use strict';
    /**
     * Threshold Filter. Pushes any value above the mid point to
     *  the max and any value below the mid point to the min.
     *  This affects the alpha channel.
     * @function
     * @name Threshold
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author ippo615
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Threshold]);
     * node.threshold(0.1);
     */

    Konva.Filters.Threshold = function (imageData) {
        var level = this.threshold() * 255,
            data = imageData.data,
            len = data.length,
            i;

        for (i = 0; i < len; i += 1) {
            data[i] = data[i] < level ? 0 : 255;
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'threshold', 0.5, null, Konva.Factory.afterSetFilter);

    /**
    * get/set threshold.  Must be a value between 0 and 1. Use with {@link Konva.Filters.Threshold} or {@link Konva.Filters.Mask} filter.
    * @name threshold
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} threshold
    * @returns {Number}
    */
})();

(function() {
    'use strict';
    /**
     * Sepia Filter
     * Based on: Pixastic Lib - Sepia filter - v0.1.0
     * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
     * @function
     * @name Sepia
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author Jacob Seidelin <jseidelin@nihilogic.dk>
     * @license MPL v1.1 [http://www.pixastic.com/lib/license.txt]
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Sepia]);
     */
    Konva.Filters.Sepia = function (imageData) {
        var data = imageData.data,
            w = imageData.width,
            y = imageData.height,
            w4 = w * 4,
            offsetY, x, offset, or, og, ob, r, g, b;

        do {
            offsetY = (y - 1) * w4;
            x = w;
            do {
                offset = offsetY + (x - 1) * 4;

                or = data[offset];
                og = data[offset + 1];
                ob = data[offset + 2];

                r = or * 0.393 + og * 0.769 + ob * 0.189;
                g = or * 0.349 + og * 0.686 + ob * 0.168;
                b = or * 0.272 + og * 0.534 + ob * 0.131;

                data[offset] = r > 255 ? 255 : r;
                data[offset + 1] = g > 255 ? 255 : g;
                data[offset + 2] = b > 255 ? 255 : b;
                data[offset + 3] = data[offset + 3];
            } while (--x);
        } while (--y);
    };
})();

(function () {
    'use strict';
    /**
     * Solarize Filter
     * Pixastic Lib - Solarize filter - v0.1.0
     * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
     * License: [http://www.pixastic.com/lib/license.txt]
     * @function
     * @name Solarize
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Solarize]);
     */
    Konva.Filters.Solarize = function (imageData) {
        var data = imageData.data,
            w = imageData.width,
            h = imageData.height,
            w4 = w * 4,
            y = h;

        do {
            var offsetY = (y - 1) * w4;
            var x = w;
            do {
                var offset = offsetY + (x - 1) * 4;
                var r = data[offset];
                var g = data[offset + 1];
                var b = data[offset + 2];

                if (r > 127) {
                    r = 255 - r;
                }
                if (g > 127) {
                    g = 255 - g;
                }
                if (b > 127) {
                    b = 255 - b;
                }

                data[offset] = r;
                data[offset + 1] = g;
                data[offset + 2] = b;
            } while (--x);
        } while (--y);
    };
})();



(function () {
    'use strict';

  /*
   * ToPolar Filter. Converts image data to polar coordinates. Performs
   *  w*h*4 pixel reads and w*h pixel writes. The r axis is placed along
   *  what would be the y axis and the theta axis along the x axis.
   * @function
   * @author ippo615
   * @memberof Konva.Filters
   * @param {ImageData} src, the source image data (what will be transformed)
   * @param {ImageData} dst, the destination image data (where it will be saved)
   * @param {Object} opt
   * @param {Number} [opt.polarCenterX] horizontal location for the center of the circle,
   *  default is in the middle
   * @param {Number} [opt.polarCenterY] vertical location for the center of the circle,
   *  default is in the middle
   */

    var ToPolar = function(src, dst, opt){

        var srcPixels = src.data,
            dstPixels = dst.data,
            xSize = src.width,
            ySize = src.height,
            xMid = opt.polarCenterX || xSize / 2,
            yMid = opt.polarCenterY || ySize / 2,
            i, x, y, r = 0, g = 0, b = 0, a = 0;

        // Find the largest radius
        var rad, rMax = Math.sqrt( xMid * xMid + yMid * yMid );
        x = xSize - xMid;
        y = ySize - yMid;
        rad = Math.sqrt( x * x + y * y );
        rMax = (rad > rMax) ? rad : rMax;

        // We'll be uisng y as the radius, and x as the angle (theta=t)
        var rSize = ySize,
            tSize = xSize,
            radius, theta;

        // We want to cover all angles (0-360) and we need to convert to
        // radians (*PI/180)
        var conversion = 360 / tSize * Math.PI / 180, sin, cos;

        // var x1, x2, x1i, x2i, y1, y2, y1i, y2i, scale;

        for( theta = 0; theta < tSize; theta += 1 ){
            sin = Math.sin(theta * conversion);
            cos = Math.cos(theta * conversion);
            for( radius = 0; radius < rSize; radius += 1 ){
                x = Math.floor(xMid + rMax * radius / rSize * cos);
                y = Math.floor(yMid + rMax * radius / rSize * sin);
                i = (y * xSize + x) * 4;
                r = srcPixels[i + 0];
                g = srcPixels[i + 1];
                b = srcPixels[i + 2];
                a = srcPixels[i + 3];

                // Store it
                //i = (theta * xSize  +  radius) * 4;
                i = (theta + radius * xSize) * 4;
                dstPixels[i + 0] = r;
                dstPixels[i + 1] = g;
                dstPixels[i + 2] = b;
                dstPixels[i + 3] = a;

            }
        }
    };

    /*
     * FromPolar Filter. Converts image data from polar coordinates back to rectangular.
     *  Performs w*h*4 pixel reads and w*h pixel writes.
     * @function
     * @author ippo615
     * @memberof Konva.Filters
     * @param {ImageData} src, the source image data (what will be transformed)
     * @param {ImageData} dst, the destination image data (where it will be saved)
     * @param {Object} opt
     * @param {Number} [opt.polarCenterX] horizontal location for the center of the circle,
     *  default is in the middle
     * @param {Number} [opt.polarCenterY] vertical location for the center of the circle,
     *  default is in the middle
     * @param {Number} [opt.polarRotation] amount to rotate the image counterclockwis,
     *  0 is no rotation, 360 degrees is a full rotation
     */

    var FromPolar = function(src, dst, opt){

        var srcPixels = src.data,
            dstPixels = dst.data,
            xSize = src.width,
            ySize = src.height,
            xMid = opt.polarCenterX || xSize / 2,
            yMid = opt.polarCenterY || ySize / 2,
            i, x, y, dx, dy, r = 0, g = 0, b = 0, a = 0;


        // Find the largest radius
        var rad, rMax = Math.sqrt( xMid * xMid + yMid * yMid );
        x = xSize - xMid;
        y = ySize - yMid;
        rad = Math.sqrt( x * x + y * y );
        rMax = (rad > rMax) ? rad : rMax;

        // We'll be uisng x as the radius, and y as the angle (theta=t)
        var rSize = ySize,
        tSize = xSize,
        radius, theta,
        phaseShift = opt.polarRotation || 0;

        // We need to convert to degrees and we need to make sure
        // it's between (0-360)
        // var conversion = tSize/360*180/Math.PI;
        //var conversion = tSize/360*180/Math.PI;

        var x1, y1;

        for( x = 0; x < xSize; x += 1 ){
            for( y = 0; y < ySize; y += 1 ){
                dx = x - xMid;
                dy = y - yMid;
                radius = Math.sqrt(dx * dx + dy * dy) * rSize / rMax;
                theta = (Math.atan2(dy, dx) * 180 / Math.PI + 360 + phaseShift) % 360;
                theta = theta * tSize / 360;
                x1 = Math.floor(theta);
                y1 = Math.floor(radius);
                i = (y1 * xSize + x1) * 4;
                r = srcPixels[i + 0];
                g = srcPixels[i + 1];
                b = srcPixels[i + 2];
                a = srcPixels[i + 3];

                // Store it
                i = (y * xSize + x) * 4;
                dstPixels[i + 0] = r;
                dstPixels[i + 1] = g;
                dstPixels[i + 2] = b;
                dstPixels[i + 3] = a;
            }
        }

    };

    //Konva.Filters.ToPolar = Konva.Util._FilterWrapDoubleBuffer(ToPolar);
    //Konva.Filters.FromPolar = Konva.Util._FilterWrapDoubleBuffer(FromPolar);

    // create a temporary canvas for working - shared between multiple calls
    var tempCanvas = Konva.Util.createCanvasElement();

    /*
     * Kaleidoscope Filter.
     * @function
     * @name Kaleidoscope
     * @author ippo615
     * @memberof Konva.Filters
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Kaleidoscope]);
     * node.kaleidoscopePower(3);
     * node.kaleidoscopeAngle(45);
     */
    Konva.Filters.Kaleidoscope = function(imageData){
        var xSize = imageData.width,
            ySize = imageData.height;

        var x, y, xoff, i, r, g, b, a, srcPos, dstPos;
        var power = Math.round( this.kaleidoscopePower() );
        var angle = Math.round( this.kaleidoscopeAngle() );
        var offset = Math.floor(xSize * (angle % 360) / 360);

        if( power < 1 ){return; }

        // Work with our shared buffer canvas
        tempCanvas.width = xSize;
        tempCanvas.height = ySize;
        var scratchData = tempCanvas.getContext('2d').getImageData(0, 0, xSize, ySize);

        // Convert thhe original to polar coordinates
        ToPolar( imageData, scratchData, {
            polarCenterX: xSize / 2,
            polarCenterY: ySize / 2
        });

        // Determine how big each section will be, if it's too small
        // make it bigger
        var minSectionSize = xSize / Math.pow(2, power);
        while( minSectionSize <= 8){
            minSectionSize = minSectionSize * 2;
            power -= 1;
        }
        minSectionSize = Math.ceil(minSectionSize);
        var sectionSize = minSectionSize;

        // Copy the offset region to 0
        // Depending on the size of filter and location of the offset we may need
        // to copy the section backwards to prevent it from rewriting itself
        var xStart = 0,
          xEnd = sectionSize,
          xDelta = 1;
        if( offset + minSectionSize > xSize ){
            xStart = sectionSize;
            xEnd = 0;
            xDelta = -1;
        }
        for( y = 0; y < ySize; y += 1 ){
            for( x = xStart; x !== xEnd; x += xDelta ){
                xoff = Math.round(x + offset) % xSize;
                srcPos = (xSize * y + xoff) * 4;
                r = scratchData.data[srcPos + 0];
                g = scratchData.data[srcPos + 1];
                b = scratchData.data[srcPos + 2];
                a = scratchData.data[srcPos + 3];
                dstPos = (xSize * y + x) * 4;
                scratchData.data[dstPos + 0] = r;
                scratchData.data[dstPos + 1] = g;
                scratchData.data[dstPos + 2] = b;
                scratchData.data[dstPos + 3] = a;
            }
        }

        // Perform the actual effect
        for( y = 0; y < ySize; y += 1 ){
            sectionSize = Math.floor( minSectionSize );
            for( i = 0; i < power; i += 1 ){
                for( x = 0; x < sectionSize + 1; x += 1 ){
                    srcPos = (xSize * y + x) * 4;
                    r = scratchData.data[srcPos + 0];
                    g = scratchData.data[srcPos + 1];
                    b = scratchData.data[srcPos + 2];
                    a = scratchData.data[srcPos + 3];
                    dstPos = (xSize * y + sectionSize * 2 - x - 1) * 4;
                    scratchData.data[dstPos + 0] = r;
                    scratchData.data[dstPos + 1] = g;
                    scratchData.data[dstPos + 2] = b;
                    scratchData.data[dstPos + 3] = a;
                }
                sectionSize *= 2;
            }
        }

        // Convert back from polar coordinates
        FromPolar(scratchData, imageData, {polarRotation: 0});
    };

    /**
    * get/set kaleidoscope power. Use with {@link Konva.Filters.Kaleidoscope} filter.
    * @name kaleidoscopePower
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} power of kaleidoscope
    * @returns {Integer}
    */
    Konva.Factory.addGetterSetter(Konva.Node, 'kaleidoscopePower', 2, null, Konva.Factory.afterSetFilter);

    /**
    * get/set kaleidoscope angle. Use with {@link Konva.Filters.Kaleidoscope} filter.
    * @name kaleidoscopeAngle
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} degrees
    * @returns {Integer}
    */
    Konva.Factory.addGetterSetter(Konva.Node, 'kaleidoscopeAngle', 0, null, Konva.Factory.afterSetFilter);

})();

(function() {
    'use strict';

    function isValidSelector(selector) {
        if (typeof selector !== 'string') {
            return false;
        }
        var firstChar = selector[0];
        return firstChar === '#' || firstChar === '.' || firstChar === firstChar.toUpperCase();
    }
    /**
     * Container constructor.&nbsp; Containers are used to contain nodes or other containers
     * @constructor
     * @memberof Konva
     * @augments Konva.Node
     * @abstract
     * @param {Object} config
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height

     */
    Konva.Container = function(config) {
        this.__init(config);
    };

    Konva.Util.addMethods(Konva.Container, {
        __init: function(config) {
            this.children = new Konva.Collection();
            Konva.Node.call(this, config);
        },
        /**
         * returns a {@link Konva.Collection} of direct descendant nodes
         * @method
         * @memberof Konva.Container.prototype
         * @param {Function} [filterFunc] filter function
         * @returns {Konva.Collection}
         * @example
         * // get all children
         * var children = layer.getChildren();
         *
         * // get only circles
         * var circles = layer.getChildren(function(node){
         *    return node.getClassName() === 'Circle';
         * });
         */
        getChildren: function(filterFunc) {
            if (!filterFunc) {
                return this.children;
            }

            var results = new Konva.Collection();
            this.children.each(function(child){
                if (filterFunc(child)) {
                    results.push(child);
                }
            });
            return results;
        },
        /**
         * determine if node has children
         * @method
         * @memberof Konva.Container.prototype
         * @returns {Boolean}
         */
        hasChildren: function() {
            return this.getChildren().length > 0;
        },
        /**
         * remove all children
         * @method
         * @memberof Konva.Container.prototype
         */
        removeChildren: function() {
            var children = Konva.Collection.toCollection(this.children);
            var child;
            for (var i = 0; i < children.length; i++) {
                child = children[i];
                // reset parent to prevent many _setChildrenIndices calls
                delete child.parent;
                child.index = 0;
                if (child.hasChildren()) {
                    child.removeChildren();
                }
                child.remove();
            }
            children = null;
            this.children = new Konva.Collection();
            return this;
        },
        /**
         * destroy all children
         * @method
         * @memberof Konva.Container.prototype
         */
        destroyChildren: function() {
           var children = Konva.Collection.toCollection(this.children);
            var child;
            for (var i = 0; i < children.length; i++) {
                child = children[i];
                // reset parent to prevent many _setChildrenIndices calls
                delete child.parent;
                child.index = 0;
                child.destroy();
            }
            children = null;
            this.children = new Konva.Collection();
            return this;
        },
        /**
         * Add node or nodes to container.
         * @method
         * @memberof Konva.Container.prototype
         * @param {...Konva.Node} child
         * @returns {Container}
         * @example
         * layer.add(shape1, shape2, shape3);
         */
        add: function(child) {
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) {
                    this.add(arguments[i]);
                }
                return this;
            }
            if (child.getParent()) {
                child.moveTo(this);
                return this;
            }
            var children = this.children;
            this._validateAdd(child);
            child.index = children.length;
            child.parent = this;
            children.push(child);
            this._fire('add', {
                child: child
            });

            // if node under drag we need to update drag animation
            if (Konva.DD && child.isDragging()) {
                Konva.DD.anim.setLayers(child.getLayer());
            }

            // chainable
            return this;
        },
        destroy: function() {
            // destroy children
            if (this.hasChildren()) {
                this.destroyChildren();
            }
            // then destroy self
            Konva.Node.prototype.destroy.call(this);
        },
        /**
         * return a {@link Konva.Collection} of nodes that match the selector.  Use '#' for id selections
         * and '.' for name selections.  You can also select by type or class name. Pass multiple selectors
         * separated by a space.
         * @method
         * @memberof Konva.Container.prototype
         * @param {String} selector
         * @returns {Collection}
         * @example
         * // select node with id foo
         * var node = stage.find('#foo');
         *
         * // select nodes with name bar inside layer
         * var nodes = layer.find('.bar');
         *
         * // select all groups inside layer
         * var nodes = layer.find('Group');
         *
         * // select all rectangles inside layer
         * var nodes = layer.find('Rect');
         *
         * // select node with an id of foo or a name of bar inside layer
         * var nodes = layer.find('#foo, .bar');
         */
        find: function(selector) {
            var retArr = [],
                selectorArr = selector.replace(/ /g, '').split(','),
                len = selectorArr.length,
                n, i, sel, arr, node, children, clen;

            for (n = 0; n < len; n++) {
                sel = selectorArr[n];
                if (!isValidSelector(sel)) {
                    Konva.Util.warn('Selector "' + sel + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".');
                    Konva.Util.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".');
                    Konva.Util.warn('Konva is awesome, right?');
                }
                // id selector
                if(sel.charAt(0) === '#') {
                    node = this._getNodeById(sel.slice(1));
                    if(node) {
                        retArr.push(node);
                    }
                }
                // name selector
                else if(sel.charAt(0) === '.') {
                    arr = this._getNodesByName(sel.slice(1));
                    retArr = retArr.concat(arr);
                }
                // unrecognized selector, pass to children
                else {
                    children = this.getChildren();
                    clen = children.length;
                    for(i = 0; i < clen; i++) {
                        retArr = retArr.concat(children[i]._get(sel));
                    }
                }
            }

            return Konva.Collection.toCollection(retArr);
        },
        /**
         * return a first node from `find` method
         * @method
         * @memberof Konva.Container.prototype
         * @param {String} selector
         * @returns {Konva.Node}
         * @example
         * // select node with id foo
         * var node = stage.findOne('#foo');
         *
         * // select node with name bar inside layer
         * var nodes = layer.findOne('.bar');
         */
        findOne: function(selector) {
            return this.find(selector)[0];
        },
        _getNodeById: function(key) {
            var node = Konva.ids[key];

            if(node !== undefined && this.isAncestorOf(node)) {
                return node;
            }
            return null;
        },
        _getNodesByName: function(key) {
            var arr = Konva.names[key] || [];
            return this._getDescendants(arr);
        },
        _get: function(selector) {
            var retArr = Konva.Node.prototype._get.call(this, selector);
            var children = this.getChildren();
            var len = children.length;
            for(var n = 0; n < len; n++) {
                retArr = retArr.concat(children[n]._get(selector));
            }
            return retArr;
        },
        // extenders
        toObject: function() {
            var obj = Konva.Node.prototype.toObject.call(this);

            obj.children = [];

            var children = this.getChildren();
            var len = children.length;
            for(var n = 0; n < len; n++) {
                var child = children[n];
                obj.children.push(child.toObject());
            }

            return obj;
        },
        _getDescendants: function(arr) {
            var retArr = [];
            var len = arr.length;
            for(var n = 0; n < len; n++) {
                var node = arr[n];
                if(this.isAncestorOf(node)) {
                    retArr.push(node);
                }
            }

            return retArr;
        },
        /**
         * determine if node is an ancestor
         * of descendant
         * @method
         * @memberof Konva.Container.prototype
         * @param {Konva.Node} node
         */
        isAncestorOf: function(node) {
            var parent = node.getParent();
            while(parent) {
                if(parent._id === this._id) {
                    return true;
                }
                parent = parent.getParent();
            }

            return false;
        },
        clone: function(obj) {
            // call super method
            var node = Konva.Node.prototype.clone.call(this, obj);

            this.getChildren().each(function(no) {
                node.add(no.clone());
            });
            return node;
        },
        /**
         * get all shapes that intersect a point.  Note: because this method must clear a temporary
         * canvas and redraw every shape inside the container, it should only be used for special sitations
         * because it performs very poorly.  Please use the {@link Konva.Stage#getIntersection} method if at all possible
         * because it performs much better
         * @method
         * @memberof Konva.Container.prototype
         * @param {Object} pos
         * @param {Number} pos.x
         * @param {Number} pos.y
         * @returns {Array} array of shapes
         */
        getAllIntersections: function(pos) {
            var arr = [];

            this.find('Shape').each(function(shape) {
                if(shape.isVisible() && shape.intersects(pos)) {
                    arr.push(shape);
                }
            });

            return arr;
        },
        _setChildrenIndices: function() {
            this.children.each(function(child, n) {
                child.index = n;
            });
        },
        drawScene: function(can, top, caching) {
            var layer = this.getLayer(),
                canvas = can || (layer && layer.getCanvas()),
                context = canvas && canvas.getContext(),
                cachedCanvas = this._cache.canvas,
                cachedSceneCanvas = cachedCanvas && cachedCanvas.scene;

            if (this.isVisible()) {
                if (!caching && cachedSceneCanvas) {
                    context.save();
                    layer._applyTransform(this, context, top);
                    this._drawCachedSceneCanvas(context);
                    context.restore();
                }
                else {
                    this._drawChildren(canvas, 'drawScene', top, false, caching);
                }
            }
            return this;
        },
        drawHit: function(can, top, caching) {
            var layer = this.getLayer(),
                canvas = can || (layer && layer.hitCanvas),
                context = canvas && canvas.getContext(),
                cachedCanvas = this._cache.canvas,
                cachedHitCanvas = cachedCanvas && cachedCanvas.hit;

            if (this.shouldDrawHit(canvas)) {
                if (layer) {
                    layer.clearHitCache();
                }
                if (!caching && cachedHitCanvas) {
                    context.save();
                    layer._applyTransform(this, context, top);
                    this._drawCachedHitCanvas(context);
                    context.restore();
                }
                else {
                    this._drawChildren(canvas, 'drawHit', top);
                }
            }
            return this;
        },
        _drawChildren: function(canvas, drawMethod, top, caching, skipBuffer) {
            var layer = this.getLayer(),
                context = canvas && canvas.getContext(),
                clipWidth = this.getClipWidth(),
                clipHeight = this.getClipHeight(),
                hasClip = clipWidth && clipHeight,
                clipX, clipY;

            if (hasClip && layer) {
                clipX = this.getClipX();
                clipY = this.getClipY();

                context.save();
                layer._applyTransform(this, context);
                context.beginPath();
                context.rect(clipX, clipY, clipWidth, clipHeight);
                context.clip();
                context.reset();
            }

            this.children.each(function(child) {
                child[drawMethod](canvas, top, caching, skipBuffer);
            });

            if (hasClip) {
                context.restore();
            }
        },
        shouldDrawHit: function(canvas) {
            var layer = this.getLayer();
            var dd = Konva.DD;
            var layerUnderDrag = dd && Konva.isDragging() && (Konva.DD.anim.getLayers().indexOf(layer) !== -1);
            return (canvas && canvas.isCache) || (layer && layer.hitGraphEnabled())
                && this.isVisible() && !layerUnderDrag;
        },
        getClientRect: function(skipTransform) {
            var minX, minY, maxX, maxY;
            var selfRect = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            };
            this.children.each(function(child) {
                var rect = child.getClientRect();

                // skip invisible children (like empty groups)
                // or don't skip... hmmm...
                // if (rect.width === 0 && rect.height === 0) {
                //     return;
                // }

                if (minX === undefined) { // initial value for first child
                    minX = rect.x;
                    minY = rect.y;
                    maxX = rect.x + rect.width;
                    maxY = rect.y + rect.height;
                } else {
                    minX = Math.min(minX, rect.x);
                    minY = Math.min(minY, rect.y);
                    maxX = Math.max(maxX, rect.x + rect.width);
                    maxY = Math.max(maxY, rect.y + rect.height);
                }

            });

            if (this.children.length !== 0) {
                selfRect = {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            }

            if (!skipTransform) {
                return this._transformedRect(selfRect);
            }
            return selfRect;
        }
    });

    Konva.Util.extend(Konva.Container, Konva.Node);
    // deprecated methods
    Konva.Container.prototype.get = Konva.Container.prototype.find;

    // add getters setters
    Konva.Factory.addComponentsGetterSetter(Konva.Container, 'clip', ['x', 'y', 'width', 'height']);
    /**
     * get/set clip
     * @method
     * @name clip
     * @memberof Konva.Container.prototype
     * @param {Object} clip
     * @param {Number} clip.x
     * @param {Number} clip.y
     * @param {Number} clip.width
     * @param {Number} clip.height
     * @returns {Object}
     * @example
     * // get clip
     * var clip = container.clip();
     *
     * // set clip
     * container.setClip({
     *   x: 20,
     *   y: 20,
     *   width: 20,
     *   height: 20
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Container, 'clipX');
    /**
     * get/set clip x
     * @name clipX
     * @method
     * @memberof Konva.Container.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get clip x
     * var clipX = container.clipX();
     *
     * // set clip x
     * container.clipX(10);
     */

    Konva.Factory.addGetterSetter(Konva.Container, 'clipY');
    /**
     * get/set clip y
     * @name clipY
     * @method
     * @memberof Konva.Container.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get clip y
     * var clipY = container.clipY();
     *
     * // set clip y
     * container.clipY(10);
     */

    Konva.Factory.addGetterSetter(Konva.Container, 'clipWidth');
    /**
     * get/set clip width
     * @name clipWidth
     * @method
     * @memberof Konva.Container.prototype
     * @param {Number} width
     * @returns {Number}
     * @example
     * // get clip width
     * var clipWidth = container.clipWidth();
     *
     * // set clip width
     * container.clipWidth(100);
     */

    Konva.Factory.addGetterSetter(Konva.Container, 'clipHeight');
    /**
     * get/set clip height
     * @name clipHeight
     * @method
     * @memberof Konva.Container.prototype
     * @param {Number} height
     * @returns {Number}
     * @example
     * // get clip height
     * var clipHeight = container.clipHeight();
     *
     * // set clip height
     * container.clipHeight(100);
     */

    Konva.Collection.mapMethods(Konva.Container);
})();

(function(Konva) {
    'use strict';
    var HAS_SHADOW = 'hasShadow';
    var SHADOW_RGBA = 'shadowRGBA';

    function _fillFunc(context) {
        context.fill();
    }
    function _strokeFunc(context) {
        context.stroke();
    }
    function _fillFuncHit(context) {
        context.fill();
    }
    function _strokeFuncHit(context) {
        context.stroke();
    }

    function _clearHasShadowCache() {
        this._clearCache(HAS_SHADOW);
    }

    function _clearGetShadowRGBACache() {
        this._clearCache(SHADOW_RGBA);
    }

    /**
     * Shape constructor.  Shapes are primitive objects such as rectangles,
     *  circles, text, lines, etc.
     * @constructor
     * @memberof Konva
     * @augments Konva.Node
     * @param {Object} config
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var customShape = new Konva.Shape({
         *   x: 5,
         *   y: 10,
         *   fill: 'red',
         *   // a Konva.Canvas renderer is passed into the drawFunc function
         *   drawFunc: function(context) {
         *     context.beginPath();
         *     context.moveTo(200, 50);
         *     context.lineTo(420, 80);
         *     context.quadraticCurveTo(300, 100, 260, 170);
         *     context.closePath();
         *     context.fillStrokeShape(this);
         *   }
         *});
     */
    Konva.Shape = function(config) {
        this.__init(config);
    };

    Konva.Util.addMethods(Konva.Shape, {
        __init: function(config) {
            this.nodeType = 'Shape';
            this._fillFunc = _fillFunc;
            this._strokeFunc = _strokeFunc;
            this._fillFuncHit = _fillFuncHit;
            this._strokeFuncHit = _strokeFuncHit;

            // set colorKey
            var shapes = Konva.shapes;
            var key;

            while(true) {
                key = Konva.Util.getRandomColor();
                if(key && !( key in shapes)) {
                    break;
                }
            }

            this.colorKey = key;
            shapes[key] = this;

            // call super constructor
            Konva.Node.call(this, config);

            this.on('shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearHasShadowCache);

            this.on('shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearGetShadowRGBACache);
        },
        hasChildren: function() {
            return false;
        },
        getChildren: function() {
            return [];
        },
        /**
         * get canvas context tied to the layer
         * @method
         * @memberof Konva.Shape.prototype
         * @returns {Konva.Context}
         */
        getContext: function() {
            return this.getLayer().getContext();
        },
        /**
         * get canvas renderer tied to the layer.  Note that this returns a canvas renderer, not a canvas element
         * @method
         * @memberof Konva.Shape.prototype
         * @returns {Konva.Canvas}
         */
        getCanvas: function() {
            return this.getLayer().getCanvas();
        },
        /**
         * returns whether or not a shadow will be rendered
         * @method
         * @memberof Konva.Shape.prototype
         * @returns {Boolean}
         */
        hasShadow: function() {
            return this._getCache(HAS_SHADOW, this._hasShadow);
        },
        _hasShadow: function() {
            return this.getShadowEnabled() && (this.getShadowOpacity() !== 0 && !!(this.getShadowColor() || this.getShadowBlur() || this.getShadowOffsetX() || this.getShadowOffsetY()));
        },
        getShadowRGBA: function() {
            return this._getCache(SHADOW_RGBA, this._getShadowRGBA);
        },
        _getShadowRGBA: function() {
            if (this.hasShadow()) {
                var rgba = Konva.Util.colorToRGBA(this.shadowColor());
                return 'rgba(' + rgba.r + ',' + rgba.g + ',' + rgba.b + ',' + (rgba.a * (this.getShadowOpacity() || 1)) + ')';
            }
        },
        /**
         * returns whether or not the shape will be filled
         * @method
         * @memberof Konva.Shape.prototype
         * @returns {Boolean}
         */
        hasFill: function() {
            return !!(this.getFill() || this.getFillPatternImage() || this.getFillLinearGradientColorStops() || this.getFillRadialGradientColorStops());
        },
        /**
         * returns whether or not the shape will be stroked
         * @method
         * @memberof Konva.Shape.prototype
         * @returns {Boolean}
         */
        hasStroke: function() {
            return !!(this.stroke());
        },
        /**
         * determines if point is in the shape, regardless if other shapes are on top of it.  Note: because
         *  this method clears a temporary canvas and then redraws the shape, it performs very poorly if executed many times
         *  consecutively.  Please use the {@link Konva.Stage#getIntersection} method if at all possible
         *  because it performs much better
         * @method
         * @memberof Konva.Shape.prototype
         * @param {Object} point
         * @param {Number} point.x
         * @param {Number} point.y
         * @returns {Boolean}
         */
        intersects: function(point) {
            var stage = this.getStage(),
                bufferHitCanvas = stage.bufferHitCanvas,
                p;

            bufferHitCanvas.getContext().clear();
            this.drawScene(bufferHitCanvas);
            p = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;
            return p[3] > 0;
        },
        // extends Node.prototype.destroy
        destroy: function() {
            Konva.Node.prototype.destroy.call(this);
            delete Konva.shapes[this.colorKey];
        },
        _useBufferCanvas: function(caching) {
            return !caching && (this.perfectDrawEnabled() && (this.getAbsoluteOpacity() !== 1) && this.hasFill() && this.hasStroke() && this.getStage()) ||
                   (this.perfectDrawEnabled() && this.hasShadow() && (this.getAbsoluteOpacity() !== 1) && this.hasFill() && this.hasStroke() && this.getStage());
        },
        /**
         * return self rectangle (x, y, width, height) of shape.
         * This method are not taken into account transformation and styles.
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Object} rect with {x, y, width, height} properties
         * @example
         *
         * rect.getSelfRect();  // return {x:0, y:0, width:rect.width(), height:rect.height()}
         * circle.getSelfRect();  // return {x: - circle.width() / 2, y: - circle.height() / 2, width:circle.width(), height:circle.height()}
         *
         */
        getSelfRect: function() {
            var size = this.getSize();
            return {
                x: this._centroid ? Math.round(-size.width / 2) : 0,
                y: this._centroid ? Math.round(-size.height / 2) : 0,
                width: size.width,
                height: size.height
            };
        },
        getClientRect: function(skipTransform) {
            var fillRect = this.getSelfRect();

            var strokeWidth = (this.hasStroke() && this.strokeWidth()) || 0;
            var fillAndStrokeWidth = fillRect.width + strokeWidth;
            var fillAndStrokeHeight = fillRect.height + strokeWidth;

            var shadowOffsetX = this.shadowOffsetX();
            var shadowOffsetY = this.shadowOffsetY();

            var preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);
            var preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);

            var blurRadius = (this.hasShadow() && this.shadowBlur() || 0);

            var width = preWidth + blurRadius * 2;
            var height = preHeight + blurRadius * 2;

            // if stroke, for example = 3
            // we need to set x to 1.5, but after Math.round it will be 2
            // as we have additional offset we need to increase width and height by 1 pixel
            var roundingOffset = 0;
            if (Math.round(strokeWidth / 2) !== strokeWidth / 2) {
                roundingOffset = 1;
            }
            var rect = {
                width: width + roundingOffset,
                height: height + roundingOffset,
                x: -Math.round(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetX, 0) + fillRect.x,
                y: -Math.round(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetY, 0) + fillRect.y
            };
            if (!skipTransform) {
                return this._transformedRect(rect);
            }
            return rect;
        },
        drawScene: function(can, top, caching, skipBuffer) {
            var layer = this.getLayer(),
                canvas = can || layer.getCanvas(),
                context = canvas.getContext(),
                cachedCanvas = this._cache.canvas,
                drawFunc = this.sceneFunc(),
                hasShadow = this.hasShadow(),
                hasStroke = this.hasStroke(),
                stage, bufferCanvas, bufferContext;

            if(!this.isVisible()) {
                return this;
            }
            if (cachedCanvas) {
                context.save();
                layer._applyTransform(this, context, top);
                this._drawCachedSceneCanvas(context);
                context.restore();
                return this;
            }
            if (!drawFunc) {
                return this;
            }
            context.save();
            // if buffer canvas is needed
            if (this._useBufferCanvas(caching) && !skipBuffer) {
                stage = this.getStage();
                bufferCanvas = stage.bufferCanvas;
                bufferContext = bufferCanvas.getContext();
                bufferContext.clear();
                bufferContext.save();
                bufferContext._applyLineJoin(this);
                // layer might be undefined if we are using cache before adding to layer
                if (!caching) {
                    if (layer) {
                        layer._applyTransform(this, bufferContext, top);
                    } else {
                        var m = this.getAbsoluteTransform(top).getMatrix();
                        context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
                    }
                }

                drawFunc.call(this, bufferContext);
                bufferContext.restore();

                if (hasShadow && !canvas.hitCanvas) {
                        context.save();
                        context._applyShadow(this);
                        context._applyOpacity(this);
                        context.drawImage(bufferCanvas._canvas, 0, 0);
                        context.restore();
                } else {
                    context._applyOpacity(this);
                    context.drawImage(bufferCanvas._canvas, 0, 0);
                }
            }
            // if buffer canvas is not needed
            else {
                context._applyLineJoin(this);
                // layer might be undefined if we are using cache before adding to layer
                if (!caching) {
                    if (layer) {
                        layer._applyTransform(this, context, top);
                    } else {
                        var o = this.getAbsoluteTransform(top).getMatrix();
                        context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
                    }
                }

                if (hasShadow && hasStroke && !canvas.hitCanvas) {
                    context.save();
                    // apply shadow
                    if (!caching) {
                        context._applyOpacity(this);
                    }
                    context._applyShadow(this);
                    drawFunc.call(this, context);
                    context.restore();
                    // if shape has stroke we need to redraw shape
                    // otherwise we will see a shadow under stroke (and over fill)
                    // but I think this is unexpected behavior
                    if (this.hasFill() && this.getShadowForStrokeEnabled()) {
                        drawFunc.call(this, context);
                    }
                } else if (hasShadow && !canvas.hitCanvas) {
                    context.save();
                    if (!caching) {
                        context._applyOpacity(this);
                    }
                    context._applyShadow(this);
                    drawFunc.call(this, context);
                    context.restore();
                } else {
                    if (!caching) {
                        context._applyOpacity(this);
                    }
                    drawFunc.call(this, context);
                }
            }
            context.restore();
            return this;
        },
        drawHit: function(can, top, caching) {
            var layer = this.getLayer(),
                canvas = can || layer.hitCanvas,
                context = canvas.getContext(),
                drawFunc = this.hitFunc() || this.sceneFunc(),
                cachedCanvas = this._cache.canvas,
                cachedHitCanvas = cachedCanvas && cachedCanvas.hit;

            if(!this.shouldDrawHit(canvas)) {
                return this;
            }
            if (layer) {
                layer.clearHitCache();
            }
            if (cachedHitCanvas) {
                context.save();
                layer._applyTransform(this, context, top);
                this._drawCachedHitCanvas(context);
                context.restore();
                return this;
            }
            if (!drawFunc) {
                return this;
            }
            context.save();
            context._applyLineJoin(this);
            if (!caching) {
                if (layer) {
                    layer._applyTransform(this, context, top);
                } else {
                    var o = this.getAbsoluteTransform(top).getMatrix();
                    context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
                }
            }
            drawFunc.call(this, context);
            context.restore();
            return this;
        },
        /**
        * draw hit graph using the cached scene canvas
        * @method
        * @memberof Konva.Shape.prototype
        * @param {Integer} alphaThreshold alpha channel threshold that determines whether or not
        *  a pixel should be drawn onto the hit graph.  Must be a value between 0 and 255.
        *  The default is 0
        * @returns {Konva.Shape}
        * @example
        * shape.cache();
        * shape.drawHitFromCache();
        */
        drawHitFromCache: function(alphaThreshold) {
            var threshold = alphaThreshold || 0,
                cachedCanvas = this._cache.canvas,
                sceneCanvas = this._getCachedSceneCanvas(),
                hitCanvas = cachedCanvas.hit,
                hitContext = hitCanvas.getContext(),
                hitWidth = hitCanvas.getWidth(),
                hitHeight = hitCanvas.getHeight(),
                hitImageData, hitData, len, rgbColorKey, i, alpha;

            hitContext.clear();
            hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);

            try {
                hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);
                hitData = hitImageData.data;
                len = hitData.length;
                rgbColorKey = Konva.Util._hexToRgb(this.colorKey);

                // replace non transparent pixels with color key
                for(i = 0; i < len; i += 4) {
                    alpha = hitData[i + 3];
                    if (alpha > threshold) {
                        hitData[i] = rgbColorKey.r;
                        hitData[i + 1] = rgbColorKey.g;
                        hitData[i + 2] = rgbColorKey.b;
                        hitData[i + 3] = 255;
                    }
                    else {
                        hitData[i + 3] = 0;
                    }
                }
                hitContext.putImageData(hitImageData, 0, 0);
            }
            catch(e) {
                Konva.Util.error('Unable to draw hit graph from cached scene canvas. ' + e.message);
            }

            return this;
        }
    });
    Konva.Util.extend(Konva.Shape, Konva.Node);

    // add getters and setters
    Konva.Factory.addGetterSetter(Konva.Shape, 'stroke');

    /**
     * get/set stroke color
     * @name stroke
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} color
     * @returns {String}
     * @example
     * // get stroke color
     * var stroke = shape.stroke();
     *
     * // set stroke color with color string
     * shape.stroke('green');
     *
     * // set stroke color with hex
     * shape.stroke('#00ff00');
     *
     * // set stroke color with rgb
     * shape.stroke('rgb(0,255,0)');
     *
     * // set stroke color with rgba and make it 50% opaque
     * shape.stroke('rgba(0,255,0,0.5');
     */

    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'strokeRed', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'strokeGreen', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'strokeBlue', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'strokeAlpha', 1, Konva.Validators.alphaComponent);


    Konva.Factory.addGetterSetter(Konva.Shape, 'strokeWidth', 2);

    /**
     * get/set stroke width
     * @name strokeWidth
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} strokeWidth
     * @returns {Number}
     * @example
     * // get stroke width
     * var strokeWidth = shape.strokeWidth();
     *
     * // set stroke width
     * shape.strokeWidth();
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'strokeHitEnabled', true);

    /**
     * get/set strokeHitEnabled property. Useful for performance optimization.
     * You may set `shape.strokeHitEnabled(false)`. In this case stroke will be no draw on hit canvas, so hit area
     * of shape will be decreased (by lineWidth / 2). Remember that non closed line with `strokeHitEnabled = false`
     * will be not drawn on hit canvas, that is mean line will no trigger pointer events (like mouseover)
     * Default value is true
     * @name strokeHitEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} strokeHitEnabled
     * @returns {Boolean}
     * @example
     * // get strokeHitEnabled
     * var strokeHitEnabled = shape.strokeHitEnabled();
     *
     * // set strokeHitEnabled
     * shape.strokeHitEnabled();
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'perfectDrawEnabled', true);

    /**
     * get/set perfectDrawEnabled. If a shape has fill, stroke and opacity you may set `perfectDrawEnabled` to improve performance.
     * See http://konvajs.github.io/docs/performance/Disable_Perfect_Draw.html for more information.
     * Default value is true
     * @name perfectDrawEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} perfectDrawEnabled
     * @returns {Boolean}
     * @example
     * // get perfectDrawEnabled
     * var perfectDrawEnabled = shape.perfectDrawEnabled();
     *
     * // set perfectDrawEnabled
     * shape.perfectDrawEnabled();
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowForStrokeEnabled', true);

    /**
     * get/set shadowForStrokeEnabled. Useful for performance optimization.
     * You may set `shape.shadowForStrokeEnabled(false)`. In this case stroke will be no draw shadow for stroke.
     * Remember if you set `shadowForStrokeEnabled = false` for non closed line - that line with have no shadow!.
     * Default value is true
     * @name shadowForStrokeEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} shadowForStrokeEnabled
     * @returns {Boolean}
     * @example
     * // get shadowForStrokeEnabled
     * var shadowForStrokeEnabled = shape.shadowForStrokeEnabled();
     *
     * // set shadowForStrokeEnabled
     * shape.shadowForStrokeEnabled();
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'lineJoin');

    /**
     * get/set line join.  Can be miter, round, or bevel.  The
     *  default is miter
     * @name lineJoin
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} lineJoin
     * @returns {String}
     * @example
     * // get line join
     * var lineJoin = shape.lineJoin();
     *
     * // set line join
     * shape.lineJoin('round');
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'lineCap');

    /**
     * get/set line cap.  Can be butt, round, or square
     * @name lineCap
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} lineCap
     * @returns {String}
     * @example
     * // get line cap
     * var lineCap = shape.lineCap();
     *
     * // set line cap
     * shape.lineCap('round');
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'sceneFunc');

    /**
     * get/set scene draw function
     * @name sceneFunc
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Function} drawFunc drawing function
     * @returns {Function}
     * @example
     * // get scene draw function
     * var sceneFunc = shape.sceneFunc();
     *
     * // set scene draw function
     * shape.sceneFunc(function(context) {
     *   context.beginPath();
     *   context.rect(0, 0, this.width(), this.height());
     *   context.closePath();
     *   context.fillStrokeShape(this);
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'hitFunc');

    /**
     * get/set hit draw function
     * @name hitFunc
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Function} drawFunc drawing function
     * @returns {Function}
     * @example
     * // get hit draw function
     * var hitFunc = shape.hitFunc();
     *
     * // set hit draw function
     * shape.hitFunc(function(context) {
     *   context.beginPath();
     *   context.rect(0, 0, this.width(), this.height());
     *   context.closePath();
     *   context.fillStrokeShape(this);
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'dash');

    /**
     * get/set dash array for stroke.
     * @name dash
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Array} dash
     * @returns {Array}
     * @example
     *  // apply dashed stroke that is 10px long and 5 pixels apart
     *  line.dash([10, 5]);
     *  // apply dashed stroke that is made up of alternating dashed
     *  // lines that are 10px long and 20px apart, and dots that have
     *  // a radius of 5px and are 20px apart
     *  line.dash([10, 20, 0.001, 20]);
     */


    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowColor');

    /**
     * get/set shadow color
     * @name shadowColor
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} color
     * @returns {String}
     * @example
     * // get shadow color
     * var shadow = shape.shadowColor();
     *
     * // set shadow color with color string
     * shape.shadowColor('green');
     *
     * // set shadow color with hex
     * shape.shadowColor('#00ff00');
     *
     * // set shadow color with rgb
     * shape.shadowColor('rgb(0,255,0)');
     *
     * // set shadow color with rgba and make it 50% opaque
     * shape.shadowColor('rgba(0,255,0,0.5');
     */

    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'shadowRed', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'shadowGreen', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'shadowBlue', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'shadowAlpha', 1, Konva.Validators.alphaComponent);

    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowBlur');

    /**
     * get/set shadow blur
     * @name shadowBlur
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} blur
     * @returns {Number}
     * @example
     * // get shadow blur
     * var shadowBlur = shape.shadowBlur();
     *
     * // set shadow blur
     * shape.shadowBlur(10);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowOpacity');

    /**
     * get/set shadow opacity.  must be a value between 0 and 1
     * @name shadowOpacity
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} opacity
     * @returns {Number}
     * @example
     * // get shadow opacity
     * var shadowOpacity = shape.shadowOpacity();
     *
     * // set shadow opacity
     * shape.shadowOpacity(0.5);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'shadowOffset', ['x', 'y']);

    /**
     * get/set shadow offset
     * @name shadowOffset
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} offset
     * @param {Number} offset.x
     * @param {Number} offset.y
     * @returns {Object}
     * @example
     * // get shadow offset
     * var shadowOffset = shape.shadowOffset();
     *
     * // set shadow offset
     * shape.shadowOffset({
     *   x: 20
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowOffsetX', 0);

     /**
     * get/set shadow offset x
     * @name shadowOffsetX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get shadow offset x
     * var shadowOffsetX = shape.shadowOffsetX();
     *
     * // set shadow offset x
     * shape.shadowOffsetX(5);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowOffsetY', 0);

     /**
     * get/set shadow offset y
     * @name shadowOffsetY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get shadow offset y
     * var shadowOffsetY = shape.shadowOffsetY();
     *
     * // set shadow offset y
     * shape.shadowOffsetY(5);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternImage');

    /**
     * get/set fill pattern image
     * @name fillPatternImage
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Image} image object
     * @returns {Image}
     * @example
     * // get fill pattern image
     * var fillPatternImage = shape.fillPatternImage();
     *
     * // set fill pattern image
     * var imageObj = new Image();
     * imageObj.onload = function() {
     *   shape.fillPatternImage(imageObj);
     * };
     * imageObj.src = 'path/to/image/jpg';
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fill');

    /**
     * get/set fill color
     * @name fill
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} color
     * @returns {String}
     * @example
     * // get fill color
     * var fill = shape.fill();
     *
     * // set fill color with color string
     * shape.fill('green');
     *
     * // set fill color with hex
     * shape.fill('#00ff00');
     *
     * // set fill color with rgb
     * shape.fill('rgb(0,255,0)');
     *
     * // set fill color with rgba and make it 50% opaque
     * shape.fill('rgba(0,255,0,0.5');
     *
     * // shape without fill
     * shape.fill(null);
     */

    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'fillRed', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'fillGreen', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'fillBlue', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'fillAlpha', 1, Konva.Validators.alphaComponent);

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternX', 0);

    /**
     * get/set fill pattern x
     * @name fillPatternX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill pattern x
     * var fillPatternX = shape.fillPatternX();
     * // set fill pattern x
     * shape.fillPatternX(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternY', 0);

    /**
     * get/set fill pattern y
     * @name fillPatternY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill pattern y
     * var fillPatternY = shape.fillPatternY();
     * // set fill pattern y
     * shape.fillPatternY(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientColorStops');

    /**
     * get/set fill linear gradient color stops
     * @name fillLinearGradientColorStops
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Array} colorStops
     * @returns {Array} colorStops
     * @example
     * // get fill linear gradient color stops
     * var colorStops = shape.fillLinearGradientColorStops();
     *
     * // create a linear gradient that starts with red, changes to blue
     * // halfway through, and then changes to green
     * shape.fillLinearGradientColorStops(0, 'red', 0.5, 'blue', 1, 'green');
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientStartRadius', 0);

    /**
     * get/set fill radial gradient start radius
     * @name fillRadialGradientStartRadius
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} radius
     * @returns {Number}
     * @example
     * // get radial gradient start radius
     * var startRadius = shape.fillRadialGradientStartRadius();
     *
     * // set radial gradient start radius
     * shape.fillRadialGradientStartRadius(0);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientEndRadius', 0);

    /**
     * get/set fill radial gradient end radius
     * @name fillRadialGradientEndRadius
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} radius
     * @returns {Number}
     * @example
     * // get radial gradient end radius
     * var endRadius = shape.fillRadialGradientEndRadius();
     *
     * // set radial gradient end radius
     * shape.fillRadialGradientEndRadius(100);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientColorStops');

    /**
     * get/set fill radial gradient color stops
     * @name fillRadialGradientColorStops
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} colorStops
     * @returns {Array}
     * @example
     * // get fill radial gradient color stops
     * var colorStops = shape.fillRadialGradientColorStops();
     *
     * // create a radial gradient that starts with red, changes to blue
     * // halfway through, and then changes to green
     * shape.fillRadialGradientColorStops(0, 'red', 0.5, 'blue', 1, 'green');
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternRepeat', 'repeat');

    /**
     * get/set fill pattern repeat.  Can be 'repeat', 'repeat-x', 'repeat-y', or 'no-repeat'.  The default is 'repeat'
     * @name fillPatternRepeat
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} repeat
     * @returns {String}
     * @example
     * // get fill pattern repeat
     * var repeat = shape.fillPatternRepeat();
     *
     * // repeat pattern in x direction only
     * shape.fillPatternRepeat('repeat-x');
     *
     * // do not repeat the pattern
     * shape.fillPatternRepeat('no repeat');
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillEnabled', true);

    /**
     * get/set fill enabled flag
     * @name fillEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get fill enabled flag
     * var fillEnabled = shape.fillEnabled();
     *
     * // disable fill
     * shape.fillEnabled(false);
     *
     * // enable fill
     * shape.fillEnabled(true);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'strokeEnabled', true);

    /**
     * get/set stroke enabled flag
     * @name strokeEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get stroke enabled flag
     * var strokeEnabled = shape.strokeEnabled();
     *
     * // disable stroke
     * shape.strokeEnabled(false);
     *
     * // enable stroke
     * shape.strokeEnabled(true);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowEnabled', true);

    /**
     * get/set shadow enabled flag
     * @name shadowEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get shadow enabled flag
     * var shadowEnabled = shape.shadowEnabled();
     *
     * // disable shadow
     * shape.shadowEnabled(false);
     *
     * // enable shadow
     * shape.shadowEnabled(true);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'dashEnabled', true);

    /**
     * get/set dash enabled flag
     * @name dashEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get dash enabled flag
     * var dashEnabled = shape.dashEnabled();
     *
     * // disable dash
     * shape.dashEnabled(false);
     *
     * // enable dash
     * shape.dashEnabled(true);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'strokeScaleEnabled', true);

    /**
     * get/set strokeScale enabled flag
     * @name strokeScaleEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get stroke scale enabled flag
     * var strokeScaleEnabled = shape.strokeScaleEnabled();
     *
     * // disable stroke scale
     * shape.strokeScaleEnabled(false);
     *
     * // enable stroke scale
     * shape.strokeScaleEnabled(true);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPriority', 'color');

    /**
     * get/set fill priority.  can be color, pattern, linear-gradient, or radial-gradient.  The default is color.
     *   This is handy if you want to toggle between different fill types.
     * @name fillPriority
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} priority
     * @returns {String}
     * @example
     * // get fill priority
     * var fillPriority = shape.fillPriority();
     *
     * // set fill priority
     * shape.fillPriority('linear-gradient');
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillPatternOffset', ['x', 'y']);

    /**
     * get/set fill pattern offset
     * @name fillPatternOffset
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} offset
     * @param {Number} offset.x
     * @param {Number} offset.y
     * @returns {Object}
     * @example
     * // get fill pattern offset
     * var patternOffset = shape.fillPatternOffset();
     *
     * // set fill pattern offset
     * shape.fillPatternOffset({
     *   x: 20
     *   y: 10
     * });
     */


    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternOffsetX', 0);
    /**
     * get/set fill pattern offset x
     * @name fillPatternOffsetX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill pattern offset x
     * var patternOffsetX = shape.fillPatternOffsetX();
     *
     * // set fill pattern offset x
     * shape.fillPatternOffsetX(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternOffsetY', 0);
    /**
     * get/set fill pattern offset y
     * @name fillPatternOffsetY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill pattern offset y
     * var patternOffsetY = shape.fillPatternOffsetY();
     *
     * // set fill pattern offset y
     * shape.fillPatternOffsetY(10);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillPatternScale', ['x', 'y']);

    /**
     * get/set fill pattern scale
     * @name fillPatternScale
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} scale
     * @param {Number} scale.x
     * @param {Number} scale.y
     * @returns {Object}
     * @example
     * // get fill pattern scale
     * var patternScale = shape.fillPatternScale();
     *
     * // set fill pattern scale
     * shape.fillPatternScale({
     *   x: 2
     *   y: 2
     * });
     */


    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternScaleX', 1);
    /**
     * get/set fill pattern scale x
     * @name fillPatternScaleX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill pattern scale x
     * var patternScaleX = shape.fillPatternScaleX();
     *
     * // set fill pattern scale x
     * shape.fillPatternScaleX(2);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternScaleY', 1);
    /**
     * get/set fill pattern scale y
     * @name fillPatternScaleY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill pattern scale y
     * var patternScaleY = shape.fillPatternScaleY();
     *
     * // set fill pattern scale y
     * shape.fillPatternScaleY(2);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillLinearGradientStartPoint', ['x', 'y']);

    /**
     * get/set fill linear gradient start point
     * @name fillLinearGradientStartPoint
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} startPoint
     * @param {Number} startPoint.x
     * @param {Number} startPoint.y
     * @returns {Object}
     * @example
     * // get fill linear gradient start point
     * var startPoint = shape.fillLinearGradientStartPoint();
     *
     * // set fill linear gradient start point
     * shape.fillLinearGradientStartPoint({
     *   x: 20
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientStartPointX', 0);
    /**
     * get/set fill linear gradient start point x
     * @name fillLinearGradientStartPointX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill linear gradient start point x
     * var startPointX = shape.fillLinearGradientStartPointX();
     *
     * // set fill linear gradient start point x
     * shape.fillLinearGradientStartPointX(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientStartPointY', 0);
    /**
     * get/set fill linear gradient start point y
     * @name fillLinearGradientStartPointY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill linear gradient start point y
     * var startPointY = shape.fillLinearGradientStartPointY();
     *
     * // set fill linear gradient start point y
     * shape.fillLinearGradientStartPointY(20);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillLinearGradientEndPoint', ['x', 'y']);

    /**
     * get/set fill linear gradient end point
     * @name fillLinearGradientEndPoint
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} endPoint
     * @param {Number} endPoint.x
     * @param {Number} endPoint.y
     * @returns {Object}
     * @example
     * // get fill linear gradient end point
     * var endPoint = shape.fillLinearGradientEndPoint();
     *
     * // set fill linear gradient end point
     * shape.fillLinearGradientEndPoint({
     *   x: 20
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientEndPointX', 0);
    /**
     * get/set fill linear gradient end point x
     * @name fillLinearGradientEndPointX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill linear gradient end point x
     * var endPointX = shape.fillLinearGradientEndPointX();
     *
     * // set fill linear gradient end point x
     * shape.fillLinearGradientEndPointX(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientEndPointY', 0);
    /**
     * get/set fill linear gradient end point y
     * @name fillLinearGradientEndPointY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill linear gradient end point y
     * var endPointY = shape.fillLinearGradientEndPointY();
     *
     * // set fill linear gradient end point y
     * shape.fillLinearGradientEndPointY(20);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillRadialGradientStartPoint', ['x', 'y']);

    /**
     * get/set fill radial gradient start point
     * @name fillRadialGradientStartPoint
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} startPoint
     * @param {Number} startPoint.x
     * @param {Number} startPoint.y
     * @returns {Object}
     * @example
     * // get fill radial gradient start point
     * var startPoint = shape.fillRadialGradientStartPoint();
     *
     * // set fill radial gradient start point
     * shape.fillRadialGradientStartPoint({
     *   x: 20
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientStartPointX', 0);
    /**
     * get/set fill radial gradient start point x
     * @name fillRadialGradientStartPointX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill radial gradient start point x
     * var startPointX = shape.fillRadialGradientStartPointX();
     *
     * // set fill radial gradient start point x
     * shape.fillRadialGradientStartPointX(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientStartPointY', 0);
    /**
     * get/set fill radial gradient start point y
     * @name fillRadialGradientStartPointY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill radial gradient start point y
     * var startPointY = shape.fillRadialGradientStartPointY();
     *
     * // set fill radial gradient start point y
     * shape.fillRadialGradientStartPointY(20);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillRadialGradientEndPoint', ['x', 'y']);

    /**
     * get/set fill radial gradient end point
     * @name fillRadialGradientEndPoint
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} endPoint
     * @param {Number} endPoint.x
     * @param {Number} endPoint.y
     * @returns {Object}
     * @example
     * // get fill radial gradient end point
     * var endPoint = shape.fillRadialGradientEndPoint();
     *
     * // set fill radial gradient end point
     * shape.fillRadialGradientEndPoint({
     *   x: 20
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientEndPointX', 0);
    /**
     * get/set fill radial gradient end point x
     * @name fillRadialGradientEndPointX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill radial gradient end point x
     * var endPointX = shape.fillRadialGradientEndPointX();
     *
     * // set fill radial gradient end point x
     * shape.fillRadialGradientEndPointX(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientEndPointY', 0);
    /**
     * get/set fill radial gradient end point y
     * @name fillRadialGradientEndPointY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill radial gradient end point y
     * var endPointY = shape.fillRadialGradientEndPointY();
     *
     * // set fill radial gradient end point y
     * shape.fillRadialGradientEndPointY(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternRotation', 0);

    /**
     * get/set fill pattern rotation in degrees
     * @name fillPatternRotation
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} rotation
     * @returns {Konva.Shape}
     * @example
     * // get fill pattern rotation
     * var patternRotation = shape.fillPatternRotation();
     *
     * // set fill pattern rotation
     * shape.fillPatternRotation(20);
     */


    Konva.Factory.backCompat(Konva.Shape, {
        dashArray: 'dash',
        getDashArray: 'getDash',
        setDashArray: 'getDash',

        drawFunc: 'sceneFunc',
        getDrawFunc: 'getSceneFunc',
        setDrawFunc: 'setSceneFunc',

        drawHitFunc: 'hitFunc',
        getDrawHitFunc: 'getHitFunc',
        setDrawHitFunc: 'setHitFunc'
    });

    Konva.Collection.mapMethods(Konva.Shape);
})(Konva);

(function() {
    'use strict';
    // CONSTANTS
    var STAGE = 'Stage',
        STRING = 'string',
        PX = 'px',

        MOUSEOUT = 'mouseout',
        MOUSELEAVE = 'mouseleave',
        MOUSEOVER = 'mouseover',
        MOUSEENTER = 'mouseenter',
        MOUSEMOVE = 'mousemove',
        MOUSEDOWN = 'mousedown',
        MOUSEUP = 'mouseup',
        CLICK = 'click',
        DBL_CLICK = 'dblclick',
        TOUCHSTART = 'touchstart',
        TOUCHEND = 'touchend',
        TAP = 'tap',
        DBL_TAP = 'dbltap',
        TOUCHMOVE = 'touchmove',
        DOMMOUSESCROLL = 'DOMMouseScroll',
        MOUSEWHEEL = 'mousewheel',
        WHEEL = 'wheel',

        CONTENT_MOUSEOUT = 'contentMouseout',
        CONTENT_MOUSEOVER = 'contentMouseover',
        CONTENT_MOUSEMOVE = 'contentMousemove',
        CONTENT_MOUSEDOWN = 'contentMousedown',
        CONTENT_MOUSEUP = 'contentMouseup',
        CONTENT_CLICK = 'contentClick',
        CONTENT_DBL_CLICK = 'contentDblclick',
        CONTENT_TOUCHSTART = 'contentTouchstart',
        CONTENT_TOUCHEND = 'contentTouchend',
        CONTENT_DBL_TAP = 'contentDbltap',
        CONTENT_TOUCHMOVE = 'contentTouchmove',

        DIV = 'div',
        RELATIVE = 'relative',
        KONVA_CONTENT = 'konvajs-content',
        SPACE = ' ',
        UNDERSCORE = '_',
        CONTAINER = 'container',
        EMPTY_STRING = '',
        EVENTS = [MOUSEDOWN, MOUSEMOVE, MOUSEUP, MOUSEOUT, TOUCHSTART, TOUCHMOVE, TOUCHEND, MOUSEOVER, DOMMOUSESCROLL, MOUSEWHEEL, WHEEL],

        // cached variables
        eventsLength = EVENTS.length;

    function addEvent(ctx, eventName) {
        ctx.content.addEventListener(eventName, function(evt) {
            ctx[UNDERSCORE + eventName](evt);
        }, false);
    }

    /**
     * Stage constructor.  A stage is used to contain multiple layers
     * @constructor
     * @memberof Konva
     * @augments Konva.Container
     * @param {Object} config
     * @param {String|Element} config.container Container id or DOM element
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var stage = new Konva.Stage({
         *   width: 500,
         *   height: 800,
         *   container: 'containerId'
         * });
     */
    Konva.Stage = function(config) {
        this.___init(config);
    };

    Konva.Util.addMethods(Konva.Stage, {
        ___init: function(config) {
            this.nodeType = STAGE;
            // call super constructor
            Konva.Container.call(this, config);
            this._id = Konva.idCounter++;
            this._buildDOM();
            this._bindContentEvents();
            this._enableNestedTransforms = false;
            Konva.stages.push(this);
        },
        _validateAdd: function(child) {
            if (child.getType() !== 'Layer') {
                Konva.Util.throw('You may only add layers to the stage.');
            }
        },
        /**
         * set container dom element which contains the stage wrapper div element
         * @method
         * @memberof Konva.Stage.prototype
         * @param {DomElement} container can pass in a dom element or id string
         */
        setContainer: function(container) {
            if( typeof container === STRING) {
                var id = container;
                container = Konva.document.getElementById(container);
                if (!container) {
                    throw 'Can not find container in document with id ' + id;
                }
            }
            this._setAttr(CONTAINER, container);
            return this;
        },
        shouldDrawHit: function() {
            return true;
        },
        draw: function() {
            Konva.Node.prototype.draw.call(this);
            return this;
        },
        /**
         * draw layer scene graphs
         * @name draw
         * @method
         * @memberof Konva.Stage.prototype
         */

        /**
         * draw layer hit graphs
         * @name drawHit
         * @method
         * @memberof Konva.Stage.prototype
         */

        /**
         * set height
         * @method
         * @memberof Konva.Stage.prototype
         * @param {Number} height
         */
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            this._resizeDOM();
            return this;
        },
        /**
         * set width
         * @method
         * @memberof Konva.Stage.prototype
         * @param {Number} width
         */
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            this._resizeDOM();
            return this;
        },
        /**
         * clear all layers
         * @method
         * @memberof Konva.Stage.prototype
         */
        clear: function() {
            var layers = this.children,
                len = layers.length,
                n;

            for(n = 0; n < len; n++) {
                layers[n].clear();
            }
            return this;
        },
        clone: function(obj) {
            if (!obj) {
                obj = {};
            }
            obj.container = Konva.document.createElement(DIV);
            return Konva.Container.prototype.clone.call(this, obj);
        },
        /**
         * destroy stage
         * @method
         * @memberof Konva.Stage.prototype
         */
        destroy: function() {
            var content = this.content;
            Konva.Container.prototype.destroy.call(this);

            if(content && Konva.Util._isInDocument(content)) {
                this.getContainer().removeChild(content);
            }
            var index = Konva.stages.indexOf(this);
            if (index > -1) {
                Konva.stages.splice(index, 1);
            }
        },
        /**
         * get pointer position which can be a touch position or mouse position
         * @method
         * @memberof Konva.Stage.prototype
         * @returns {Object}
         */
        getPointerPosition: function() {
            return this.pointerPos;
        },
        getStage: function() {
            return this;
        },
        /**
         * get stage content div element which has the
         *  the class name "konvajs-content"
         * @method
         * @memberof Konva.Stage.prototype
         */
        getContent: function() {
            return this.content;
        },
        /**
         * Creates a composite data URL
         * @method
         * @memberof Konva.Stage.prototype
         * @param {Object} config
         * @param {Function} [config.callback] function executed when the composite has completed. Deprecated as method is sync now.
         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
         *  "image/png" is the default
         * @param {Number} [config.x] x position of canvas section
         * @param {Number} [config.y] y position of canvas section
         * @param {Number} [config.width] width of canvas section
         * @param {Number} [config.height] height of canvas section
         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
         *  is very high quality
         */
        toDataURL: function(config) {
            config = config || {};

            var mimeType = config.mimeType || null,
                quality = config.quality || null,
                x = config.x || 0,
                y = config.y || 0,
                canvas = new Konva.SceneCanvas({
                    width: config.width || this.getWidth(),
                    height: config.height || this.getHeight(),
                    pixelRatio: config.pixelRatio
                }),
                _context = canvas.getContext()._context,
                layers = this.children;

            if(x || y) {
                _context.translate(-1 * x, -1 * y);
            }


            layers.each(function(layer) {
                var width = layer.getCanvas().getWidth();
                var height = layer.getCanvas().getHeight();
                var ratio = layer.getCanvas().getPixelRatio();
                _context.drawImage(layer.getCanvas()._canvas, 0, 0, width / ratio, height / ratio);
            });
            var src = canvas.toDataURL(mimeType, quality);

            if (config.callback) {
                config.callback(src);
            }

            return src;
        },
        /**
         * converts stage into an image.
         * @method
         * @memberof Konva.Stage.prototype
         * @param {Object} config
         * @param {Function} config.callback function executed when the composite has completed
         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
         *  "image/png" is the default
         * @param {Number} [config.x] x position of canvas section
         * @param {Number} [config.y] y position of canvas section
         * @param {Number} [config.width] width of canvas section
         * @param {Number} [config.height] height of canvas section
         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
         *  is very high quality
         */
        toImage: function(config) {
            var cb = config.callback;

            config.callback = function(dataUrl) {
                Konva.Util._getImage(dataUrl, function(img) {
                    cb(img);
                });
            };
            this.toDataURL(config);
        },
        /**
         * get visible intersection shape. This is the preferred
         *  method for determining if a point intersects a shape or not
         * @method
         * @memberof Konva.Stage.prototype
         * @param {Object} pos
         * @param {Number} pos.x
         * @param {Number} pos.y
         * @returns {Konva.Shape}
         */
        getIntersection: function(pos) {
            var layers = this.getChildren(),
                len = layers.length,
                end = len - 1,
                n, shape;

            for(n = end; n >= 0; n--) {
                shape = layers[n].getIntersection(pos);
                if (shape) {
                    return shape;
                }
            }

            return null;
        },
        _resizeDOM: function() {
            if(this.content) {
                var width = this.getWidth(),
                    height = this.getHeight(),
                    layers = this.getChildren(),
                    len = layers.length,
                    n, layer;

                // set content dimensions
                this.content.style.width = width + PX;
                this.content.style.height = height + PX;

                this.bufferCanvas.setSize(width, height);
                this.bufferHitCanvas.setSize(width, height);

                // set layer dimensions
                for(n = 0; n < len; n++) {
                    layer = layers[n];
                    layer.setSize(width, height);
                    layer.draw();
                }
            }
        },
        /**
         * add layer or layers to stage
         * @method
         * @memberof Konva.Stage.prototype
         * @param {...Konva.Layer} layer
         * @example
         * stage.add(layer1, layer2, layer3);
         */
        add: function(layer) {
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) {
                    this.add(arguments[i]);
                }
                return this;
            }
            Konva.Container.prototype.add.call(this, layer);
            layer._setCanvasSize(this.width(), this.height());

            // draw layer and append canvas to container
            layer.draw();
            this.content.appendChild(layer.canvas._canvas);

            // chainable
            return this;
        },
        getParent: function() {
            return null;
        },
        getLayer: function() {
            return null;
        },
        /**
         * returns a {@link Konva.Collection} of layers
         * @method
         * @memberof Konva.Stage.prototype
         */
        getLayers: function() {
            return this.getChildren();
        },
        _bindContentEvents: function() {
            for (var n = 0; n < eventsLength; n++) {
                addEvent(this, EVENTS[n]);
            }
        },
        _mouseover: function(evt) {
            if (!Konva.UA.mobile) {
                this._setPointerPosition(evt);
                this._fire(CONTENT_MOUSEOVER, {evt: evt});
            }
        },
        _mouseout: function(evt) {
            if (!Konva.UA.mobile) {
                this._setPointerPosition(evt);
                var targetShape = this.targetShape;

                if(targetShape && !Konva.isDragging()) {
                    targetShape._fireAndBubble(MOUSEOUT, {evt: evt});
                    targetShape._fireAndBubble(MOUSELEAVE, {evt: evt});
                    this.targetShape = null;
                }
                this.pointerPos = undefined;

                this._fire(CONTENT_MOUSEOUT, {evt: evt});
            }
        },
        _mousemove: function(evt) {
            // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event
            if (Konva.UA.ieMobile) {
                return this._touchmove(evt);
            }
            // workaround fake mousemove event in chrome browser https://code.google.com/p/chromium/issues/detail?id=161464
            if ((typeof evt.movementX !== 'undefined' || typeof evt.movementY !== 'undefined') && evt.movementY === 0 && evt.movementX === 0) {
                return null;
            }
            if (Konva.UA.mobile) {
                return null;
            }
            this._setPointerPosition(evt);
            var shape;

            if (!Konva.isDragging()) {
                shape = this.getIntersection(this.getPointerPosition());
                if(shape && shape.isListening()) {
                    if(!Konva.isDragging() && (!this.targetShape || this.targetShape._id !== shape._id)) {
                        if(this.targetShape) {
                            this.targetShape._fireAndBubble(MOUSEOUT, {evt: evt}, shape);
                            this.targetShape._fireAndBubble(MOUSELEAVE, {evt: evt}, shape);
                        }
                        shape._fireAndBubble(MOUSEOVER, {evt: evt}, this.targetShape);
                        shape._fireAndBubble(MOUSEENTER, {evt: evt}, this.targetShape);
                        this.targetShape = shape;
                    }
                    else {
                        shape._fireAndBubble(MOUSEMOVE, {evt: evt});
                    }
                }
                /*
                 * if no shape was detected, clear target shape and try
                 * to run mouseout from previous target shape
                 */
                else {
                    if(this.targetShape && !Konva.isDragging()) {
                        this.targetShape._fireAndBubble(MOUSEOUT, {evt: evt});
                        this.targetShape._fireAndBubble(MOUSELEAVE, {evt: evt});
                        this.targetShape = null;
                    }

                }

                // content event
                this._fire(CONTENT_MOUSEMOVE, {evt: evt});
            }

            // always call preventDefault for desktop events because some browsers
            // try to drag and drop the canvas element
            if (evt.preventDefault) {
                evt.preventDefault();
            }
        },
        _mousedown: function(evt) {
            // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event
            if (Konva.UA.ieMobile) {
                return this._touchstart(evt);
            }
            if (!Konva.UA.mobile) {
                this._setPointerPosition(evt);
                var shape = this.getIntersection(this.getPointerPosition());

                Konva.listenClickTap = true;

                if (shape && shape.isListening()) {
                    this.clickStartShape = shape;
                    shape._fireAndBubble(MOUSEDOWN, {evt: evt});
                }

                // content event
                this._fire(CONTENT_MOUSEDOWN, {evt: evt});
            }

            // always call preventDefault for desktop events because some browsers
            // try to drag and drop the canvas element
            if (evt.preventDefault) {
                evt.preventDefault();
            }
        },
        _mouseup: function(evt) {

            // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event
            if (Konva.UA.ieMobile) {
                return this._touchend(evt);
            }
            if (!Konva.UA.mobile) {
                this._setPointerPosition(evt);
                var shape = this.getIntersection(this.getPointerPosition()),
                    clickStartShape = this.clickStartShape,
                    fireDblClick = false,
                    dd = Konva.DD;

                if(Konva.inDblClickWindow) {
                    fireDblClick = true;
                    Konva.inDblClickWindow = false;
                }
                // don't set inDblClickWindow after dragging
                else if (!dd || !dd.justDragged) {
                    Konva.inDblClickWindow = true;
                } else if (dd) {
                    dd.justDragged = false;
                }

                setTimeout(function() {
                    Konva.inDblClickWindow = false;
                }, Konva.dblClickWindow);

                if (shape && shape.isListening()) {
                    shape._fireAndBubble(MOUSEUP, {evt: evt});

                    // detect if click or double click occurred
                    if(Konva.listenClickTap && clickStartShape && clickStartShape._id === shape._id) {
                        shape._fireAndBubble(CLICK, {evt: evt});

                        if(fireDblClick) {
                            shape._fireAndBubble(DBL_CLICK, {evt: evt});
                        }
                    }
                }
                // content events
                this._fire(CONTENT_MOUSEUP, {evt: evt});
                if (Konva.listenClickTap) {
                    this._fire(CONTENT_CLICK, {evt: evt});
                    if(fireDblClick) {
                        this._fire(CONTENT_DBL_CLICK, {evt: evt});
                    }
                }

                Konva.listenClickTap = false;
            }

            // always call preventDefault for desktop events because some browsers
            // try to drag and drop the canvas element
            if (evt.preventDefault) {
                evt.preventDefault();
            }
        },
        _touchstart: function(evt) {
            this._setPointerPosition(evt);
            var shape = this.getIntersection(this.getPointerPosition());

            Konva.listenClickTap = true;

            if (shape && shape.isListening()) {
                this.tapStartShape = shape;
                shape._fireAndBubble(TOUCHSTART, {evt: evt});

                // only call preventDefault if the shape is listening for events
                if (shape.isListening() && evt.preventDefault) {
                    evt.preventDefault();
                }
            }
            // content event
            this._fire(CONTENT_TOUCHSTART, {evt: evt});
        },
        _touchend: function(evt) {
            this._setPointerPosition(evt);
            var shape = this.getIntersection(this.getPointerPosition()),
                fireDblClick = false;

            if(Konva.inDblClickWindow) {
                fireDblClick = true;
                Konva.inDblClickWindow = false;
            }
            else {
                Konva.inDblClickWindow = true;
            }

            setTimeout(function() {
                Konva.inDblClickWindow = false;
            }, Konva.dblClickWindow);

            if (shape && shape.isListening()) {
                shape._fireAndBubble(TOUCHEND, {evt: evt});

                // detect if tap or double tap occurred
                if(Konva.listenClickTap && shape._id === this.tapStartShape._id) {
                    shape._fireAndBubble(TAP, {evt: evt});

                    if(fireDblClick) {
                        shape._fireAndBubble(DBL_TAP, {evt: evt});
                    }
                }
                // only call preventDefault if the shape is listening for events
                if (shape.isListening() && evt.preventDefault) {
                    evt.preventDefault();
                }
            }
            // content events
            if (Konva.listenClickTap) {
                this._fire(CONTENT_TOUCHEND, {evt: evt});
                if(fireDblClick) {
                    this._fire(CONTENT_DBL_TAP, {evt: evt});
                }
            }

            Konva.listenClickTap = false;
        },
        _touchmove: function(evt) {
            this._setPointerPosition(evt);
            var dd = Konva.DD,
                shape;
            if (!Konva.isDragging()) {
                shape = this.getIntersection(this.getPointerPosition());
                if (shape && shape.isListening()) {
                    shape._fireAndBubble(TOUCHMOVE, {evt: evt});
                    // only call preventDefault if the shape is listening for events
                    if (shape.isListening() && evt.preventDefault) {
                        evt.preventDefault();
                    }
                }
                this._fire(CONTENT_TOUCHMOVE, {evt: evt});
            }
            if(dd) {
                if (Konva.isDragging()) {
                    evt.preventDefault();
                }
            }
        },
        _DOMMouseScroll: function(evt) {
            this._mousewheel(evt);
        },
        _mousewheel: function(evt) {
            this._setPointerPosition(evt);
            var shape = this.getIntersection(this.getPointerPosition());

            if (shape && shape.isListening()) {
                shape._fireAndBubble(MOUSEWHEEL, {evt: evt});
            }
        },
        _wheel: function(evt) {
            this._mousewheel(evt);
        },
        _setPointerPosition: function(evt) {
            var contentPosition = this._getContentPosition(),
                x = null,
                y = null;
            evt = evt ? evt : window.event;

            // touch events
            if(evt.touches !== undefined) {
                // currently, only handle one finger
                if (evt.touches.length > 0) {

                    var touch = evt.touches[0];
                    // get the information for finger #1
                    x = touch.clientX - contentPosition.left;
                    y = touch.clientY - contentPosition.top;
                }
            }
            // mouse events
            else {
                if (!contentPosition) {
                    x = evt.offsetX;
                    y = evt.offetY;
                }
                // we unfortunately have to use UA detection here because accessing
                // the layerX or layerY properties in newer versions of Chrome
                // throws a JS warning.  layerX and layerY are required for FF
                // when the container is transformed via CSS.
                else if (Konva.UA.browser === 'mozilla') {
                    x = evt.layerX || (evt.clientX - contentPosition.left);
                    y = evt.layerY || (evt.clientY - contentPosition.top);
                } else {
                    x = evt.clientX - contentPosition.left;
                    y = evt.clientY - contentPosition.top;
                }
            }

            if (x !== null && y !== null) {
                this.pointerPos = {
                    x: x,
                    y: y
                };
            }
        },
        _getContentPosition: function() {
            var rect = this.content.getBoundingClientRect ? this.content.getBoundingClientRect() : { top: 0, left: 0 };
            return {
                top: rect.top,
                left: rect.left
            };
        },
        _buildDOM: function() {
            var container = this.getContainer();
            if (!container) {
                if (Konva.Util.isBrowser()) {
                    throw 'Stage has no container. A container is required.';
                } else {
                    // automatically create element for jsdom in nodejs env
                    container = Konva.document.createElement(DIV);
                }
            }
            // clear content inside container
            container.innerHTML = EMPTY_STRING;

            // content
            this.content = Konva.document.createElement(DIV);
            this.content.style.position = RELATIVE;
            this.content.className = KONVA_CONTENT;
            this.content.setAttribute('role', 'presentation');
            container.appendChild(this.content);

            // the buffer canvas pixel ratio must be 1 because it is used as an
            // intermediate canvas before copying the result onto a scene canvas.
            // not setting it to 1 will result in an over compensation
            this.bufferCanvas = new Konva.SceneCanvas({
                pixelRatio: 1
            });
            this.bufferHitCanvas = new Konva.HitCanvas();

            this._resizeDOM();
        },
        _onContent: function(typesStr, handler) {
            var types = typesStr.split(SPACE),
                len = types.length,
                n, baseEvent;

            for(n = 0; n < len; n++) {
                baseEvent = types[n];
                this.content.addEventListener(baseEvent, handler, false);
            }
        },
        // currently cache function is now working for stage, because stage has no its own canvas element
        // TODO: may be it is better to cache all children layers?
        cache: function() {
            Konva.Util.warn('Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.');
        },
        clearCache: function() {
        }
    });
    Konva.Util.extend(Konva.Stage, Konva.Container);

    // add getters and setters
    Konva.Factory.addGetter(Konva.Stage, 'container');
    Konva.Factory.addOverloadedGetterSetter(Konva.Stage, 'container');

    /**
     * get container DOM element
     * @name container
     * @method
     * @memberof Konva.Stage.prototype
     * @returns {DomElement} container
     * @example
     * // get container
     * var container = stage.container();
     * // set container
     * var container = document.createElement('div');
     * body.appendChild(container);
     * stage.container(container);
     */

})();

(function() {
    'use strict';
    /**
     * BaseLayer constructor.
     * @constructor
     * @memberof Konva
     * @augments Konva.Container
     * @param {Object} config
     * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
     * to clear the canvas before each layer draw.  The default value is true.
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height

     * @example
     * var layer = new Konva.Layer();
     */
    Konva.BaseLayer = function(config) {
        this.___init(config);
    };

    Konva.Util.addMethods(Konva.BaseLayer, {
        ___init: function(config) {
            this.nodeType = 'Layer';
            Konva.Container.call(this, config);
        },
        createPNGStream: function() {
            return this.canvas._canvas.createPNGStream();
        },
        /**
         * get layer canvas
         * @method
         * @memberof Konva.BaseLayer.prototype
         */
        getCanvas: function() {
            return this.canvas;
        },
        /**
         * get layer hit canvas
         * @method
         * @memberof Konva.BaseLayer.prototype
         */
        getHitCanvas: function() {
            return this.hitCanvas;
        },
        /**
         * get layer canvas context
         * @method
         * @memberof Konva.BaseLayer.prototype
         */
        getContext: function() {
            return this.getCanvas().getContext();
        },
        /**
         * clear scene and hit canvas contexts tied to the layer
         * @method
         * @memberof Konva.BaseLayer.prototype
         * @param {Object} [bounds]
         * @param {Number} [bounds.x]
         * @param {Number} [bounds.y]
         * @param {Number} [bounds.width]
         * @param {Number} [bounds.height]
         * @example
         * layer.clear();
         * layer.clear({
         *   x : 0,
         *   y : 0,
         *   width : 100,
         *   height : 100
         * });
         */
        clear: function(bounds) {
            this.getContext().clear(bounds);
            return this;
        },
        clearHitCache: function() {
            this._hitImageData = undefined;
        },
        // extend Node.prototype.setZIndex
        setZIndex: function(index) {
            Konva.Node.prototype.setZIndex.call(this, index);
            var stage = this.getStage();
            if(stage) {
                stage.content.removeChild(this.getCanvas()._canvas);

                if(index < stage.getChildren().length - 1) {
                    stage.content.insertBefore(this.getCanvas()._canvas, stage.getChildren()[index + 1].getCanvas()._canvas);
                }
                else {
                    stage.content.appendChild(this.getCanvas()._canvas);
                }
            }
            return this;
        },
        // extend Node.prototype.moveToTop
        moveToTop: function() {
            Konva.Node.prototype.moveToTop.call(this);
            var stage = this.getStage();
            if(stage) {
                stage.content.removeChild(this.getCanvas()._canvas);
                stage.content.appendChild(this.getCanvas()._canvas);
            }
        },
        // extend Node.prototype.moveUp
        moveUp: function() {
            var moved = Konva.Node.prototype.moveUp.call(this);
            if (!moved){
                return;
            }
            var stage = this.getStage();
            if(!stage) {
                return;
            }
            stage.content.removeChild(this.getCanvas()._canvas);

            if(this.index < stage.getChildren().length - 1) {
                stage.content.insertBefore(this.getCanvas()._canvas, stage.getChildren()[this.index + 1].getCanvas()._canvas);
            } else {
                stage.content.appendChild(this.getCanvas()._canvas);
            }
        },
        // extend Node.prototype.moveDown
        moveDown: function() {
            if(Konva.Node.prototype.moveDown.call(this)) {
                var stage = this.getStage();
                if(stage) {
                    var children = stage.getChildren();
                    stage.content.removeChild(this.getCanvas()._canvas);
                    stage.content.insertBefore(this.getCanvas()._canvas, children[this.index + 1].getCanvas()._canvas);
                }
            }
        },
        // extend Node.prototype.moveToBottom
        moveToBottom: function() {
            if(Konva.Node.prototype.moveToBottom.call(this)) {
                var stage = this.getStage();
                if(stage) {
                    var children = stage.getChildren();
                    stage.content.removeChild(this.getCanvas()._canvas);
                    stage.content.insertBefore(this.getCanvas()._canvas, children[1].getCanvas()._canvas);
                }
            }
        },
        getLayer: function() {
            return this;
        },
        remove: function() {
            var _canvas = this.getCanvas()._canvas;

            Konva.Node.prototype.remove.call(this);

            if(_canvas && _canvas.parentNode && Konva.Util._isInDocument(_canvas)) {
                _canvas.parentNode.removeChild(_canvas);
            }
            return this;
        },
        getStage: function() {
            return this.parent;
        },
        setSize: function(width, height) {
            this.canvas.setSize(width, height);
        },
        /**
         * get/set width of layer.getter return width of stage. setter doing nothing.
         * if you want change width use `stage.width(value);`
         * @name width
         * @method
         * @memberof Konva.BaseLayer.prototype
         * @returns {Number}
         * @example
         * var width = layer.width();
         */
        getWidth: function() {
            if (this.parent) {
                return this.parent.getWidth();
            }
        },
        setWidth: function() {
            Konva.Util.warn('Can not change width of layer. Use "stage.width(value)" function instead.');
        },
        /**
         * get/set height of layer.getter return height of stage. setter doing nothing.
         * if you want change height use `stage.height(value);`
         * @name height
         * @method
         * @memberof Konva.BaseLayer.prototype
         * @returns {Number}
         * @example
         * var height = layer.height();
         */
        getHeight: function() {
            if (this.parent) {
                return this.parent.getHeight();
            }
        },
        setHeight: function() {
            Konva.Util.warn('Can not change height of layer. Use "stage.height(value)" function instead.');
        },
        // the apply transform method is handled by the Layer and FastLayer class
        // because it is up to the layer to decide if an absolute or relative transform
        // should be used
        _applyTransform: function(shape, context, top) {
            var m = shape.getAbsoluteTransform(top).getMatrix();
            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
        }
    });
    Konva.Util.extend(Konva.BaseLayer, Konva.Container);

    // add getters and setters
    Konva.Factory.addGetterSetter(Konva.BaseLayer, 'clearBeforeDraw', true);
    /**
     * get/set clearBeforeDraw flag which determines if the layer is cleared or not
     *  before drawing
     * @name clearBeforeDraw
     * @method
     * @memberof Konva.BaseLayer.prototype
     * @param {Boolean} clearBeforeDraw
     * @returns {Boolean}
     * @example
     * // get clearBeforeDraw flag
     * var clearBeforeDraw = layer.clearBeforeDraw();
     *
     * // disable clear before draw
     * layer.clearBeforeDraw(false);
     *
     * // enable clear before draw
     * layer.clearBeforeDraw(true);
     */

    Konva.Collection.mapMethods(Konva.BaseLayer);
})();

(function() {
    'use strict';
    // constants
    var HASH = '#',
        BEFORE_DRAW = 'beforeDraw',
        DRAW = 'draw',

        /*
         * 2 - 3 - 4
         * |       |
         * 1 - 0   5
         *         |
         * 8 - 7 - 6
         */
        INTERSECTION_OFFSETS = [
            {x: 0, y: 0},  // 0
            {x: -1, y: 0}, // 1
            {x: -1, y: -1}, // 2
            {x: 0, y: -1}, // 3
            {x: 1, y: -1}, // 4
            {x: 1, y: 0}, // 5
            {x: 1, y: 1}, // 6
            {x: 0, y: 1}, // 7
            {x: -1, y: 1}  // 8
        ],
        INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;

    /**
     * Layer constructor.  Layers are tied to their own canvas element and are used
     * to contain groups or shapes.
     * @constructor
     * @memberof Konva
     * @augments Konva.BaseLayer
     * @param {Object} config
     * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
     * to clear the canvas before each layer draw.  The default value is true.
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height

     * @example
     * var layer = new Konva.Layer();
     */
    Konva.Layer = function(config) {
        this.____init(config);
    };

    Konva.Util.addMethods(Konva.Layer, {
        ____init: function(config) {
            this.nodeType = 'Layer';
            this.canvas = new Konva.SceneCanvas();
            this.hitCanvas = new Konva.HitCanvas({
                pixelRatio: 1
            });
            // call super constructor
            Konva.BaseLayer.call(this, config);
        },
        _setCanvasSize: function(width, height) {
            this.canvas.setSize(width, height);
            this.hitCanvas.setSize(width, height);
        },
        _validateAdd: function(child) {
            var type = child.getType();
            if (type !== 'Group' && type !== 'Shape') {
                Konva.Util.throw('You may only add groups and shapes to a layer.');
            }
        },
        /**
         * get visible intersection shape. This is the preferred
         * method for determining if a point intersects a shape or not
         * @method
         * @memberof Konva.Layer.prototype
         * @param {Object} pos
         * @param {Number} pos.x
         * @param {Number} pos.y
         * @returns {Konva.Shape}
         */
        getIntersection: function(pos) {
            var obj, i, intersectionOffset, shape;

            if(!this.hitGraphEnabled() || !this.isVisible()) {
                return null;
            }
            // in some cases antialiased area may be bigger than 1px
            // it is possible if we will cache node, then scale it a lot
            // TODO: check { 0; 0 } point before loop, and remove it from INTERSECTION_OFFSETS.
            var spiralSearchDistance = 1;
            var continueSearch = false;
            while (true) {
                for (i = 0; i < INTERSECTION_OFFSETS_LEN; i++) {
                    intersectionOffset = INTERSECTION_OFFSETS[i];
                    obj = this._getIntersection({
                        x: pos.x + intersectionOffset.x * spiralSearchDistance,
                        y: pos.y + intersectionOffset.y * spiralSearchDistance
                    });
                    shape = obj.shape;
                    if (shape) {
                        return shape;
                    }
                    // we should continue search if we found antialiased pixel
                    // that means our node somewhere very close
                    continueSearch = !!obj.antialiased;
                    // stop search if found empty pixel
                    if (!obj.antialiased) {
                        break;
                    }
                }
                // if no shape, and no antialiased pixel, we should end searching
                if (continueSearch) {
                    spiralSearchDistance += 1;
                } else {
                    return null;
                }
            }
        },
        _getImageData: function(x, y) {
            var width = this.hitCanvas.width || 1,
                height = this.hitCanvas.height || 1,
                index = (Math.round(y) * width ) + Math.round(x);

            if (!this._hitImageData) {
                this._hitImageData = this.hitCanvas.context.getImageData(0, 0, width, height);
            }

            return [
                this._hitImageData.data[4 * index + 0], // Red
                this._hitImageData.data[4 * index + 1], // Green
                this._hitImageData.data[4 * index + 2], // Blue
                this._hitImageData.data[4 * index + 3] // Alpha
            ];
        },
        _getIntersection: function(pos) {
            var ratio = this.hitCanvas.pixelRatio;
            var p = this.hitCanvas.context.getImageData(Math.round(pos.x * ratio), Math.round(pos.y * ratio), 1, 1).data,
                p3 = p[3],
                colorKey, shape;
            // fully opaque pixel
            if(p3 === 255) {
                colorKey = Konva.Util._rgbToHex(p[0], p[1], p[2]);
                shape = Konva.shapes[HASH + colorKey];
                if (shape) {
                    return {
                        shape: shape
                    };
                }
                return {
                    antialiased: true
                };
            }
            // antialiased pixel
            else if(p3 > 0) {
                return {
                    antialiased: true
                };
            }
            // empty pixel
            return {};
        },
        drawScene: function(can, top) {
            var layer = this.getLayer(),
                canvas = can || (layer && layer.getCanvas());

            this._fire(BEFORE_DRAW, {
                node: this
            });

            if(this.getClearBeforeDraw()) {
                canvas.getContext().clear();
            }

            Konva.Container.prototype.drawScene.call(this, canvas, top);

            this._fire(DRAW, {
                node: this
            });

            return this;
        },
        drawHit: function(can, top) {
            var layer = this.getLayer(),
                canvas = can || (layer && layer.hitCanvas);

            if(layer && layer.getClearBeforeDraw()) {
                layer.getHitCanvas().getContext().clear();
            }

            Konva.Container.prototype.drawHit.call(this, canvas, top);
            this.imageData = null; // Clear imageData cache
            return this;
        },
        clear: function(bounds) {
            Konva.BaseLayer.prototype.clear.call(this, bounds);
            this.getHitCanvas().getContext().clear(bounds);
            this.imageData = null; // Clear getImageData cache
            return this;
        },
        // extend Node.prototype.setVisible
        setVisible: function(visible) {
            Konva.Node.prototype.setVisible.call(this, visible);
            if(visible) {
                this.getCanvas()._canvas.style.display = 'block';
                this.hitCanvas._canvas.style.display = 'block';
            }
            else {
                this.getCanvas()._canvas.style.display = 'none';
                this.hitCanvas._canvas.style.display = 'none';
            }
            return this;
        },
        /**
         * enable hit graph
         * @name enableHitGraph
         * @method
         * @memberof Konva.Layer.prototype
         * @returns {Layer}
         */
        enableHitGraph: function() {
            this.setHitGraphEnabled(true);
            return this;
        },
        /**
         * disable hit graph
         * @name disableHitGraph
         * @method
         * @memberof Konva.Layer.prototype
         * @returns {Layer}
         */
        disableHitGraph: function() {
            this.setHitGraphEnabled(false);
            return this;
        },
        setSize: function(width, height) {
            Konva.BaseLayer.prototype.setSize.call(this, width, height);
            this.hitCanvas.setSize(width, height);
        }
    });
    Konva.Util.extend(Konva.Layer, Konva.BaseLayer);

    Konva.Factory.addGetterSetter(Konva.Layer, 'hitGraphEnabled', true);
    /**
     * get/set hitGraphEnabled flag.  Disabling the hit graph will greatly increase
     *  draw performance because the hit graph will not be redrawn each time the layer is
     *  drawn.  This, however, also disables mouse/touch event detection
     * @name hitGraphEnabled
     * @method
     * @memberof Konva.Layer.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get hitGraphEnabled flag
     * var hitGraphEnabled = layer.hitGraphEnabled();
     *
     * // disable hit graph
     * layer.hitGraphEnabled(false);
     *
     * // enable hit graph
     * layer.hitGraphEnabled(true);
     */
    Konva.Collection.mapMethods(Konva.Layer);
})();

(function() {
    'use strict';
    /**
     * FastLayer constructor. Layers are tied to their own canvas element and are used
     * to contain shapes only.  If you don't need node nesting, mouse and touch interactions,
     * or event pub/sub, you should use FastLayer instead of Layer to create your layers.
     * It renders about 2x faster than normal layers.
     * @constructor
     * @memberof Konva
     * @augments Konva.BaseLayer
     * @param {Object} config
     * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
     * to clear the canvas before each layer draw.  The default value is true.
     * @param {Boolean} [config.visible]
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height

     * @example
     * var layer = new Konva.FastLayer();
     */
    Konva.FastLayer = function(config) {
        this.____init(config);
    };

    Konva.Util.addMethods(Konva.FastLayer, {
        ____init: function(config) {
            this.nodeType = 'Layer';
            this.canvas = new Konva.SceneCanvas();
            // call super constructor
            Konva.BaseLayer.call(this, config);
        },
        _validateAdd: function(child) {
            var type = child.getType();
            if (type !== 'Shape') {
                Konva.Util.throw('You may only add shapes to a fast layer.');
            }
        },
        _setCanvasSize: function(width, height) {
            this.canvas.setSize(width, height);
        },
        hitGraphEnabled: function() {
            return false;
        },
        getIntersection: function() {
            return null;
        },
        drawScene: function(can) {
            var layer = this.getLayer(),
                canvas = can || (layer && layer.getCanvas());

            if(this.getClearBeforeDraw()) {
                canvas.getContext().clear();
            }

            Konva.Container.prototype.drawScene.call(this, canvas);

            return this;
        },
        draw: function() {
            this.drawScene();
            return this;
        },
        // extend Node.prototype.setVisible
        setVisible: function(visible) {
            Konva.Node.prototype.setVisible.call(this, visible);
            if(visible) {
                this.getCanvas()._canvas.style.display = 'block';
            }
            else {
                this.getCanvas()._canvas.style.display = 'none';
            }
            return this;
        }
    });
    Konva.Util.extend(Konva.FastLayer, Konva.BaseLayer);

    Konva.Collection.mapMethods(Konva.FastLayer);
})();

(function() {
    'use strict';
    /**
     * Group constructor.  Groups are used to contain shapes or other groups.
     * @constructor
     * @memberof Konva
     * @augments Konva.Container
     * @param {Object} config
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height

     * @example
     * var group = new Konva.Group();
     */
    Konva.Group = function(config) {
        this.___init(config);
    };

    Konva.Util.addMethods(Konva.Group, {
        ___init: function(config) {
            this.nodeType = 'Group';
            // call super constructor
            Konva.Container.call(this, config);
        },
        _validateAdd: function(child) {
            var type = child.getType();
            if (type !== 'Group' && type !== 'Shape') {
                Konva.Util.throw('You may only add groups and shapes to groups.');
            }
        }
    });
    Konva.Util.extend(Konva.Group, Konva.Container);

    Konva.Collection.mapMethods(Konva.Group);
})();

(function(Konva) {
    'use strict';
    var BATCH_DRAW_STOP_TIME_DIFF = 500;

    var now = (function() {
        if (Konva.root.performance && Konva.root.performance.now) {
            return function() {
                return Konva.root.performance.now();
            };
        }

        return function() {
            return new Date().getTime();
        };
    })();

    function FRAF(callback) {
        setTimeout(callback, 1000 / 60);
    }

    var RAF = (function(){
        return Konva.root.requestAnimationFrame
            || Konva.root.webkitRequestAnimationFrame
            || Konva.root.mozRequestAnimationFrame
            || Konva.root.oRequestAnimationFrame
            || Konva.root.msRequestAnimationFrame
            || FRAF;
    })();



    function requestAnimFrame() {
        return RAF.apply(Konva.root, arguments);
    }

    /**
     * Animation constructor.  A stage is used to contain multiple layers and handle
     * @constructor
     * @memberof Konva
     * @param {Function} func function executed on each animation frame.  The function is passed a frame object, which contains
     *  timeDiff, lastTime, time, and frameRate properties.  The timeDiff property is the number of milliseconds that have passed
     *  since the last animation frame.  The lastTime property is time in milliseconds that elapsed from the moment the animation started
     *  to the last animation frame.  The time property is the time in milliseconds that ellapsed from the moment the animation started
     *  to the current animation frame.  The frameRate property is the current frame rate in frames / second. Return false from function,
     *  if you don't need to redraw layer/layers on some frames.
     * @param {Konva.Layer|Array} [layers] layer(s) to be redrawn on each animation frame. Can be a layer, an array of layers, or null.
     *  Not specifying a node will result in no redraw.
     * @example
     * // move a node to the right at 50 pixels / second
     * var velocity = 50;
     *
     * var anim = new Konva.Animation(function(frame) {
     *   var dist = velocity * (frame.timeDiff / 1000);
     *   node.move(dist, 0);
     * }, layer);
     *
     * anim.start();
     */
    Konva.Animation = function(func, layers) {
        var Anim = Konva.Animation;
        this.func = func;
        this.setLayers(layers);
        this.id = Anim.animIdCounter++;
        this.frame = {
            time: 0,
            timeDiff: 0,
            lastTime: now()
        };
    };
    /*
     * Animation methods
     */
    Konva.Animation.prototype = {
        /**
         * set layers to be redrawn on each animation frame
         * @method
         * @memberof Konva.Animation.prototype
         * @param {Konva.Layer|Array} [layers] layer(s) to be redrawn.&nbsp; Can be a layer, an array of layers, or null.  Not specifying a node will result in no redraw.
         * @return {Konva.Animation} this
         */
        setLayers: function(layers) {
            var lays = [];
            // if passing in no layers
            if (!layers) {
                lays = [];
            }
            // if passing in an array of Layers
            // NOTE: layers could be an array or Konva.Collection.  for simplicity, I'm just inspecting
            // the length property to check for both cases
            else if (layers.length > 0) {
                lays = layers;
            }
            // if passing in a Layer
            else {
                lays = [layers];
            }

            this.layers = lays;
            return this;
        },
        /**
         * get layers
         * @method
         * @memberof Konva.Animation.prototype
         * @return {Array} Array of Konva.Layer
         */
        getLayers: function() {
            return this.layers;
        },
        /**
         * add layer.  Returns true if the layer was added, and false if it was not
         * @method
         * @memberof Konva.Animation.prototype
         * @param {Konva.Layer} layer to add
         * @return {Bool} true if layer is added to animation, otherwise false
         */
        addLayer: function(layer) {
            var layers = this.layers,
                len = layers.length, n;

            // don't add the layer if it already exists
            for (n = 0; n < len; n++) {
                if (layers[n]._id === layer._id){
                    return false;
                }
            }

            this.layers.push(layer);
            return true;
        },
        /**
         * determine if animation is running or not.  returns true or false
         * @method
         * @memberof Konva.Animation.prototype
         * @return {Bool} is animation running?
         */
        isRunning: function() {
            var a = Konva.Animation,
                animations = a.animations,
                len = animations.length,
                n;

            for(n = 0; n < len; n++) {
                if(animations[n].id === this.id) {
                    return true;
                }
            }
            return false;
        },
        /**
         * start animation
         * @method
         * @memberof Konva.Animation.prototype
         * @return {Konva.Animation} this
         */
        start: function() {
            var Anim = Konva.Animation;
            this.stop();
            this.frame.timeDiff = 0;
            this.frame.lastTime = now();
            Anim._addAnimation(this);
            return this;
        },
        /**
         * stop animation
         * @method
         * @memberof Konva.Animation.prototype
         * @return {Konva.Animation} this
         */
        stop: function() {
            Konva.Animation._removeAnimation(this);
            return this;
        },
        _updateFrameObject: function(time) {
            this.frame.timeDiff = time - this.frame.lastTime;
            this.frame.lastTime = time;
            this.frame.time += this.frame.timeDiff;
            this.frame.frameRate = 1000 / this.frame.timeDiff;
        }
    };
    Konva.Animation.animations = [];
    Konva.Animation.animIdCounter = 0;
    Konva.Animation.animRunning = false;

    Konva.Animation._addAnimation = function(anim) {
        this.animations.push(anim);
        this._handleAnimation();
    };
    Konva.Animation._removeAnimation = function(anim) {
        var id = anim.id,
            animations = this.animations,
            len = animations.length,
            n;

        for(n = 0; n < len; n++) {
            if(animations[n].id === id) {
                this.animations.splice(n, 1);
                break;
            }
        }
    };

    Konva.Animation._runFrames = function() {
        var layerHash = {},
            animations = this.animations,
            anim, layers, func, n, i, layersLen, layer, key, needRedraw;
        /*
         * loop through all animations and execute animation
         *  function.  if the animation object has specified node,
         *  we can add the node to the nodes hash to eliminate
         *  drawing the same node multiple times.  The node property
         *  can be the stage itself or a layer
         */
        /*
         * WARNING: don't cache animations.length because it could change while
         * the for loop is running, causing a JS error
         */

        for(n = 0; n < animations.length; n++) {
            anim = animations[n];
            layers = anim.layers;
            func = anim.func;


            anim._updateFrameObject(now());
            layersLen = layers.length;

            // if animation object has a function, execute it
            if (func) {
                // allow anim bypassing drawing
                needRedraw = (func.call(anim, anim.frame) !== false);
            } else {
                needRedraw = true;
            }
            if (!needRedraw) {
                continue;
            }
            for (i = 0; i < layersLen; i++) {
                layer = layers[i];

                if (layer._id !== undefined) {
                    layerHash[layer._id] = layer;
                }
            }
        }

        for (key in layerHash) {
            if (!layerHash.hasOwnProperty(key)) {
                continue;
            }
            layerHash[key].draw();
        }
    };
    Konva.Animation._animationLoop = function() {
        var Anim = Konva.Animation;
        if(Anim.animations.length) {
            requestAnimFrame(Anim._animationLoop);
            Anim._runFrames();
        }
        else {
            Anim.animRunning = false;
        }
    };
    Konva.Animation._handleAnimation = function() {
        if(!this.animRunning) {
            this.animRunning = true;
            this._animationLoop();
        }
    };

    var moveTo = Konva.Node.prototype.moveTo;
    Konva.Node.prototype.moveTo = function(container) {
        moveTo.call(this, container);
    };

    /**
     * batch draw
     * @method
     * @return {Konva.Layer} this
     * @memberof Konva.Base.prototype
     */
    Konva.BaseLayer.prototype.batchDraw = function() {
        var that = this,
            Anim = Konva.Animation;

        if (!this.batchAnim) {
            this.batchAnim = new Anim(function() {
                if (that.lastBatchDrawTime && now() - that.lastBatchDrawTime > BATCH_DRAW_STOP_TIME_DIFF) {
                    that.batchAnim.stop();
                }
            }, this);
        }

        this.lastBatchDrawTime = now();

        if (!this.batchAnim.isRunning()) {
            this.draw();
            this.batchAnim.start();
        }
        return this;
    };

    /**
     * batch draw
     * @method
     * @return {Konva.Stage} this
     * @memberof Konva.Stage.prototype
     */
    Konva.Stage.prototype.batchDraw = function() {
        this.getChildren().each(function(layer) {
            layer.batchDraw();
        });
        return this;
    };
})(Konva);

(function() {
    'use strict';
    var blacklist = {
        node: 1,
        duration: 1,
        easing: 1,
        onFinish: 1,
        yoyo: 1
    },

    PAUSED = 1,
    PLAYING = 2,
    REVERSING = 3,

    idCounter = 0,
    colorAttrs = ['fill', 'stroke', 'shadowColor'];

    var Tween = function(prop, propFunc, func, begin, finish, duration, yoyo) {
        this.prop = prop;
        this.propFunc = propFunc;
        this.begin = begin;
        this._pos = begin;
        this.duration = duration;
        this._change = 0;
        this.prevPos = 0;
        this.yoyo = yoyo;
        this._time = 0;
        this._position = 0;
        this._startTime = 0;
        this._finish = 0;
        this.func = func;
        this._change = finish - this.begin;
        this.pause();
    };
    /*
     * Tween methods
     */
    Tween.prototype = {
        fire: function(str) {
            var handler = this[str];
            if (handler) {
                handler();
            }
        },
        setTime: function(t) {
            if(t > this.duration) {
                if(this.yoyo) {
                    this._time = this.duration;
                    this.reverse();
                }
                else {
                    this.finish();
                }
            }
            else if(t < 0) {
                if(this.yoyo) {
                    this._time = 0;
                    this.play();
                }
                else {
                    this.reset();
                }
            }
            else {
                this._time = t;
                this.update();
            }
        },
        getTime: function() {
            return this._time;
        },
        setPosition: function(p) {
            this.prevPos = this._pos;
            this.propFunc(p);
            this._pos = p;
        },
        getPosition: function(t) {
            if(t === undefined) {
                t = this._time;
            }
            return this.func(t, this.begin, this._change, this.duration);
        },
        play: function() {
            this.state = PLAYING;
            this._startTime = this.getTimer() - this._time;
            this.onEnterFrame();
            this.fire('onPlay');
        },
        reverse: function() {
            this.state = REVERSING;
            this._time = this.duration - this._time;
            this._startTime = this.getTimer() - this._time;
            this.onEnterFrame();
            this.fire('onReverse');
        },
        seek: function(t) {
            this.pause();
            this._time = t;
            this.update();
            this.fire('onSeek');
        },
        reset: function() {
            this.pause();
            this._time = 0;
            this.update();
            this.fire('onReset');
        },
        finish: function() {
            this.pause();
            this._time = this.duration;
            this.update();
            this.fire('onFinish');
        },
        update: function() {
            this.setPosition(this.getPosition(this._time));
        },
        onEnterFrame: function() {
            var t = this.getTimer() - this._startTime;
            if(this.state === PLAYING) {
                this.setTime(t);
            }
            else if (this.state === REVERSING) {
                this.setTime(this.duration - t);
            }
        },
        pause: function() {
            this.state = PAUSED;
            this.fire('onPause');
        },
        getTimer: function() {
            return new Date().getTime();
        }
    };

    /**
     * Tween constructor.  Tweens enable you to animate a node between the current state and a new state.
     *  You can play, pause, reverse, seek, reset, and finish tweens.  By default, tweens are animated using
     *  a linear easing.  For more tweening options, check out {@link Konva.Easings}
     * @constructor
     * @memberof Konva
     * @example
     * // instantiate new tween which fully rotates a node in 1 second
     * var tween = new Konva.Tween({
     *   node: node,
     *   rotationDeg: 360,
     *   duration: 1,
     *   easing: Konva.Easings.EaseInOut
     * });
     *
     * // play tween
     * tween.play();
     *
     * // pause tween
     * tween.pause();
     */
    Konva.Tween = function(config) {
        var that = this,
            node = config.node,
            nodeId = node._id,
            duration,
            easing = config.easing || Konva.Easings.Linear,
            yoyo = !!config.yoyo,
            key;

        if (typeof config.duration === 'undefined') {
            duration = 1;
        } else if (config.duration === 0) {  // zero is bad value for duration
            duration = 0.001;
        } else {
            duration = config.duration;
        }
        this.node = node;
        this._id = idCounter++;

        this.anim = new Konva.Animation(function() {
            that.tween.onEnterFrame();
        }, node.getLayer() || ((node instanceof Konva.Stage) ? node.getLayers() : null));

        this.tween = new Tween(key, function(i) {
            that._tweenFunc(i);
        }, easing, 0, 1, duration * 1000, yoyo);

        this._addListeners();

        // init attrs map
        if (!Konva.Tween.attrs[nodeId]) {
            Konva.Tween.attrs[nodeId] = {};
        }
        if (!Konva.Tween.attrs[nodeId][this._id]) {
            Konva.Tween.attrs[nodeId][this._id] = {};
        }
        // init tweens map
        if (!Konva.Tween.tweens[nodeId]) {
            Konva.Tween.tweens[nodeId] = {};
        }

        for (key in config) {
            if (blacklist[key] === undefined) {
                this._addAttr(key, config[key]);
            }
        }

        this.reset();

        // callbacks
        this.onFinish = config.onFinish;
        this.onReset = config.onReset;
    };

    // start/diff object = attrs.nodeId.tweenId.attr
    Konva.Tween.attrs = {};
    // tweenId = tweens.nodeId.attr
    Konva.Tween.tweens = {};

    Konva.Tween.prototype = {
        _addAttr: function(key, end) {
            var node = this.node,
                nodeId = node._id,
                start, diff, tweenId, n, len, trueEnd, trueStart;

            // remove conflict from tween map if it exists
            tweenId = Konva.Tween.tweens[nodeId][key];

            if (tweenId) {
                delete Konva.Tween.attrs[nodeId][tweenId][key];
            }

            // add to tween map
            start = node.getAttr(key);

            if (Konva.Util._isArray(end)) {
                diff = [];
                len = Math.max(end.length, start.length);

                if (key === 'points' && end.length !== start.length) {
                    // before tweening points we need to make sure that start.length === end.length
                    // Konva.Util._prepareArrayForTween thinking that end.length > start.length

                    if (end.length > start.length) {
                        // so in this case we will increase number of starting points
                        trueStart = start;
                        start = Konva.Util._prepareArrayForTween(start, end, node.closed());
                    } else {
                        // in this case we will increase number of eding points
                        trueEnd = end;
                        end = Konva.Util._prepareArrayForTween(end, start, node.closed());
                    }
                }

                for (n = 0; n < len; n++) {
                    diff.push((end[n]) - (start[n]));
                }

            } else if (colorAttrs.indexOf(key) !== -1) {
                start = Konva.Util.colorToRGBA(start);
                var endRGBA = Konva.Util.colorToRGBA(end);
                diff = {
                    r: endRGBA.r - start.r,
                    g: endRGBA.g - start.g,
                    b: endRGBA.b - start.b,
                    a: endRGBA.a - start.a
                };
            } else {
                diff = end - start;
            }

            Konva.Tween.attrs[nodeId][this._id][key] = {
                start: start,
                diff: diff,
                end: end,
                trueEnd: trueEnd,
                trueStart: trueStart
            };
            Konva.Tween.tweens[nodeId][key] = this._id;
        },
        _tweenFunc: function(i) {
            var node = this.node,
                attrs = Konva.Tween.attrs[node._id][this._id],
                key, attr, start, diff, newVal, n, len, end;

            for (key in attrs) {
                attr = attrs[key];
                start = attr.start;
                diff = attr.diff;
                end = attr.end;

                if (Konva.Util._isArray(start)) {
                    newVal = [];
                    len = Math.max(start.length, end.length);
                    for (n = 0; n < len; n++) {
                        newVal.push((start[n] || 0) + (diff[n] * i));
                    }
                } else if (colorAttrs.indexOf(key) !== -1) {
                    newVal = 'rgba(' +
                            Math.round(start.r + diff.r * i) + ',' +
                            Math.round(start.g + diff.g * i) + ',' +
                            Math.round(start.b + diff.b * i) + ',' +
                            (start.a + diff.a * i) + ')';
                } else {
                    newVal = start + (diff * i);
                }

                node.setAttr(key, newVal);
            }
        },
        _addListeners: function() {
            var that = this;

            // start listeners
            this.tween.onPlay = function() {
                that.anim.start();
            };
            this.tween.onReverse = function() {
                that.anim.start();
            };

            // stop listeners
            this.tween.onPause = function() {
                that.anim.stop();
            };
            this.tween.onFinish = function() {
                var node = that.node;

                // after tweening  points of line we need to set original end
                var attrs = Konva.Tween.attrs[node._id][that._id];
                if (attrs.points && attrs.points.trueEnd) {
                    node.points(attrs.points.trueEnd);
                }

                if (that.onFinish) {
                    that.onFinish.call(that);
                }
            };
            this.tween.onReset = function() {
                var node = that.node;
                // after tweening  points of line we need to set original start
                var attrs = Konva.Tween.attrs[node._id][that._id];
                if (attrs.points && attrs.points.trueStart) {
                    node.points(attrs.points.trueStart);
                }

                if (that.onReset) {
                    that.onReset();
                }
            };
        },
        /**
         * play
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
        play: function() {
            this.tween.play();
            return this;
        },
        /**
         * reverse
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
        reverse: function() {
            this.tween.reverse();
            return this;
        },
        /**
         * reset
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
        reset: function() {
            this.tween.reset();
            return this;
        },
        /**
         * seek
         * @method
         * @memberof Konva.Tween.prototype
         * @param {Integer} t time in seconds between 0 and the duration
         * @returns {Tween}
         */
        seek: function(t) {
            this.tween.seek(t * 1000);
            return this;
        },
        /**
         * pause
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
        pause: function() {
            this.tween.pause();
            return this;
        },
        /**
         * finish
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
        finish: function() {
            this.tween.finish();
            return this;
        },
        /**
         * destroy
         * @method
         * @memberof Konva.Tween.prototype
         */
        destroy: function() {
            var nodeId = this.node._id,
                thisId = this._id,
                attrs = Konva.Tween.tweens[nodeId],
                key;

            this.pause();

            for (key in attrs) {
                delete Konva.Tween.tweens[nodeId][key];
            }

            delete Konva.Tween.attrs[nodeId][thisId];
        }
    };

    /**
     * Tween node properties. Shorter usage of {@link Konva.Tween} object.
     *
     * @method Konva.Node#to
     * @memberof Konva.Node
     * @param {Object} [params] tween params
     * @example
     *
     * circle.to({
     *  x : 50,
     *  duration : 0.5
     * });
     */
    Konva.Node.prototype.to = function(params) {
        var onFinish = params.onFinish;
        params.node = this;
        params.onFinish = function() {
            this.destroy();
            if (onFinish) {
                onFinish();
            }
        };
        var tween = new Konva.Tween(params);
        tween.play();
    };

    /*
    * These eases were ported from an Adobe Flash tweening library to JavaScript
    * by Xaric
    */

    /**
     * @namespace Easings
     * @memberof Konva
     */
    Konva.Easings = {
        /**
        * back ease in
        * @function
        * @memberof Konva.Easings
        */
        'BackEaseIn': function(t, b, c, d) {
            var s = 1.70158;
            return c * (t /= d) * t * ((s + 1) * t - s) + b;
        },
        /**
        * back ease out
        * @function
        * @memberof Konva.Easings
        */
        'BackEaseOut': function(t, b, c, d) {
            var s = 1.70158;
            return c * (( t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
        },
        /**
        * back ease in out
        * @function
        * @memberof Konva.Easings
        */
        'BackEaseInOut': function(t, b, c, d) {
            var s = 1.70158;
            if((t /= d / 2) < 1) {
                return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
            }
            return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
        },
        /**
        * elastic ease in
        * @function
        * @memberof Konva.Easings
        */
        'ElasticEaseIn': function(t, b, c, d, a, p) {
            // added s = 0
            var s = 0;
            if(t === 0) {
                return b;
            }
            if((t /= d) === 1) {
                return b + c;
            }
            if(!p) {
                p = d * 0.3;
            }
            if(!a || a < Math.abs(c)) {
                a = c;
                s = p / 4;
            }
            else {
                s = p / (2 * Math.PI) * Math.asin(c / a);
            }
            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
        },
        /**
        * elastic ease out
        * @function
        * @memberof Konva.Easings
        */
        'ElasticEaseOut': function(t, b, c, d, a, p) {
            // added s = 0
            var s = 0;
            if(t === 0) {
                return b;
            }
            if((t /= d) === 1) {
                return b + c;
            }
            if(!p) {
                p = d * 0.3;
            }
            if(!a || a < Math.abs(c)) {
                a = c;
                s = p / 4;
            }
            else {
                s = p / (2 * Math.PI) * Math.asin(c / a);
            }
            return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b);
        },
        /**
        * elastic ease in out
        * @function
        * @memberof Konva.Easings
        */
        'ElasticEaseInOut': function(t, b, c, d, a, p) {
            // added s = 0
            var s = 0;
            if(t === 0) {
                return b;
            }
            if((t /= d / 2) === 2) {
                return b + c;
            }
            if(!p) {
                p = d * (0.3 * 1.5);
            }
            if(!a || a < Math.abs(c)) {
                a = c;
                s = p / 4;
            }
            else {
                s = p / (2 * Math.PI) * Math.asin(c / a);
            }
            if(t < 1) {
                return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
            }
            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
        },
        /**
        * bounce ease out
        * @function
        * @memberof Konva.Easings
        */
        'BounceEaseOut': function(t, b, c, d) {
            if((t /= d) < (1 / 2.75)) {
                return c * (7.5625 * t * t) + b;
            }
            else if(t < (2 / 2.75)) {
                return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
            }
            else if(t < (2.5 / 2.75)) {
                return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
            }
            else {
                return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
            }
        },
        /**
        * bounce ease in
        * @function
        * @memberof Konva.Easings
        */
        'BounceEaseIn': function(t, b, c, d) {
            return c - Konva.Easings.BounceEaseOut(d - t, 0, c, d) + b;
        },
        /**
        * bounce ease in out
        * @function
        * @memberof Konva.Easings
        */
        'BounceEaseInOut': function(t, b, c, d) {
            if(t < d / 2) {
                return Konva.Easings.BounceEaseIn(t * 2, 0, c, d) * 0.5 + b;
            }
            else {
                return Konva.Easings.BounceEaseOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
            }
        },
        /**
        * ease in
        * @function
        * @memberof Konva.Easings
        */
        'EaseIn': function(t, b, c, d) {
            return c * (t /= d) * t + b;
        },
        /**
        * ease out
        * @function
        * @memberof Konva.Easings
        */
        'EaseOut': function(t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
        },
        /**
        * ease in out
        * @function
        * @memberof Konva.Easings
        */
        'EaseInOut': function(t, b, c, d) {
            if((t /= d / 2) < 1) {
                return c / 2 * t * t + b;
            }
            return -c / 2 * ((--t) * (t - 2) - 1) + b;
        },
        /**
        * strong ease in
        * @function
        * @memberof Konva.Easings
        */
        'StrongEaseIn': function(t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b;
        },
        /**
        * strong ease out
        * @function
        * @memberof Konva.Easings
        */
        'StrongEaseOut': function(t, b, c, d) {
            return c * (( t = t / d - 1) * t * t * t * t + 1) + b;
        },
        /**
        * strong ease in out
        * @function
        * @memberof Konva.Easings
        */
        'StrongEaseInOut': function(t, b, c, d) {
            if((t /= d / 2) < 1) {
                return c / 2 * t * t * t * t * t + b;
            }
            return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
        },
        /**
        * linear
        * @function
        * @memberof Konva.Easings
        */
        'Linear': function(t, b, c, d) {
            return c * t / d + b;
        }
    };
})();

(function() {
    'use strict';
    Konva.DD = {
        // properties
        anim: new Konva.Animation(function() {
            var b = this.dirty;
            this.dirty = false;
            return b;
        }),
        isDragging: false,
        justDragged: false,
        offset: {
            x: 0,
            y: 0
        },
        node: null,

        // methods
        _drag: function(evt) {
            var dd = Konva.DD,
                node = dd.node;

            if(node) {
               if(!dd.isDragging) {
                    var pos = node.getStage().getPointerPosition();
                    var dragDistance = node.dragDistance();
                    var distance = Math.max(
                        Math.abs(pos.x - dd.startPointerPos.x),
                        Math.abs(pos.y - dd.startPointerPos.y)
                    );
                    if (distance < dragDistance) {
                        return;
                    }
                }


                node.getStage()._setPointerPosition(evt);
                node._setDragPosition(evt);
                if(!dd.isDragging) {
                    dd.isDragging = true;
                    node.fire('dragstart', {
                        type: 'dragstart',
                        target: node,
                        evt: evt
                    }, true);
                }

                // execute ondragmove if defined
                node.fire('dragmove', {
                    type: 'dragmove',
                    target: node,
                    evt: evt
                }, true);
            }
        },
        _endDragBefore: function(evt) {
            var dd = Konva.DD,
                node = dd.node,
                layer;

            if(node) {
                layer = node.getLayer();
                dd.anim.stop();

                // only fire dragend event if the drag and drop
                // operation actually started.
                if(dd.isDragging) {
                    dd.isDragging = false;
                    dd.justDragged = true;
                    Konva.listenClickTap = false;

                    if (evt) {
                        evt.dragEndNode = node;
                    }
                }

                delete dd.node;

                (layer || node).draw();
            }
        },
        _endDragAfter: function(evt) {
            evt = evt || {};
            var dragEndNode = evt.dragEndNode;

            if (evt && dragEndNode) {
                dragEndNode.fire('dragend', {
                    type: 'dragend',
                    target: dragEndNode,
                    evt: evt
                }, true);
            }
        }
    };

    // Node extenders

    /**
     * initiate drag and drop
     * @method
     * @memberof Konva.Node.prototype
     */
    Konva.Node.prototype.startDrag = function() {
        var dd = Konva.DD,
            stage = this.getStage(),
            layer = this.getLayer(),
            pos = stage.getPointerPosition(),
            ap = this.getAbsolutePosition();

        if(pos) {
            if (dd.node) {
                dd.node.stopDrag();
            }

            dd.node = this;
            dd.startPointerPos = pos;
            dd.offset.x = pos.x - ap.x;
            dd.offset.y = pos.y - ap.y;
            dd.anim.setLayers(layer || this.getLayers());
            dd.anim.start();

            this._setDragPosition();
        }
    };

    Konva.Node.prototype._setDragPosition = function(evt) {
        var dd = Konva.DD,
            pos = this.getStage().getPointerPosition(),
            dbf = this.getDragBoundFunc();
        if (!pos) {
            return;
        }
        var newNodePos = {
            x: pos.x - dd.offset.x,
            y: pos.y - dd.offset.y
        };

        if(dbf !== undefined) {
            newNodePos = dbf.call(this, newNodePos, evt);
        }
        this.setAbsolutePosition(newNodePos);

        if (!this._lastPos || this._lastPos.x !== newNodePos.x ||
            this._lastPos.y !== newNodePos.y) {
            dd.anim.dirty = true;
        }

        this._lastPos = newNodePos;
    };

    /**
     * stop drag and drop
     * @method
     * @memberof Konva.Node.prototype
     */
    Konva.Node.prototype.stopDrag = function() {
        var dd = Konva.DD,
            evt = {};
        dd._endDragBefore(evt);
        dd._endDragAfter(evt);
    };

    Konva.Node.prototype.setDraggable = function(draggable) {
        this._setAttr('draggable', draggable);
        this._dragChange();
    };

    var origDestroy = Konva.Node.prototype.destroy;

    Konva.Node.prototype.destroy = function() {
        var dd = Konva.DD;

        // stop DD
        if(dd.node && dd.node._id === this._id) {

            this.stopDrag();
        }

        origDestroy.call(this);
    };

    /**
     * determine if node is currently in drag and drop mode
     * @method
     * @memberof Konva.Node.prototype
     */
    Konva.Node.prototype.isDragging = function() {
        var dd = Konva.DD;
        return !!(dd.node && dd.node._id === this._id && dd.isDragging);
    };

    Konva.Node.prototype._listenDrag = function() {
        var that = this;

        this._dragCleanup();

        if (this.getClassName() === 'Stage') {
            this.on('contentMousedown.konva contentTouchstart.konva', function(evt) {
                if(!Konva.DD.node) {
                    that.startDrag(evt);
                }
            });
        }
        else {
            this.on('mousedown.konva touchstart.konva', function(evt) {
                // ignore right and middle buttons
                if (evt.evt.button === 1 || evt.evt.button === 2) {
                    return;
                }
                if(!Konva.DD.node) {
                    that.startDrag(evt);
                }
            });
        }

        // listening is required for drag and drop
        /*
        this._listeningEnabled = true;
        this._clearSelfAndAncestorCache('listeningEnabled');
        */
    };

    Konva.Node.prototype._dragChange = function() {
        if(this.attrs.draggable) {
            this._listenDrag();
        }
        else {
            // remove event listeners
            this._dragCleanup();

            /*
             * force drag and drop to end
             * if this node is currently in
             * drag and drop mode
             */
            var stage = this.getStage();
            var dd = Konva.DD;
            if(stage && dd.node && dd.node._id === this._id) {
                dd.node.stopDrag();
            }
        }
    };

    Konva.Node.prototype._dragCleanup = function() {
        if (this.getClassName() === 'Stage') {
            this.off('contentMousedown.konva');
            this.off('contentTouchstart.konva');
        } else {
            this.off('mousedown.konva');
            this.off('touchstart.konva');
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'dragBoundFunc');

    /**
     * get/set drag bound function.  This is used to override the default
     *  drag and drop position
     * @name dragBoundFunc
     * @method
     * @memberof Konva.Node.prototype
     * @param {Function} dragBoundFunc
     * @returns {Function}
     * @example
     * // get drag bound function
     * var dragBoundFunc = node.dragBoundFunc();
     *
     * // create vertical drag and drop
     * node.dragBoundFunc(function(pos){
     *   return {
     *     x: this.getAbsolutePosition().x,
     *     y: pos.y
     *   };
     * });
     */

    Konva.Factory.addGetter(Konva.Node, 'draggable', false);
    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'draggable');

     /**
     * get/set draggable flag
     * @name draggable
     * @method
     * @memberof Konva.Node.prototype
     * @param {Boolean} draggable
     * @returns {Boolean}
     * @example
     * // get draggable flag
     * var draggable = node.draggable();
     *
     * // enable drag and drop
     * node.draggable(true);
     *
     * // disable drag and drop
     * node.draggable(false);
     */

    var html = Konva.document.documentElement;
    html.addEventListener('mouseup', Konva.DD._endDragBefore, true);
    html.addEventListener('touchend', Konva.DD._endDragBefore, true);

    html.addEventListener('mousemove', Konva.DD._drag);
    html.addEventListener('touchmove', Konva.DD._drag);

    html.addEventListener('mouseup', Konva.DD._endDragAfter, false);
    html.addEventListener('touchend', Konva.DD._endDragAfter, false);

})();

(function() {
    'use strict';
    /**
     * Rect constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} [config.cornerRadius]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var rect = new Konva.Rect({
     *   width: 100,
     *   height: 50,
     *   fill: 'red',
     *   stroke: 'black',
     *   strokeWidth: 5
     * });
     */
    Konva.Rect = function(config) {
        this.___init(config);
    };

    Konva.Rect.prototype = {
        ___init: function(config) {
            Konva.Shape.call(this, config);
            this.className = 'Rect';
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            var cornerRadius = this.getCornerRadius(),
                width = this.getWidth(),
                height = this.getHeight();

            context.beginPath();

            if(!cornerRadius) {
                // simple rect - don't bother doing all that complicated maths stuff.
                context.rect(0, 0, width, height);
            } else {
                // arcTo would be nicer, but browser support is patchy (Opera)
                cornerRadius = Math.min(cornerRadius, width / 2, height / 2);
                context.moveTo(cornerRadius, 0);
                context.lineTo(width - cornerRadius, 0);
                context.arc(width - cornerRadius, cornerRadius, cornerRadius, Math.PI * 3 / 2, 0, false);
                context.lineTo(width, height - cornerRadius);
                context.arc(width - cornerRadius, height - cornerRadius, cornerRadius, 0, Math.PI / 2, false);
                context.lineTo(cornerRadius, height);
                context.arc(cornerRadius, height - cornerRadius, cornerRadius, Math.PI / 2, Math.PI, false);
                context.lineTo(0, cornerRadius);
                context.arc(cornerRadius, cornerRadius, cornerRadius, Math.PI, Math.PI * 3 / 2, false);
            }
            context.closePath();
            context.fillStrokeShape(this);
        }
    };

    Konva.Util.extend(Konva.Rect, Konva.Shape);

    Konva.Factory.addGetterSetter(Konva.Rect, 'cornerRadius', 0);
    /**
     * get/set corner radius
     * @name cornerRadius
     * @method
     * @memberof Konva.Rect.prototype
     * @param {Number} cornerRadius
     * @returns {Number}
     * @example
     * // get corner radius
     * var cornerRadius = rect.cornerRadius();
     *
     * // set corner radius
     * rect.cornerRadius(10);
     */

    Konva.Collection.mapMethods(Konva.Rect);
})();

(function() {
    'use strict';
    // the 0.0001 offset fixes a bug in Chrome 27
    var PIx2 = (Math.PI * 2) - 0.0001,
        CIRCLE = 'Circle';

    /**
     * Circle constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.radius
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * // create circle
     * var circle = new Konva.Circle({
     *   radius: 40,
     *   fill: 'red',
     *   stroke: 'black'
     *   strokeWidth: 5
     * });
     */
    Konva.Circle = function(config) {
        this.___init(config);
    };

    Konva.Circle.prototype = {
        _centroid: true,
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = CIRCLE;
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            context.beginPath();
            context.arc(0, 0, this.getRadius(), 0, PIx2, false);
            context.closePath();
            context.fillStrokeShape(this);
        },
        // implements Shape.prototype.getWidth()
        getWidth: function() {
            return this.getRadius() * 2;
        },
        // implements Shape.prototype.getHeight()
        getHeight: function() {
            return this.getRadius() * 2;
        },
        // implements Shape.prototype.setWidth()
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            if (this.radius() !== width / 2) {
                this.setRadius(width / 2);
            }
        },
        // implements Shape.prototype.setHeight()
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            if (this.radius() !== height / 2) {
                this.setRadius(height / 2);
            }
        }
    };
    Konva.Util.extend(Konva.Circle, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Circle, 'radius', 0);
    Konva.Factory.addOverloadedGetterSetter(Konva.Circle, 'radius');

    /**
     * get/set radius
     * @name radius
     * @method
     * @memberof Konva.Circle.prototype
     * @param {Number} radius
     * @returns {Number}
     * @example
     * // get radius
     * var radius = circle.radius();
     *
     * // set radius
     * circle.radius(10);
     */

    Konva.Collection.mapMethods(Konva.Circle);
})();

(function() {
    'use strict';
    // the 0.0001 offset fixes a bug in Chrome 27
    var PIx2 = (Math.PI * 2) - 0.0001,
        ELLIPSE = 'Ellipse';

    /**
     * Ellipse constructor
     * @constructor
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Object} config.radius defines x and y radius
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var ellipse = new Konva.Ellipse({
     *   radius : {
     *     x : 50,
     *     y : 50
     *   },
     *   fill: 'red'
     * });
     */
    Konva.Ellipse = function(config) {
        this.___init(config);
    };

    Konva.Ellipse.prototype = {
        _centroid: true,
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = ELLIPSE;
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            var rx = this.getRadiusX(),
                ry = this.getRadiusY();

            context.beginPath();
            context.save();
            if(rx !== ry) {
                context.scale(1, ry / rx);
            }
            context.arc(0, 0, rx, 0, PIx2, false);
            context.restore();
            context.closePath();
            context.fillStrokeShape(this);
        },
        // implements Shape.prototype.getWidth()
        getWidth: function() {
            return this.getRadiusX() * 2;
        },
        // implements Shape.prototype.getHeight()
        getHeight: function() {
            return this.getRadiusY() * 2;
        },
        // implements Shape.prototype.setWidth()
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            this.setRadius({
                x: width / 2
            });
        },
        // implements Shape.prototype.setHeight()
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            this.setRadius({
                y: height / 2
            });
        }
    };
    Konva.Util.extend(Konva.Ellipse, Konva.Shape);

    // add getters setters
    Konva.Factory.addComponentsGetterSetter(Konva.Ellipse, 'radius', ['x', 'y']);

    /**
     * get/set radius
     * @name radius
     * @method
     * @memberof Konva.Ellipse.prototype
     * @param {Object} radius
     * @param {Number} radius.x
     * @param {Number} radius.y
     * @returns {Object}
     * @example
     * // get radius
     * var radius = ellipse.radius();
     *
     * // set radius
     * ellipse.radius({
     *   x: 200,
     *   y: 100
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Ellipse, 'radiusX', 0);
    /**
     * get/set radius x
     * @name radiusX
     * @method
     * @memberof Konva.Ellipse.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get radius x
     * var radiusX = ellipse.radiusX();
     *
     * // set radius x
     * ellipse.radiusX(200);
     */

    Konva.Factory.addGetterSetter(Konva.Ellipse, 'radiusY', 0);
    /**
     * get/set radius y
     * @name radiusY
     * @method
     * @memberof Konva.Ellipse.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get radius y
     * var radiusY = ellipse.radiusY();
     *
     * // set radius y
     * ellipse.radiusY(200);
     */

    Konva.Collection.mapMethods(Konva.Ellipse);

})();

(function() {
    'use strict';
    // the 0.0001 offset fixes a bug in Chrome 27
    var PIx2 = (Math.PI * 2) - 0.0001;
    /**
     * Ring constructor
     * @constructor
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.innerRadius
     * @param {Number} config.outerRadius
     * @param {Boolean} [config.clockwise]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var ring = new Konva.Ring({
     *   innerRadius: 40,
     *   outerRadius: 80,
     *   fill: 'red',
     *   stroke: 'black',
     *   strokeWidth: 5
     * });
     */
    Konva.Ring = function(config) {
        this.___init(config);
    };

    Konva.Ring.prototype = {
        _centroid: true,
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'Ring';
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            context.beginPath();
            context.arc(0, 0, this.getInnerRadius(), 0, PIx2, false);
            context.moveTo(this.getOuterRadius(), 0);
            context.arc(0, 0, this.getOuterRadius(), PIx2, 0, true);
            context.closePath();
            context.fillStrokeShape(this);
        },
        // implements Shape.prototype.getWidth()
        getWidth: function() {
            return this.getOuterRadius() * 2;
        },
        // implements Shape.prototype.getHeight()
        getHeight: function() {
            return this.getOuterRadius() * 2;
        },
        // implements Shape.prototype.setWidth()
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            if (this.outerRadius() !== width / 2) {
                this.setOuterRadius(width / 2);
            }
        },
        // implements Shape.prototype.setHeight()
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            if (this.outerRadius() !== height / 2) {
                this.setOuterRadius(height / 2);
            }
        },
        setOuterRadius: function(val) {
            this._setAttr('outerRadius', val);
            this.setWidth(val * 2);
            this.setHeight(val * 2);
        }
    };
    Konva.Util.extend(Konva.Ring, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Ring, 'innerRadius', 0);

    /**
     * get/set innerRadius
     * @name innerRadius
     * @method
     * @memberof Konva.Ring.prototype
     * @param {Number} innerRadius
     * @returns {Number}
     * @example
     * // get inner radius
     * var innerRadius = ring.innerRadius();
     *
     * // set inner radius
     * ring.innerRadius(20);
     */
    Konva.Factory.addGetter(Konva.Ring, 'outerRadius', 0);
    Konva.Factory.addOverloadedGetterSetter(Konva.Ring, 'outerRadius');

    /**
     * get/set outerRadius
     * @name outerRadius
     * @method
     * @memberof Konva.Ring.prototype
     * @param {Number} outerRadius
     * @returns {Number}
     * @example
     * // get outer radius
     * var outerRadius = ring.outerRadius();
     *
     * // set outer radius
     * ring.outerRadius(20);
     */

    Konva.Collection.mapMethods(Konva.Ring);
})();

(function() {
    'use strict';
    /**
     * Wedge constructor
     * @constructor
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.angle in degrees
     * @param {Number} config.radius
     * @param {Boolean} [config.clockwise]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * // draw a wedge that's pointing downwards
     * var wedge = new Konva.Wedge({
     *   radius: 40,
     *   fill: 'red',
     *   stroke: 'black'
     *   strokeWidth: 5,
     *   angleDeg: 60,
     *   rotationDeg: -120
     * });
     */
    Konva.Wedge = function(config) {
        this.___init(config);
    };

    Konva.Wedge.prototype = {
        _centroid: true,
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'Wedge';
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            context.beginPath();
            context.arc(0, 0, this.getRadius(), 0, Konva.getAngle(this.getAngle()), this.getClockwise());
            context.lineTo(0, 0);
            context.closePath();
            context.fillStrokeShape(this);
        },
        // implements Shape.prototype.getWidth()
        getWidth: function() {
            return this.getRadius() * 2;
        },
        // implements Shape.prototype.getHeight()
        getHeight: function() {
            return this.getRadius() * 2;
        },
        // implements Shape.prototype.setWidth()
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            if (this.radius() !== width / 2) {
                this.setRadius(width / 2);
            }
        },
        // implements Shape.prototype.setHeight()
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            if (this.radius() !== height / 2) {
                this.setRadius(height / 2);
            }
        }
    };
    Konva.Util.extend(Konva.Wedge, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Wedge, 'radius', 0);

    /**
     * get/set radius
     * @name radius
     * @method
     * @memberof Konva.Wedge.prototype
     * @param {Number} radius
     * @returns {Number}
     * @example
     * // get radius
     * var radius = wedge.radius();
     *
     * // set radius
     * wedge.radius(10);
     */

    Konva.Factory.addGetterSetter(Konva.Wedge, 'angle', 0);

    /**
     * get/set angle in degrees
     * @name angle
     * @method
     * @memberof Konva.Wedge.prototype
     * @param {Number} angle
     * @returns {Number}
     * @example
     * // get angle
     * var angle = wedge.angle();
     *
     * // set angle
     * wedge.angle(20);
     */

    Konva.Factory.addGetterSetter(Konva.Wedge, 'clockwise', false);

    /**
     * get/set clockwise flag
     * @name clockwise
     * @method
     * @memberof Konva.Wedge.prototype
     * @param {Number} clockwise
     * @returns {Number}
     * @example
     * // get clockwise flag
     * var clockwise = wedge.clockwise();
     *
     * // draw wedge counter-clockwise
     * wedge.clockwise(false);
     *
     * // draw wedge clockwise
     * wedge.clockwise(true);
     */

    Konva.Factory.backCompat(Konva.Wedge, {
        angleDeg: 'angle',
        getAngleDeg: 'getAngle',
        setAngleDeg: 'setAngle'
    });

    Konva.Collection.mapMethods(Konva.Wedge);
})();

(function() {
    'use strict';
    /**
     * Arc constructor
     * @constructor
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.angle in degrees
     * @param {Number} config.innerRadius
     * @param {Number} config.outerRadius
     * @param {Boolean} [config.clockwise]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * // draw a Arc that's pointing downwards
     * var arc = new Konva.Arc({
     *   innerRadius: 40,
     *   outerRadius: 80,
     *   fill: 'red',
     *   stroke: 'black'
     *   strokeWidth: 5,
     *   angle: 60,
     *   rotationDeg: -120
     * });
     */
    Konva.Arc = function(config) {
        this.___init(config);
    };

    Konva.Arc.prototype = {
        _centroid: true,
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'Arc';
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            var angle = Konva.getAngle(this.angle()),
                clockwise = this.clockwise();

            context.beginPath();
            context.arc(0, 0, this.getOuterRadius(), 0, angle, clockwise);
            context.arc(0, 0, this.getInnerRadius(), angle, 0, !clockwise);
            context.closePath();
            context.fillStrokeShape(this);
        },
        // implements Shape.prototype.getWidth()
        getWidth: function() {
            return this.getOuterRadius() * 2;
        },
        // implements Shape.prototype.getHeight()
        getHeight: function() {
            return this.getOuterRadius() * 2;
        },
        // implements Shape.prototype.setWidth()
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            if (this.getOuterRadius() !== width / 2) {
                this.setOuterRadius(width / 2);
            }
        },
        // implements Shape.prototype.setHeight()
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            if (this.getOuterRadius() !== height / 2) {
                this.setOuterRadius(height / 2);
            }
        }
    };
    Konva.Util.extend(Konva.Arc, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Arc, 'innerRadius', 0);

    /**
     * get/set innerRadius
     * @name innerRadius
     * @method
     * @memberof Konva.Arc.prototype
     * @param {Number} innerRadius
     * @returns {Number}
     * @example
     * // get inner radius
     * var innerRadius = arc.innerRadius();
     *
     * // set inner radius
     * arc.innerRadius(20);
     */

    Konva.Factory.addGetterSetter(Konva.Arc, 'outerRadius', 0);

    /**
     * get/set outerRadius
     * @name outerRadius
     * @method
     * @memberof Konva.Arc.prototype
     * @param {Number} outerRadius
     * @returns {Number}
     * @example
     * // get outer radius
     * var outerRadius = arc.outerRadius();
     *
     * // set outer radius
     * arc.outerRadius(20);
     */

    Konva.Factory.addGetterSetter(Konva.Arc, 'angle', 0);

    /**
     * get/set angle in degrees
     * @name angle
     * @method
     * @memberof Konva.Arc.prototype
     * @param {Number} angle
     * @returns {Number}
     * @example
     * // get angle
     * var angle = arc.angle();
     *
     * // set angle
     * arc.angle(20);
     */

    Konva.Factory.addGetterSetter(Konva.Arc, 'clockwise', false);

    /**
     * get/set clockwise flag
     * @name clockwise
     * @method
     * @memberof Konva.Arc.prototype
     * @param {Boolean} clockwise
     * @returns {Boolean}
     * @example
     * // get clockwise flag
     * var clockwise = arc.clockwise();
     *
     * // draw arc counter-clockwise
     * arc.clockwise(false);
     *
     * // draw arc clockwise
     * arc.clockwise(true);
     */

    Konva.Collection.mapMethods(Konva.Arc);
})();

(function() {
    'use strict';
    // CONSTANTS
    var IMAGE = 'Image';

    /**
     * Image constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Image} config.image
     * @param {Object} [config.crop]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var imageObj = new Image();
     * imageObj.onload = function() {
     *   var image = new Konva.Image({
     *     x: 200,
     *     y: 50,
     *     image: imageObj,
     *     width: 100,
     *     height: 100
     *   });
     * };
     * imageObj.src = '/path/to/image.jpg'
     */
    Konva.Image = function(config) {
        this.___init(config);
    };

    Konva.Image.prototype = {
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = IMAGE;
            this.sceneFunc(this._sceneFunc);
            this.hitFunc(this._hitFunc);
        },
        _useBufferCanvas: function() {
            return (this.hasShadow() || this.getAbsoluteOpacity() !== 1) && this.hasStroke() && this.getStage();
        },
        _sceneFunc: function(context) {
            var width = this.getWidth(),
                height = this.getHeight(),
                image = this.getImage(),
                cropWidth, cropHeight, params;

            if (image) {
                cropWidth = this.getCropWidth();
                cropHeight = this.getCropHeight();
                if (cropWidth && cropHeight) {
                    params = [image, this.getCropX(), this.getCropY(), cropWidth, cropHeight, 0, 0, width, height];
                } else {
                    params = [image, 0, 0, width, height];
                }
            }

            if (this.hasFill() || this.hasStroke()) {
                context.beginPath();
                context.rect(0, 0, width, height);
                context.closePath();
                context.fillStrokeShape(this);
            }

            if (image) {
                context.drawImage.apply(context, params);
            }
        },
        _hitFunc: function(context) {
            var width = this.getWidth(),
                height = this.getHeight();

            context.beginPath();
            context.rect(0, 0, width, height);
            context.closePath();
            context.fillStrokeShape(this);
        },
        getWidth: function() {
            var image = this.getImage();
            return this.attrs.width || (image ? image.width : 0);
        },
        getHeight: function() {
            var image = this.getImage();
            return this.attrs.height || (image ? image.height : 0);
        }
    };
    Konva.Util.extend(Konva.Image, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Image, 'image');

    /**
     * set image
     * @name setImage
     * @method
     * @memberof Konva.Image.prototype
     * @param {Image} image
     */

    /**
     * get image
     * @name getImage
     * @method
     * @memberof Konva.Image.prototype
     * @returns {Image}
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Image, 'crop', ['x', 'y', 'width', 'height']);
    /**
     * get/set crop
     * @method
     * @name crop
     * @memberof Konva.Image.prototype
     * @param {Object} crop
     * @param {Number} crop.x
     * @param {Number} crop.y
     * @param {Number} crop.width
     * @param {Number} crop.height
     * @returns {Object}
     * @example
     * // get crop
     * var crop = image.crop();
     *
     * // set crop
     * image.crop({
     *   x: 20,
     *   y: 20,
     *   width: 20,
     *   height: 20
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Image, 'cropX', 0);
    /**
     * get/set crop x
     * @method
     * @name cropX
     * @memberof Konva.Image.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get crop x
     * var cropX = image.cropX();
     *
     * // set crop x
     * image.cropX(20);
     */

    Konva.Factory.addGetterSetter(Konva.Image, 'cropY', 0);
    /**
     * get/set crop y
     * @name cropY
     * @method
     * @memberof Konva.Image.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get crop y
     * var cropY = image.cropY();
     *
     * // set crop y
     * image.cropY(20);
     */

    Konva.Factory.addGetterSetter(Konva.Image, 'cropWidth', 0);
    /**
     * get/set crop width
     * @name cropWidth
     * @method
     * @memberof Konva.Image.prototype
     * @param {Number} width
     * @returns {Number}
     * @example
     * // get crop width
     * var cropWidth = image.cropWidth();
     *
     * // set crop width
     * image.cropWidth(20);
     */

    Konva.Factory.addGetterSetter(Konva.Image, 'cropHeight', 0);
    /**
     * get/set crop height
     * @name cropHeight
     * @method
     * @memberof Konva.Image.prototype
     * @param {Number} height
     * @returns {Number}
     * @example
     * // get crop height
     * var cropHeight = image.cropHeight();
     *
     * // set crop height
     * image.cropHeight(20);
     */

    Konva.Collection.mapMethods(Konva.Image);

    /**
     * load image from given url and create `Konva.Image` instance
     * @method
     * @memberof Konva.Image
     * @param {String} url image source
     * @param {Function} callback with Konva.Image instance as first argument
     * @example
     *  Konva.Image.fromURL(imageURL, function(image){
     *    // image is Konva.Image instance
     *    layer.add(image);
     *    layer.draw();
     *  });
     */
    Konva.Image.fromURL = function(url, callback) {
        var img = new Image();
        img.onload = function() {
          var image = new Konva.Image({
            image: img
          });
          callback(image);
        };
        img.src = url;
    };
})();

/*eslint-disable max-depth */
(function() {
    'use strict';
    // constants
    var AUTO = 'auto',
        //CANVAS = 'canvas',
        CENTER = 'center',
        CHANGE_KONVA = 'Change.konva',
        CONTEXT_2D = '2d',
        DASH = '-',
        EMPTY_STRING = '',
        LEFT = 'left',
        TEXT = 'text',
        TEXT_UPPER = 'Text',
        MIDDLE = 'middle',
        NORMAL = 'normal',
        PX_SPACE = 'px ',
        SPACE = ' ',
        RIGHT = 'right',
        WORD = 'word',
        CHAR = 'char',
        NONE = 'none',
        ATTR_CHANGE_LIST = ['fontFamily', 'fontSize', 'fontStyle', 'fontVariant', 'padding', 'align', 'lineHeight', 'text', 'width', 'height', 'wrap'],

        // cached variables
        attrChangeListLen = ATTR_CHANGE_LIST.length,
        dummyContext = Konva.Util.createCanvasElement().getContext(CONTEXT_2D);

    /**
     * Text constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {String} [config.fontFamily] default is Arial
     * @param {Number} [config.fontSize] in pixels.  Default is 12
     * @param {String} [config.fontStyle] can be normal, bold, or italic.  Default is normal
     * @param {String} [config.fontVariant] can be normal or small-caps.  Default is normal
     * @param {String} config.text
     * @param {String} [config.align] can be left, center, or right
     * @param {Number} [config.padding]
     * @param {Number} [config.width] default is auto
     * @param {Number} [config.height] default is auto
     * @param {Number} [config.lineHeight] default is 1
     * @param {String} [config.wrap] can be word, char, or none. Default is word
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var text = new Konva.Text({
     *   x: 10,
     *   y: 15,
     *   text: 'Simple Text',
     *   fontSize: 30,
     *   fontFamily: 'Calibri',
     *   fill: 'green'
     * });
     */
    Konva.Text = function(config) {
        this.___init(config);
    };
    function _fillFunc(context) {
        context.fillText(this.partialText, 0, 0);
    }
    function _strokeFunc(context) {
        context.strokeText(this.partialText, 0, 0);
    }

    Konva.Text.prototype = {
        ___init: function(config) {
            config = config || {};

            // set default color to black
            if (!config.fillLinearGradientColorStops && !config.fillRadialGradientColorStops) {
                config.fill = config.fill || 'black';
            }

            if (config.width === undefined) {
                config.width = AUTO;
            }
            if (config.height === undefined) {
                config.height = AUTO;
            }

            // call super constructor
            Konva.Shape.call(this, config);

            this._fillFunc = _fillFunc;
            this._strokeFunc = _strokeFunc;
            this.className = TEXT_UPPER;

            // update text data for certain attr changes
            for(var n = 0; n < attrChangeListLen; n++) {
                this.on(ATTR_CHANGE_LIST[n] + CHANGE_KONVA, this._setTextData);
            }

            this._setTextData();
            this.sceneFunc(this._sceneFunc);
            this.hitFunc(this._hitFunc);
        },
        _sceneFunc: function(context) {
            var p = this.getPadding(),
                textHeight = this.getTextHeight(),
                lineHeightPx = this.getLineHeight() * textHeight,
                textArr = this.textArr,
                textArrLen = textArr.length,
                totalWidth = this.getWidth(),
                n;

            context.setAttr('font', this._getContextFont());

            context.setAttr('textBaseline', MIDDLE);
            context.setAttr('textAlign', LEFT);
            context.save();
            if (p) {
                context.translate(p, 0);
                context.translate(0, p + textHeight / 2);
            } else {
                context.translate(0, textHeight / 2);
            }


            // draw text lines
            for(n = 0; n < textArrLen; n++) {
                var obj = textArr[n],
                    text = obj.text,
                    width = obj.width;

                // horizontal alignment
                context.save();
                if(this.getAlign() === RIGHT) {
                    context.translate(totalWidth - width - p * 2, 0);
                }
                else if(this.getAlign() === CENTER) {
                    context.translate((totalWidth - width - p * 2) / 2, 0);
                }

                this.partialText = text;

                context.fillStrokeShape(this);
                context.restore();
                context.translate(0, lineHeightPx);
            }
            context.restore();
        },
        _hitFunc: function(context) {
            var width = this.getWidth(),
                height = this.getHeight();

            context.beginPath();
            context.rect(0, 0, width, height);
            context.closePath();
            context.fillStrokeShape(this);
        },
        setText: function(text) {
            var str = Konva.Util._isString(text) ? text : text.toString();
            this._setAttr(TEXT, str);
            return this;
        },
        /**
         * get width of text area, which includes padding
         * @method
         * @memberof Konva.Text.prototype
         * @returns {Number}
         */
        getWidth: function() {
            return this.attrs.width === AUTO ? this.getTextWidth() + this.getPadding() * 2 : this.attrs.width;
        },
        /**
         * get the height of the text area, which takes into account multi-line text, line heights, and padding
         * @method
         * @memberof Konva.Text.prototype
         * @returns {Number}
         */
        getHeight: function() {
            return this.attrs.height === AUTO ? (this.getTextHeight() * this.textArr.length * this.getLineHeight()) + this.getPadding() * 2 : this.attrs.height;
        },
        /**
         * get text width
         * @method
         * @memberof Konva.Text.prototype
         * @returns {Number}
         */
        getTextWidth: function() {
            return this.textWidth;
        },
        /**
         * get text height
         * @method
         * @memberof Konva.Text.prototype
         * @returns {Number}
         */
        getTextHeight: function() {
            return this.textHeight;
        },
        _getTextSize: function(text) {
            var _context = dummyContext,
                fontSize = this.getFontSize(),
                metrics;

            _context.save();
            _context.font = this._getContextFont();

            metrics = _context.measureText(text);
            _context.restore();
            return {
                width: metrics.width,
                height: parseInt(fontSize, 10)
            };
        },
        _getContextFont: function() {
            return this.getFontStyle() + SPACE + this.getFontVariant() + SPACE + this.getFontSize() + PX_SPACE + this.getFontFamily();
        },
        _addTextLine: function (line, width) {
            return this.textArr.push({text: line, width: width});
        },
        _getTextWidth: function (text) {
            return dummyContext.measureText(text).width;
        },
        _setTextData: function () {
            var lines = this.getText().split('\n'),
                fontSize = +this.getFontSize(),
                textWidth = 0,
                lineHeightPx = this.getLineHeight() * fontSize,
                width = this.attrs.width,
                height = this.attrs.height,
                fixedWidth = width !== AUTO,
                fixedHeight = height !== AUTO,
                padding = this.getPadding(),
                maxWidth = width - padding * 2,
                maxHeightPx = height - padding * 2,
                currentHeightPx = 0,
                wrap = this.getWrap(),
                shouldWrap = wrap !== NONE,
                wrapAtWord = wrap !== CHAR && shouldWrap;

            this.textArr = [];
            dummyContext.save();
            dummyContext.font = this._getContextFont();
            for (var i = 0, max = lines.length; i < max; ++i) {
                var line = lines[i],
                    lineWidth = this._getTextWidth(line);
                if (fixedWidth && lineWidth > maxWidth) {
                    /*
                     * if width is fixed and line does not fit entirely
                     * break the line into multiple fitting lines
                     */
                    while (line.length > 0) {
                        /*
                         * use binary search to find the longest substring that
                         * that would fit in the specified width
                         */
                        var low = 0, high = line.length,
                            match = '', matchWidth = 0;
                        while (low < high) {
                            var mid = (low + high) >>> 1,
                                substr = line.slice(0, mid + 1),
                                substrWidth = this._getTextWidth(substr);
                            if (substrWidth <= maxWidth) {
                                low = mid + 1;
                                match = substr;
                                matchWidth = substrWidth;
                            } else {
                                high = mid;
                            }
                        }
                        /*
                         * 'low' is now the index of the substring end
                         * 'match' is the substring
                         * 'matchWidth' is the substring width in px
                         */
                        if (match) {
                            // a fitting substring was found
                            if (wrapAtWord) {
                                // try to find a space or dash where wrapping could be done
                                var wrapIndex = Math.max(match.lastIndexOf(SPACE),
                                                          match.lastIndexOf(DASH)) + 1;
                                if (wrapIndex > 0) {
                                    // re-cut the substring found at the space/dash position
                                    low = wrapIndex;
                                    match = match.slice(0, low);
                                    matchWidth = this._getTextWidth(match);
                                }
                            }
                            this._addTextLine(match, matchWidth);
                            textWidth = Math.max(textWidth, matchWidth);
                            currentHeightPx += lineHeightPx;
                            if (!shouldWrap ||
                                (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx)) {
                                /*
                                 * stop wrapping if wrapping is disabled or if adding
                                 * one more line would overflow the fixed height
                                 */
                                break;
                            }
                            line = line.slice(low);
                            if (line.length > 0) {
                                // Check if the remaining text would fit on one line
                                lineWidth = this._getTextWidth(line);
                                if (lineWidth <= maxWidth) {
                                    // if it does, add the line and break out of the loop
                                    this._addTextLine(line, lineWidth);
                                    currentHeightPx += lineHeightPx;
                                    textWidth = Math.max(textWidth, lineWidth);
                                    break;
                                }
                            }
                        } else {
                            // not even one character could fit in the element, abort
                            break;
                        }
                    }
                } else {
                    // element width is automatically adjusted to max line width
                    this._addTextLine(line, lineWidth);
                    currentHeightPx += lineHeightPx;
                    textWidth = Math.max(textWidth, lineWidth);
                }
                // if element height is fixed, abort if adding one more line would overflow
                if (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx) {
                    break;
                }
            }
            dummyContext.restore();
            this.textHeight = fontSize;
            this.textWidth = textWidth;
        }
    };
    Konva.Util.extend(Konva.Text, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Text, 'fontFamily', 'Arial');

    /**
     * get/set font family
     * @name fontFamily
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} fontFamily
     * @returns {String}
     * @example
     * // get font family
     * var fontFamily = text.fontFamily();
     *
     * // set font family
     * text.fontFamily('Arial');
     */

    Konva.Factory.addGetterSetter(Konva.Text, 'fontSize', 12);

    /**
     * get/set font size in pixels
     * @name fontSize
     * @method
     * @memberof Konva.Text.prototype
     * @param {Number} fontSize
     * @returns {Number}
     * @example
     * // get font size
     * var fontSize = text.fontSize();
     *
     * // set font size to 22px
     * text.fontSize(22);
     */

    Konva.Factory.addGetterSetter(Konva.Text, 'fontStyle', NORMAL);

    /**
     * set font style.  Can be 'normal', 'italic', or 'bold'.  'normal' is the default.
     * @name fontStyle
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} fontStyle
     * @returns {String}
     * @example
     * // get font style
     * var fontStyle = text.fontStyle();
     *
     * // set font style
     * text.fontStyle('bold');
     */

    Konva.Factory.addGetterSetter(Konva.Text, 'fontVariant', NORMAL);

    /**
     * set font variant.  Can be 'normal' or 'small-caps'.  'normal' is the default.
     * @name fontVariant
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} fontVariant
     * @returns {String}
     * @example
     * // get font variant
     * var fontVariant = text.fontVariant();
     *
     * // set font variant
     * text.fontVariant('small-caps');
     */

    Konva.Factory.addGetterSetter(Konva.Text, 'padding', 0);

    /**
     * set padding
     * @name padding
     * @method
     * @memberof Konva.Text.prototype
     * @param {Number} padding
     * @returns {Number}
     * @example
     * // get padding
     * var padding = text.padding();
     *
     * // set padding to 10 pixels
     * text.padding(10);
     */

    Konva.Factory.addGetterSetter(Konva.Text, 'align', LEFT);

    /**
     * get/set horizontal align of text.  Can be 'left', 'center', or 'right'
     * @name align
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} align
     * @returns {String}
     * @example
     * // get text align
     * var align = text.align();
     *
     * // center text
     * text.align('center');
     *
     * // align text to right
     * text.align('right');
     */

    Konva.Factory.addGetterSetter(Konva.Text, 'lineHeight', 1);

    /**
     * get/set line height.  The default is 1.
     * @name lineHeight
     * @method
     * @memberof Konva.Text.prototype
     * @param {Number} lineHeight
     * @returns {Number}
     * @example
     * // get line height
     * var lineHeight = text.lineHeight();
     *
     * // set the line height
     * text.lineHeight(2);
     */

    Konva.Factory.addGetterSetter(Konva.Text, 'wrap', WORD);

    /**
     * get/set wrap.  Can be word, char, or none. Default is word.
     * @name wrap
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} wrap
     * @returns {String}
     * @example
     * // get wrap
     * var wrap = text.wrap();
     *
     * // set wrap
     * text.wrap('word');
     */

    Konva.Factory.addGetter(Konva.Text, 'text', EMPTY_STRING);
    Konva.Factory.addOverloadedGetterSetter(Konva.Text, 'text');

    /**
     * get/set text
     * @name getText
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} text
     * @returns {String}
     * @example
     * // get text
     * var text = text.text();
     *
     * // set text
     * text.text('Hello world!');
     */

    Konva.Collection.mapMethods(Konva.Text);
})();

(function () {
    'use strict';
    /**
     * Line constructor.&nbsp; Lines are defined by an array of points and
     *  a tension
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Array} config.points
     * @param {Number} [config.tension] Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
     *   The default is 0
     * @param {Boolean} [config.closed] defines whether or not the line shape is closed, creating a polygon or blob
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var line = new Konva.Line({
     *   x: 100,
     *   y: 50,
     *   points: [73, 70, 340, 23, 450, 60, 500, 20],
     *   stroke: 'red',
     *   tension: 1
     * });
     */
    Konva.Line = function (config) {
        this.___init(config);
    };

    Konva.Line.prototype = {
        ___init: function (config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'Line';

            this.on('pointsChange.konva tensionChange.konva closedChange.konva', function () {
                this._clearCache('tensionPoints');
            });

            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function (context) {
            var points = this.getPoints(),
                length = points.length,
                tension = this.getTension(),
                closed = this.getClosed(),
                tp, len, n;

            if (!length) {
                return;
            }

            context.beginPath();
            context.moveTo(points[0], points[1]);

            // tension
            if (tension !== 0 && length > 4) {
                tp = this.getTensionPoints();
                len = tp.length;
                n = closed ? 0 : 4;

                if (!closed) {
                    context.quadraticCurveTo(tp[0], tp[1], tp[2], tp[3]);
                }

                while (n < len - 2) {
                    context.bezierCurveTo(tp[n++], tp[n++], tp[n++], tp[n++], tp[n++], tp[n++]);
                }

                if (!closed) {
                    context.quadraticCurveTo(tp[len - 2], tp[len - 1], points[length - 2], points[length - 1]);
                }
            }
            // no tension
            else {
                for (n = 2; n < length; n += 2) {
                    context.lineTo(points[n], points[n + 1]);
                }
            }

            // closed e.g. polygons and blobs
            if (closed) {
                context.closePath();
                context.fillStrokeShape(this);
            }
            // open e.g. lines and splines
            else {
                context.strokeShape(this);
            }
        },
        getTensionPoints: function () {
            return this._getCache('tensionPoints', this._getTensionPoints);
        },
        _getTensionPoints: function () {
            if (this.getClosed()) {
                return this._getTensionPointsClosed();
            } else {
                return Konva.Util._expandPoints(this.getPoints(), this.getTension());
            }
        },
        _getTensionPointsClosed: function () {
            var p = this.getPoints(),
                len = p.length,
                tension = this.getTension(),
                util = Konva.Util,
                firstControlPoints = util._getControlPoints(
                    p[len - 2],
                    p[len - 1],
                    p[0],
                    p[1],
                    p[2],
                    p[3],
                    tension
                ),
                lastControlPoints = util._getControlPoints(
                    p[len - 4],
                    p[len - 3],
                    p[len - 2],
                    p[len - 1],
                    p[0],
                    p[1],
                    tension
                ),
                middle = Konva.Util._expandPoints(p, tension),
                tp = [
                    firstControlPoints[2],
                    firstControlPoints[3]
                ]
                .concat(middle)
                .concat([
                    lastControlPoints[0],
                    lastControlPoints[1],
                    p[len - 2],
                    p[len - 1],
                    lastControlPoints[2],
                    lastControlPoints[3],
                    firstControlPoints[0],
                    firstControlPoints[1],
                    p[0],
                    p[1]
                ]);

            return tp;
        },
        getWidth: function () {
            return this.getSelfRect().width;
        },
        getHeight: function () {
            return this.getSelfRect().height;
        },
        // overload size detection
        getSelfRect: function () {
            var points;
            if (this.getTension() !== 0) {
                points = this._getTensionPoints();
            } else {
                points = this.getPoints();
            }
            var minX = points[0];
            var maxX = points[0];
            var minY = points[1];
            var maxY = points[1];
            var x, y;
            for (var i = 0; i < points.length / 2; i++) {
                x = points[i * 2];
                y = points[i * 2 + 1];
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }
            return {
                x: Math.round(minX),
                y: Math.round(minY),
                width: Math.round(maxX - minX),
                height: Math.round(maxY - minY)
            };
        }
    };
    Konva.Util.extend(Konva.Line, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Line, 'closed', false);

    /**
     * get/set closed flag.  The default is false
     * @name closed
     * @method
     * @memberof Konva.Line.prototype
     * @param {Boolean} closed
     * @returns {Boolean}
     * @example
     * // get closed flag
     * var closed = line.closed();
     *
     * // close the shape
     * line.closed(true);
     *
     * // open the shape
     * line.closed(false);
     */

    Konva.Factory.addGetterSetter(Konva.Line, 'tension', 0);

    /**
     * get/set tension
     * @name tension
     * @method
     * @memberof Konva.Line.prototype
     * @param {Number} Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
     *   The default is 0
     * @returns {Number}
     * @example
     * // get tension
     * var tension = line.tension();
     *
     * // set tension
     * line.tension(3);
     */

    Konva.Factory.addGetterSetter(Konva.Line, 'points', []);
    /**
     * get/set points array
     * @name points
     * @method
     * @memberof Konva.Line.prototype
     * @param {Array} points
     * @returns {Array}
     * @example
     * // get points
     * var points = line.points();
     *
     * // set points
     * line.points([10, 20, 30, 40, 50, 60]);
     *
     * // push a new point
     * line.points(line.points().concat([70, 80]));
     */

    Konva.Collection.mapMethods(Konva.Line);
})();

(function() {
    'use strict';
    /**
     * Sprite constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {String} config.animation animation key
     * @param {Object} config.animations animation map
     * @param {Integer} [config.frameIndex] animation frame index
     * @param {Image} config.image image object
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var imageObj = new Image();
     * imageObj.onload = function() {
     *   var sprite = new Konva.Sprite({
     *     x: 200,
     *     y: 100,
     *     image: imageObj,
     *     animation: 'standing',
     *     animations: {
     *       standing: [
     *         // x, y, width, height (6 frames)
     *         0, 0, 49, 109,
     *         52, 0, 49, 109,
     *         105, 0, 49, 109,
     *         158, 0, 49, 109,
     *         210, 0, 49, 109,
     *         262, 0, 49, 109
     *       ],
     *       kicking: [
     *         // x, y, width, height (6 frames)
     *         0, 109, 45, 98,
     *         45, 109, 45, 98,
     *         95, 109, 63, 98,
     *         156, 109, 70, 98,
     *         229, 109, 60, 98,
     *         287, 109, 41, 98
     *       ]
     *     },
     *     frameRate: 7,
     *     frameIndex: 0
     *   });
     * };
     * imageObj.src = '/path/to/image.jpg'
     */
    Konva.Sprite = function(config) {
        this.___init(config);
    };

    Konva.Sprite.prototype = {
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'Sprite';

            this._updated = true;
            var that = this;
            this.anim = new Konva.Animation(function() {
                // if we don't need to redraw layer we should return false
                var updated = that._updated;
                that._updated = false;
                return updated;
            });
            this.on('animationChange.konva', function() {
                // reset index when animation changes
                this.frameIndex(0);
            });
            this.on('frameIndexChange.konva', function() {
                this._updated = true;
            });
            // smooth change for frameRate
            this.on('frameRateChange.konva', function() {
                if (!this.anim.isRunning()) {
                    return;
                }
                clearInterval(this.interval);
                this._setInterval();
            });

            this.sceneFunc(this._sceneFunc);
            this.hitFunc(this._hitFunc);
        },
        _sceneFunc: function(context) {
            var anim = this.getAnimation(),
                index = this.frameIndex(),
                ix4 = index * 4,
                set = this.getAnimations()[anim],
                offsets = this.frameOffsets(),
                x = set[ix4 + 0],
                y = set[ix4 + 1],
                width = set[ix4 + 2],
                height = set[ix4 + 3],
                image = this.getImage();

            if (this.hasFill() || this.hasStroke()) {
                context.beginPath();
                context.rect(0, 0, width, height);
                context.closePath();
                context.fillStrokeShape(this);
            }

            if(image) {
                if (offsets) {
                    var offset = offsets[anim],
                    ix2 = index * 2;
                    context.drawImage(image, x, y, width, height, offset[ix2 + 0], offset[ix2 + 1], width, height);
                } else {
                    context.drawImage(image, x, y, width, height, 0, 0, width, height);
                }
            }
        },
        _hitFunc: function(context) {
            var anim = this.getAnimation(),
                index = this.frameIndex(),
                ix4 = index * 4,
                set = this.getAnimations()[anim],
                offsets = this.frameOffsets(),
                width = set[ix4 + 2],
                height = set[ix4 + 3];

            context.beginPath();
            if (offsets) {
                var offset = offsets[anim];
                var ix2 = index * 2;
                context.rect(offset[ix2 + 0], offset[ix2 + 1], width, height);
            } else {
                context.rect(0, 0, width, height);
            }
            context.closePath();
            context.fillShape(this);
        },
        _useBufferCanvas: function() {
            return (this.hasShadow() || this.getAbsoluteOpacity() !== 1) && this.hasStroke();
        },
        _setInterval: function() {
            var that = this;
            this.interval = setInterval(function() {
                that._updateIndex();
            }, 1000 / this.getFrameRate());
        },
        /**
         * start sprite animation
         * @method
         * @memberof Konva.Sprite.prototype
         */
        start: function() {
            var layer = this.getLayer();

            /*
             * animation object has no executable function because
             *  the updates are done with a fixed FPS with the setInterval
             *  below.  The anim object only needs the layer reference for
             *  redraw
             */
            this.anim.setLayers(layer);
            this._setInterval();
            this.anim.start();
        },
        /**
         * stop sprite animation
         * @method
         * @memberof Konva.Sprite.prototype
         */
        stop: function() {
            this.anim.stop();
            clearInterval(this.interval);
        },
        /**
         * determine if animation of sprite is running or not.  returns true or false
         * @method
         * @memberof Konva.Animation.prototype
         * @returns {Boolean}
         */
        isRunning: function() {
            return this.anim.isRunning();
        },
        _updateIndex: function() {
            var index = this.frameIndex(),
                animation = this.getAnimation(),
                animations = this.getAnimations(),
                anim = animations[animation],
                len = anim.length / 4;

            if(index < len - 1) {
                this.frameIndex(index + 1);
            }
            else {
                this.frameIndex(0);
            }
        }
    };
    Konva.Util.extend(Konva.Sprite, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Sprite, 'animation');

    /**
     * get/set animation key
     * @name animation
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {String} anim animation key
     * @returns {String}
     * @example
     * // get animation key
     * var animation = sprite.animation();
     *
     * // set animation key
     * sprite.animation('kicking');
     */

    Konva.Factory.addGetterSetter(Konva.Sprite, 'animations');

    /**
     * get/set animations map
     * @name animations
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {Object} animations
     * @returns {Object}
     * @example
     * // get animations map
     * var animations = sprite.animations();
     *
     * // set animations map
     * sprite.animations({
     *   standing: [
     *     // x, y, width, height (6 frames)
     *     0, 0, 49, 109,
     *     52, 0, 49, 109,
     *     105, 0, 49, 109,
     *     158, 0, 49, 109,
     *     210, 0, 49, 109,
     *     262, 0, 49, 109
     *   ],
     *   kicking: [
     *     // x, y, width, height (6 frames)
     *     0, 109, 45, 98,
     *     45, 109, 45, 98,
     *     95, 109, 63, 98,
     *     156, 109, 70, 98,
     *     229, 109, 60, 98,
     *     287, 109, 41, 98
     *   ]
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Sprite, 'frameOffsets');

    /**
    * get/set offsets map
    * @name offsets
    * @method
    * @memberof Konva.Sprite.prototype
    * @param {Object} offsets
    * @returns {Object}
    * @example
    * // get offsets map
    * var offsets = sprite.offsets();
    *
    * // set offsets map
    * sprite.offsets({
    *   standing: [
    *     // x, y (6 frames)
    *     0, 0,
    *     0, 0,
    *     5, 0,
    *     0, 0,
    *     0, 3,
    *     2, 0
    *   ],
    *   kicking: [
    *     // x, y (6 frames)
    *     0, 5,
    *     5, 0,
    *     10, 0,
    *     0, 0,
    *     2, 1,
    *     0, 0
    *   ]
    * });
    */

    Konva.Factory.addGetterSetter(Konva.Sprite, 'image');

    /**
     * get/set image
     * @name image
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {Image} image
     * @returns {Image}
     * @example
     * // get image
     * var image = sprite.image();
     *
     * // set image
     * sprite.image(imageObj);
     */

    Konva.Factory.addGetterSetter(Konva.Sprite, 'frameIndex', 0);

    /**
     * set/set animation frame index
     * @name frameIndex
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {Integer} frameIndex
     * @returns {Integer}
     * @example
     * // get animation frame index
     * var frameIndex = sprite.frameIndex();
     *
     * // set animation frame index
     * sprite.frameIndex(3);
     */

    Konva.Factory.addGetterSetter(Konva.Sprite, 'frameRate', 17);

    /**
     * get/set frame rate in frames per second.  Increase this number to make the sprite
     *  animation run faster, and decrease the number to make the sprite animation run slower
     *  The default is 17 frames per second
     * @name frameRate
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {Integer} frameRate
     * @returns {Integer}
     * @example
     * // get frame rate
     * var frameRate = sprite.frameRate();
     *
     * // set frame rate to 2 frames per second
     * sprite.frameRate(2);
     */

    Konva.Factory.backCompat(Konva.Sprite, {
        index: 'frameIndex',
        getIndex: 'getFrameIndex',
        setIndex: 'setFrameIndex'
    });

    Konva.Collection.mapMethods(Konva.Sprite);
})();

/*eslint-disable  no-shadow, max-len, max-depth */
(function () {
    'use strict';
    /**
     * Path constructor.
     * @author Jason Follas
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {String} config.data SVG data string
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var path = new Konva.Path({
     *   x: 240,
     *   y: 40,
     *   data: 'M12.582,9.551C3.251,16.237,0.921,29.021,7.08,38.564l-2.36,1.689l4.893,2.262l4.893,2.262l-0.568-5.36l-0.567-5.359l-2.365,1.694c-4.657-7.375-2.83-17.185,4.352-22.33c7.451-5.338,17.817-3.625,23.156,3.824c5.337,7.449,3.625,17.813-3.821,23.152l2.857,3.988c9.617-6.893,11.827-20.277,4.935-29.896C35.591,4.87,22.204,2.658,12.582,9.551z',
     *   fill: 'green',
     *   scale: 2
     * });
     */
    Konva.Path = function (config) {
        this.___init(config);
    };

    Konva.Path.prototype = {
        ___init: function (config) {
            this.dataArray = [];
            var that = this;

            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'Path';

            this.dataArray = Konva.Path.parsePathData(this.getData());
            this.on('dataChange.konva', function () {
                that.dataArray = Konva.Path.parsePathData(this.getData());
            });

            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            var ca = this.dataArray,
                closedPath = false;

            // context position
            context.beginPath();
            for (var n = 0; n < ca.length; n++) {
                var c = ca[n].command;
                var p = ca[n].points;
                switch (c) {
                    case 'L':
                        context.lineTo(p[0], p[1]);
                        break;
                    case 'M':
                        context.moveTo(p[0], p[1]);
                        break;
                    case 'C':
                        context.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
                        break;
                    case 'Q':
                        context.quadraticCurveTo(p[0], p[1], p[2], p[3]);
                        break;
                    case 'A':
                        var cx = p[0], cy = p[1], rx = p[2], ry = p[3], theta = p[4], dTheta = p[5], psi = p[6], fs = p[7];

                        var r = (rx > ry) ? rx : ry;
                        var scaleX = (rx > ry) ? 1 : rx / ry;
                        var scaleY = (rx > ry) ? ry / rx : 1;

                        context.translate(cx, cy);
                        context.rotate(psi);
                        context.scale(scaleX, scaleY);
                        context.arc(0, 0, r, theta, theta + dTheta, 1 - fs);
                        context.scale(1 / scaleX, 1 / scaleY);
                        context.rotate(-psi);
                        context.translate(-cx, -cy);

                        break;
                    case 'z':
                        context.closePath();
                        closedPath = true;
                        break;
                }
            }

            if (closedPath) {
                context.fillStrokeShape(this);
            }
            else {
                context.strokeShape(this);
            }
        },
        getSelfRect: function() {
            var points = [];
            this.dataArray.forEach(function(data) {
                points = points.concat(data.points);
            });
            var minX = points[0];
            var maxX = points[0];
            var minY = points[0];
            var maxY = points[0];
            var x, y;
            for (var i = 0; i < points.length / 2; i++) {
                x = points[i * 2]; y = points[i * 2 + 1];
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }
            return {
                x: Math.round(minX),
                y: Math.round(minY),
                width: Math.round(maxX - minX),
                height: Math.round(maxY - minY)
            };
        }
    };
    Konva.Util.extend(Konva.Path, Konva.Shape);

    Konva.Path.getLineLength = function(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    };
    Konva.Path.getPointOnLine = function(dist, P1x, P1y, P2x, P2y, fromX, fromY) {
        if(fromX === undefined) {
            fromX = P1x;
        }
        if(fromY === undefined) {
            fromY = P1y;
        }

        var m = (P2y - P1y) / ((P2x - P1x) + 0.00000001);
        var run = Math.sqrt(dist * dist / (1 + m * m));
        if(P2x < P1x) {
            run *= -1;
        }
        var rise = m * run;
        var pt;

        if (P2x === P1x) { // vertical line
            pt = {
                x: fromX,
                y: fromY + rise
            };
        } else if((fromY - P1y) / ((fromX - P1x) + 0.00000001) === m) {
            pt = {
                x: fromX + run,
                y: fromY + rise
            };
        }
        else {
            var ix, iy;

            var len = this.getLineLength(P1x, P1y, P2x, P2y);
            if(len < 0.00000001) {
                return undefined;
            }
            var u = (((fromX - P1x) * (P2x - P1x)) + ((fromY - P1y) * (P2y - P1y)));
            u = u / (len * len);
            ix = P1x + u * (P2x - P1x);
            iy = P1y + u * (P2y - P1y);

            var pRise = this.getLineLength(fromX, fromY, ix, iy);
            var pRun = Math.sqrt(dist * dist - pRise * pRise);
            run = Math.sqrt(pRun * pRun / (1 + m * m));
            if(P2x < P1x) {
                run *= -1;
            }
            rise = m * run;
            pt = {
                x: ix + run,
                y: iy + rise
            };
        }

        return pt;
    };

    Konva.Path.getPointOnCubicBezier = function(pct, P1x, P1y, P2x, P2y, P3x, P3y, P4x, P4y) {
        function CB1(t) {
            return t * t * t;
        }
        function CB2(t) {
            return 3 * t * t * (1 - t);
        }
        function CB3(t) {
            return 3 * t * (1 - t) * (1 - t);
        }
        function CB4(t) {
            return (1 - t) * (1 - t) * (1 - t);
        }
        var x = P4x * CB1(pct) + P3x * CB2(pct) + P2x * CB3(pct) + P1x * CB4(pct);
        var y = P4y * CB1(pct) + P3y * CB2(pct) + P2y * CB3(pct) + P1y * CB4(pct);

        return {
            x: x,
            y: y
        };
    };
    Konva.Path.getPointOnQuadraticBezier = function(pct, P1x, P1y, P2x, P2y, P3x, P3y) {
        function QB1(t) {
            return t * t;
        }
        function QB2(t) {
            return 2 * t * (1 - t);
        }
        function QB3(t) {
            return (1 - t) * (1 - t);
        }
        var x = P3x * QB1(pct) + P2x * QB2(pct) + P1x * QB3(pct);
        var y = P3y * QB1(pct) + P2y * QB2(pct) + P1y * QB3(pct);

        return {
            x: x,
            y: y
        };
    };
    Konva.Path.getPointOnEllipticalArc = function(cx, cy, rx, ry, theta, psi) {
        var cosPsi = Math.cos(psi), sinPsi = Math.sin(psi);
        var pt = {
            x: rx * Math.cos(theta),
            y: ry * Math.sin(theta)
        };
        return {
            x: cx + (pt.x * cosPsi - pt.y * sinPsi),
            y: cy + (pt.x * sinPsi + pt.y * cosPsi)
        };
    };
    /*
     * get parsed data array from the data
     *  string.  V, v, H, h, and l data are converted to
     *  L data for the purpose of high performance Path
     *  rendering
     */
    Konva.Path.parsePathData = function(data) {
        // Path Data Segment must begin with a moveTo
        //m (x y)+  Relative moveTo (subsequent points are treated as lineTo)
        //M (x y)+  Absolute moveTo (subsequent points are treated as lineTo)
        //l (x y)+  Relative lineTo
        //L (x y)+  Absolute LineTo
        //h (x)+    Relative horizontal lineTo
        //H (x)+    Absolute horizontal lineTo
        //v (y)+    Relative vertical lineTo
        //V (y)+    Absolute vertical lineTo
        //z (closepath)
        //Z (closepath)
        //c (x1 y1 x2 y2 x y)+ Relative Bezier curve
        //C (x1 y1 x2 y2 x y)+ Absolute Bezier curve
        //q (x1 y1 x y)+       Relative Quadratic Bezier
        //Q (x1 y1 x y)+       Absolute Quadratic Bezier
        //t (x y)+    Shorthand/Smooth Relative Quadratic Bezier
        //T (x y)+    Shorthand/Smooth Absolute Quadratic Bezier
        //s (x2 y2 x y)+       Shorthand/Smooth Relative Bezier curve
        //S (x2 y2 x y)+       Shorthand/Smooth Absolute Bezier curve
        //a (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+     Relative Elliptical Arc
        //A (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+  Absolute Elliptical Arc

        // return early if data is not defined
        if(!data) {
            return [];
        }

        // command string
        var cs = data;

        // command chars
        var cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];
        // convert white spaces to commas
        cs = cs.replace(new RegExp(' ', 'g'), ',');
        // create pipes so that we can split the data
        for(var n = 0; n < cc.length; n++) {
            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
        }
        // create array
        var arr = cs.split('|');
        var ca = [];
        // init context point
        var cpx = 0;
        var cpy = 0;
        for( n = 1; n < arr.length; n++) {
            var str = arr[n];
            var c = str.charAt(0);
            str = str.slice(1);
            // remove ,- for consistency
            str = str.replace(new RegExp(',-', 'g'), '-');
            // add commas so that it's easy to split
            str = str.replace(new RegExp('-', 'g'), ',-');
            str = str.replace(new RegExp('e,-', 'g'), 'e-');
            var p = str.split(',');
            if(p.length > 0 && p[0] === '') {
                p.shift();
            }
            // convert strings to floats
            for(var i = 0; i < p.length; i++) {
                p[i] = parseFloat(p[i]);
            }
            while(p.length > 0) {
                if(isNaN(p[0])) {// case for a trailing comma before next command
                    break;
                }

                var cmd = null;
                var points = [];
                var startX = cpx, startY = cpy;
                // Move var from within the switch to up here (jshint)
                var prevCmd, ctlPtx, ctlPty;     // Ss, Tt
                var rx, ry, psi, fa, fs, x1, y1; // Aa


                // convert l, H, h, V, and v to L
                switch (c) {

                    // Note: Keep the lineTo's above the moveTo's in this switch
                    case 'l':
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'L':
                        cpx = p.shift();
                        cpy = p.shift();
                        points.push(cpx, cpy);
                        break;

                    // Note: lineTo handlers need to be above this point
                    case 'm':
                        var dx = p.shift();
                        var dy = p.shift();
                        cpx += dx;
                        cpy += dy;
                        cmd = 'M';
                        // After closing the path move the current position
                        // to the the first point of the path (if any).
                        if(ca.length > 2 && ca[ca.length - 1].command === 'z'){
                            for(var idx = ca.length - 2; idx >= 0; idx--){
                                if(ca[idx].command === 'M'){
                                    cpx = ca[idx].points[0] + dx;
                                    cpy = ca[idx].points[1] + dy;
                                    break;
                                }
                            }
                        }
                        points.push(cpx, cpy);
                        c = 'l';
                        // subsequent points are treated as relative lineTo
                        break;
                    case 'M':
                        cpx = p.shift();
                        cpy = p.shift();
                        cmd = 'M';
                        points.push(cpx, cpy);
                        c = 'L';
                        // subsequent points are treated as absolute lineTo
                        break;

                    case 'h':
                        cpx += p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'H':
                        cpx = p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'v':
                        cpy += p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'V':
                        cpy = p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'C':
                        points.push(p.shift(), p.shift(), p.shift(), p.shift());
                        cpx = p.shift();
                        cpy = p.shift();
                        points.push(cpx, cpy);
                        break;
                    case 'c':
                        points.push(cpx + p.shift(), cpy + p.shift(), cpx + p.shift(), cpy + p.shift());
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'C';
                        points.push(cpx, cpy);
                        break;
                    case 'S':
                        ctlPtx = cpx;
                        ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if(prevCmd.command === 'C') {
                            ctlPtx = cpx + (cpx - prevCmd.points[2]);
                            ctlPty = cpy + (cpy - prevCmd.points[3]);
                        }
                        points.push(ctlPtx, ctlPty, p.shift(), p.shift());
                        cpx = p.shift();
                        cpy = p.shift();
                        cmd = 'C';
                        points.push(cpx, cpy);
                        break;
                    case 's':
                        ctlPtx = cpx;
                        ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if(prevCmd.command === 'C') {
                            ctlPtx = cpx + (cpx - prevCmd.points[2]);
                            ctlPty = cpy + (cpy - prevCmd.points[3]);
                        }
                        points.push(ctlPtx, ctlPty, cpx + p.shift(), cpy + p.shift());
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'C';
                        points.push(cpx, cpy);
                        break;
                    case 'Q':
                        points.push(p.shift(), p.shift());
                        cpx = p.shift();
                        cpy = p.shift();
                        points.push(cpx, cpy);
                        break;
                    case 'q':
                        points.push(cpx + p.shift(), cpy + p.shift());
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'Q';
                        points.push(cpx, cpy);
                        break;
                    case 'T':
                        ctlPtx = cpx;
                        ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if(prevCmd.command === 'Q') {
                            ctlPtx = cpx + (cpx - prevCmd.points[0]);
                            ctlPty = cpy + (cpy - prevCmd.points[1]);
                        }
                        cpx = p.shift();
                        cpy = p.shift();
                        cmd = 'Q';
                        points.push(ctlPtx, ctlPty, cpx, cpy);
                        break;
                    case 't':
                        ctlPtx = cpx;
                        ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if(prevCmd.command === 'Q') {
                            ctlPtx = cpx + (cpx - prevCmd.points[0]);
                            ctlPty = cpy + (cpy - prevCmd.points[1]);
                        }
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'Q';
                        points.push(ctlPtx, ctlPty, cpx, cpy);
                        break;
                    case 'A':
                        rx = p.shift();
                        ry = p.shift();
                        psi = p.shift();
                        fa = p.shift();
                        fs = p.shift();
                        x1 = cpx;
                        y1 = cpy;
                        cpx = p.shift();
                        cpy = p.shift();
                        cmd = 'A';
                        points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
                        break;
                    case 'a':
                        rx = p.shift();
                        ry = p.shift();
                        psi = p.shift();
                        fa = p.shift();
                        fs = p.shift();
                        x1 = cpx;
                        y1 = cpy; cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'A';
                        points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
                        break;
                }

                ca.push({
                    command: cmd || c,
                    points: points,
                    start: {
                        x: startX,
                        y: startY
                    },
                    pathLength: this.calcLength(startX, startY, cmd || c, points)
                });
            }

            if(c === 'z' || c === 'Z') {
                ca.push({
                    command: 'z',
                    points: [],
                    start: undefined,
                    pathLength: 0
                });
            }
        }

        return ca;
    };
    Konva.Path.calcLength = function(x, y, cmd, points) {
        var len, p1, p2, t;
        var path = Konva.Path;

        switch (cmd) {
            case 'L':
                return path.getLineLength(x, y, points[0], points[1]);
            case 'C':
                // Approximates by breaking curve into 100 line segments
                len = 0.0;
                p1 = path.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
                for( t = 0.01; t <= 1; t += 0.01) {
                    p2 = path.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
                    len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                    p1 = p2;
                }
                return len;
            case 'Q':
                // Approximates by breaking curve into 100 line segments
                len = 0.0;
                p1 = path.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);
                for( t = 0.01; t <= 1; t += 0.01) {
                    p2 = path.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);
                    len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                    p1 = p2;
                }
                return len;
            case 'A':
                // Approximates by breaking curve into line segments
                len = 0.0;
                var start = points[4];
                // 4 = theta
                var dTheta = points[5];
                // 5 = dTheta
                var end = points[4] + dTheta;
                var inc = Math.PI / 180.0;
                // 1 degree resolution
                if(Math.abs(start - end) < inc) {
                    inc = Math.abs(start - end);
                }
                // Note: for purpose of calculating arc length, not going to worry about rotating X-axis by angle psi
                p1 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);
                if(dTheta < 0) {// clockwise
                    for( t = start - inc; t > end; t -= inc) {
                        p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                        p1 = p2;
                    }
                }
                else {// counter-clockwise
                    for( t = start + inc; t < end; t += inc) {
                        p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                        p1 = p2;
                    }
                }
                p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
                len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);

                return len;
        }

        return 0;
    };
    Konva.Path.convertEndpointToCenterParameterization = function(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg) {
        // Derived from: http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
        var psi = psiDeg * (Math.PI / 180.0);
        var xp = Math.cos(psi) * (x1 - x2) / 2.0 + Math.sin(psi) * (y1 - y2) / 2.0;
        var yp = -1 * Math.sin(psi) * (x1 - x2) / 2.0 + Math.cos(psi) * (y1 - y2) / 2.0;

        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);

        if(lambda > 1) {
            rx *= Math.sqrt(lambda);
            ry *= Math.sqrt(lambda);
        }

        var f = Math.sqrt((((rx * rx) * (ry * ry)) - ((rx * rx) * (yp * yp)) - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp) + (ry * ry) * (xp * xp)));

        if(fa === fs) {
            f *= -1;
        }
        if(isNaN(f)) {
            f = 0;
        }

        var cxp = f * rx * yp / ry;
        var cyp = f * -ry * xp / rx;

        var cx = (x1 + x2) / 2.0 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;
        var cy = (y1 + y2) / 2.0 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;

        var vMag = function(v) {
            return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
        };
        var vRatio = function(u, v) {
            return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
        };
        var vAngle = function(u, v) {
            return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
        };
        var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
        var u = [(xp - cxp) / rx, (yp - cyp) / ry];
        var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
        var dTheta = vAngle(u, v);

        if(vRatio(u, v) <= -1) {
            dTheta = Math.PI;
        }
        if(vRatio(u, v) >= 1) {
            dTheta = 0;
        }
        if(fs === 0 && dTheta > 0) {
            dTheta = dTheta - 2 * Math.PI;
        }
        if(fs === 1 && dTheta < 0) {
            dTheta = dTheta + 2 * Math.PI;
        }
        return [cx, cy, rx, ry, theta, dTheta, psi, fs];
    };
    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Path, 'data');

    /**
     * set SVG path data string.  This method
     *  also automatically parses the data string
     *  into a data array.  Currently supported SVG data:
     *  M, m, L, l, H, h, V, v, Q, q, T, t, C, c, S, s, A, a, Z, z
     * @name setData
     * @method
     * @memberof Konva.Path.prototype
     * @param {String} SVG path command string
     */

    /**
     * get SVG path data string
     * @name getData
     * @method
     * @memberof Konva.Path.prototype
     */

    Konva.Collection.mapMethods(Konva.Path);
})();

(function() {
    'use strict';
    var EMPTY_STRING = '',
        //CALIBRI = 'Calibri',
        NORMAL = 'normal';

    /**
     * Path constructor.
     * @author Jason Follas
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {String} [config.fontFamily] default is Calibri
     * @param {Number} [config.fontSize] default is 12
     * @param {String} [config.fontStyle] can be normal, bold, or italic.  Default is normal
     * @param {String} [config.fontVariant] can be normal or small-caps.  Default is normal
     * @param {String} config.text
     * @param {String} config.data SVG data string
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var textpath = new Konva.TextPath({
     *   x: 100,
     *   y: 50,
     *   fill: '#333',
     *   fontSize: '24',
     *   fontFamily: 'Arial',
     *   text: 'All the world\'s a stage, and all the men and women merely players.',
     *   data: 'M10,10 C0,0 10,150 100,100 S300,150 400,50'
     * });
     */
    Konva.TextPath = function(config) {
        this.___init(config);
    };

    function _fillFunc(context) {
        context.fillText(this.partialText, 0, 0);
    }
    function _strokeFunc(context) {
        context.strokeText(this.partialText, 0, 0);
    }

    Konva.TextPath.prototype = {
        ___init: function(config) {
            var that = this;
            this.dummyCanvas = Konva.Util.createCanvasElement();
            this.dataArray = [];

            // call super constructor
            Konva.Shape.call(this, config);

            // overrides
            // TODO: shouldn't this be on the prototype?
            this._fillFunc = _fillFunc;
            this._strokeFunc = _strokeFunc;
            this._fillFuncHit = _fillFunc;
            this._strokeFuncHit = _strokeFunc;

            this.className = 'TextPath';

            this.dataArray = Konva.Path.parsePathData(this.attrs.data);
            this.on('dataChange.konva', function() {
                that.dataArray = Konva.Path.parsePathData(this.attrs.data);
            });

            // update text data for certain attr changes
            this.on('textChange.konva textStroke.konva textStrokeWidth.konva', that._setTextData);
            that._setTextData();
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            context.setAttr('font', this._getContextFont());
            context.setAttr('textBaseline', 'middle');
            context.setAttr('textAlign', 'left');
            context.save();

            var glyphInfo = this.glyphInfo;
            for(var i = 0; i < glyphInfo.length; i++) {
                context.save();

                var p0 = glyphInfo[i].p0;

                context.translate(p0.x, p0.y);
                context.rotate(glyphInfo[i].rotation);
                this.partialText = glyphInfo[i].text;

                context.fillStrokeShape(this);
                context.restore();

                //// To assist with debugging visually, uncomment following
                // context.beginPath();
                // if (i % 2)
                // context.strokeStyle = 'cyan';
                // else
                // context.strokeStyle = 'green';
                // var p1 = glyphInfo[i].p1;
                // context.moveTo(p0.x, p0.y);
                // context.lineTo(p1.x, p1.y);
                // context.stroke();
            }
            context.restore();
        },
        /**
         * get text width in pixels
         * @method
         * @memberof Konva.TextPath.prototype
         */
        getTextWidth: function() {
            return this.textWidth;
        },
        /**
         * get text height in pixels
         * @method
         * @memberof Konva.TextPath.prototype
         */
        getTextHeight: function() {
            return this.textHeight;
        },
        /**
         * set text
         * @method
         * @memberof Konva.TextPath.prototype
         * @param {String} text
         */
        setText: function(text) {
            Konva.Text.prototype.setText.call(this, text);
        },
        _getTextSize: function(text) {
            var dummyCanvas = this.dummyCanvas;
            var _context = dummyCanvas.getContext('2d');

            _context.save();

            _context.font = this._getContextFont();
            var metrics = _context.measureText(text);

            _context.restore();

            return {
                width: metrics.width,
                height: parseInt(this.attrs.fontSize, 10)
            };
        },
        _setTextData: function() {

            var that = this;
            var size = this._getTextSize(this.attrs.text);
            this.textWidth = size.width;
            this.textHeight = size.height;

            this.glyphInfo = [];

            var charArr = this.attrs.text.split('');

            var p0, p1, pathCmd;

            var pIndex = -1;
            var currentT = 0;

            var getNextPathSegment = function() {
                currentT = 0;
                var pathData = that.dataArray;

                for(var j = pIndex + 1; j < pathData.length; j++) {
                    if(pathData[j].pathLength > 0) {
                        pIndex = j;

                        return pathData[j];
                    }
                    else if(pathData[j].command === 'M') {
                        p0 = {
                            x: pathData[j].points[0],
                            y: pathData[j].points[1]
                        };
                    }
                }

                return {};
            };
            var findSegmentToFitCharacter = function(c) {

                var glyphWidth = that._getTextSize(c).width;

                var currLen = 0;
                var attempts = 0;

                p1 = undefined;
                while(Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 && attempts < 25) {
                    attempts++;
                    var cumulativePathLength = currLen;
                    while(pathCmd === undefined) {
                        pathCmd = getNextPathSegment();

                        if(pathCmd && cumulativePathLength + pathCmd.pathLength < glyphWidth) {
                            cumulativePathLength += pathCmd.pathLength;
                            pathCmd = undefined;
                        }
                    }

                    if(pathCmd === {} || p0 === undefined) {
                        return undefined;
                    }

                    var needNewSegment = false;

                    switch (pathCmd.command) {
                        case 'L':
                            if(Konva.Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {
                                p1 = Konva.Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);
                            }
                            else {
                                pathCmd = undefined;
                            }
                            break;
                        case 'A':

                            var start = pathCmd.points[4];
                            // 4 = theta
                            var dTheta = pathCmd.points[5];
                            // 5 = dTheta
                            var end = pathCmd.points[4] + dTheta;

                            if(currentT === 0){
                                currentT = start + 0.00000001;
                            }
                            // Just in case start is 0
                            else if(glyphWidth > currLen) {
                                currentT += (Math.PI / 180.0) * dTheta / Math.abs(dTheta);
                            }
                            else {
                                currentT -= Math.PI / 360.0 * dTheta / Math.abs(dTheta);
                            }

                            // Credit for bug fix: @therth https://github.com/ericdrowell/KonvaJS/issues/249
                            // Old code failed to render text along arc of this path: "M 50 50 a 150 50 0 0 1 250 50 l 50 0"
                            if(dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {
                                currentT = end;
                                needNewSegment = true;
                            }
                            p1 = Konva.Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);
                            break;
                        case 'C':
                            if(currentT === 0) {
                                if(glyphWidth > pathCmd.pathLength) {
                                    currentT = 0.00000001;
                                }
                                else {
                                    currentT = glyphWidth / pathCmd.pathLength;
                                }
                            }
                            else if(glyphWidth > currLen) {
                                currentT += (glyphWidth - currLen) / pathCmd.pathLength;
                            }
                            else {
                                currentT -= (currLen - glyphWidth) / pathCmd.pathLength;
                            }

                            if(currentT > 1.0) {
                                currentT = 1.0;
                                needNewSegment = true;
                            }
                            p1 = Konva.Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);
                            break;
                        case 'Q':
                            if(currentT === 0) {
                                currentT = glyphWidth / pathCmd.pathLength;
                            }
                            else if(glyphWidth > currLen) {
                                currentT += (glyphWidth - currLen) / pathCmd.pathLength;
                            }
                            else {
                                currentT -= (currLen - glyphWidth) / pathCmd.pathLength;
                            }

                            if(currentT > 1.0) {
                                currentT = 1.0;
                                needNewSegment = true;
                            }
                            p1 = Konva.Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);
                            break;

                    }

                    if(p1 !== undefined) {
                        currLen = Konva.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);
                    }

                    if(needNewSegment) {
                        needNewSegment = false;
                        pathCmd = undefined;
                    }
                }
            };
            for(var i = 0; i < charArr.length; i++) {

                // Find p1 such that line segment between p0 and p1 is approx. width of glyph
                findSegmentToFitCharacter(charArr[i]);

                if(p0 === undefined || p1 === undefined) {
                    break;
                }

                var width = Konva.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);

                // Note: Since glyphs are rendered one at a time, any kerning pair data built into the font will not be used.
                // Can foresee having a rough pair table built in that the developer can override as needed.

                var kern = 0;
                // placeholder for future implementation

                var midpoint = Konva.Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);

                var rotation = Math.atan2((p1.y - p0.y), (p1.x - p0.x));
                this.glyphInfo.push({
                    transposeX: midpoint.x,
                    transposeY: midpoint.y,
                    text: charArr[i],
                    rotation: rotation,
                    p0: p0,
                    p1: p1
                });
                p0 = p1;
            }
        },
        getSelfRect: function() {
            var points = [];
            var fontSize = this.fontSize();

            this.glyphInfo.forEach(function(info) {
                points.push(info.p0.x);
                points.push(info.p0.y);
                points.push(info.p1.x);
                points.push(info.p1.y);
            });
            var minX = points[0];
            var maxX = points[0];
            var minY = points[0];
            var maxY = points[0];
            var x, y;
            for (var i = 0; i < points.length / 2; i++) {
                x = points[i * 2]; y = points[i * 2 + 1];
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }
            return {
                x: Math.round(minX) - fontSize,
                y: Math.round(minY) - fontSize,
                width: Math.round(maxX - minX) + fontSize * 2,
                height: Math.round(maxY - minY) + fontSize * 2
            };
        }
    };

    // map TextPath methods to Text
    Konva.TextPath.prototype._getContextFont = Konva.Text.prototype._getContextFont;

    Konva.Util.extend(Konva.TextPath, Konva.Shape);

    // add setters and getters
    Konva.Factory.addGetterSetter(Konva.TextPath, 'fontFamily', 'Arial');

    /**
     * set font family
     * @name setFontFamily
     * @method
     * @memberof Konva.TextPath.prototype
     * @param {String} fontFamily
     */

     /**
     * get font family
     * @name getFontFamily
     * @method
     * @memberof Konva.TextPath.prototype
     */

    Konva.Factory.addGetterSetter(Konva.TextPath, 'fontSize', 12);

    /**
     * set font size
     * @name setFontSize
     * @method
     * @memberof Konva.TextPath.prototype
     * @param {int} fontSize
     */

     /**
     * get font size
     * @name getFontSize
     * @method
     * @memberof Konva.TextPath.prototype
     */

    Konva.Factory.addGetterSetter(Konva.TextPath, 'fontStyle', NORMAL);

    /**
     * set font style.  Can be 'normal', 'italic', or 'bold'.  'normal' is the default.
     * @name setFontStyle
     * @method
     * @memberof Konva.TextPath.prototype
     * @param {String} fontStyle
     */

     /**
     * get font style
     * @name getFontStyle
     * @method
     * @memberof Konva.TextPath.prototype
     */

    Konva.Factory.addGetterSetter(Konva.TextPath, 'fontVariant', NORMAL);

    /**
     * set font variant.  Can be 'normal' or 'small-caps'.  'normal' is the default.
     * @name setFontVariant
     * @method
     * @memberof Konva.TextPath.prototype
     * @param {String} fontVariant
     */

    /**
     * @get font variant
     * @name getFontVariant
     * @method
     * @memberof Konva.TextPath.prototype
     */

    Konva.Factory.addGetter(Konva.TextPath, 'text', EMPTY_STRING);

    /**
     * get text
     * @name getText
     * @method
     * @memberof Konva.TextPath.prototype
     */

    Konva.Collection.mapMethods(Konva.TextPath);
})();

(function() {
    'use strict';
    /**
     * RegularPolygon constructor.&nbsp; Examples include triangles, squares, pentagons, hexagons, etc.
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.sides
     * @param {Number} config.radius
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var hexagon = new Konva.RegularPolygon({
     *   x: 100,
     *   y: 200,
     *   sides: 6,
     *   radius: 70,
     *   fill: 'red',
     *   stroke: 'black',
     *   strokeWidth: 4
     * });
     */
    Konva.RegularPolygon = function(config) {
        this.___init(config);
    };

    Konva.RegularPolygon.prototype = {
        _centroid: true,
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'RegularPolygon';
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            var sides = this.attrs.sides,
                radius = this.attrs.radius,
                n, x, y;

            context.beginPath();
            context.moveTo(0, 0 - radius);

            for(n = 1; n < sides; n++) {
                x = radius * Math.sin(n * 2 * Math.PI / sides);
                y = -1 * radius * Math.cos(n * 2 * Math.PI / sides);
                context.lineTo(x, y);
            }
            context.closePath();
            context.fillStrokeShape(this);
        },
        getWidth: function() {
            return this.getRadius() * 2;
        },
        // implements Shape.prototype.getHeight()
        getHeight: function() {
            return this.getRadius() * 2;
        },
        // implements Shape.prototype.setWidth()
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            if (this.radius() !== width / 2) {
                this.setRadius(width / 2);
            }
        },
        // implements Shape.prototype.setHeight()
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            if (this.radius() !== height / 2) {
                this.setRadius(height / 2);
            }
        }
    };
    Konva.Util.extend(Konva.RegularPolygon, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.RegularPolygon, 'radius', 0);

    /**
     * set radius
     * @name setRadius
     * @method
     * @memberof Konva.RegularPolygon.prototype
     * @param {Number} radius
     */

     /**
     * get radius
     * @name getRadius
     * @method
     * @memberof Konva.RegularPolygon.prototype
     */

    Konva.Factory.addGetterSetter(Konva.RegularPolygon, 'sides', 0);

    /**
     * set number of sides
     * @name setSides
     * @method
     * @memberof Konva.RegularPolygon.prototype
     * @param {int} sides
     */

    /**
     * get number of sides
     * @name getSides
     * @method
     * @memberof Konva.RegularPolygon.prototype
     */

    Konva.Collection.mapMethods(Konva.RegularPolygon);
})();

(function() {
    'use strict';
    /**
     * Star constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Integer} config.numPoints
     * @param {Number} config.innerRadius
     * @param {Number} config.outerRadius
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var star = new Konva.Star({
     *   x: 100,
     *   y: 200,
     *   numPoints: 5,
     *   innerRadius: 70,
     *   outerRadius: 70,
     *   fill: 'red',
     *   stroke: 'black',
     *   strokeWidth: 4
     * });
     */
    Konva.Star = function(config) {
        this.___init(config);
    };

    Konva.Star.prototype = {
        _centroid: true,
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'Star';
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            var innerRadius = this.innerRadius(),
                outerRadius = this.outerRadius(),
                numPoints = this.numPoints();

            context.beginPath();
            context.moveTo(0, 0 - outerRadius);

            for(var n = 1; n < numPoints * 2; n++) {
                var radius = n % 2 === 0 ? outerRadius : innerRadius;
                var x = radius * Math.sin(n * Math.PI / numPoints);
                var y = -1 * radius * Math.cos(n * Math.PI / numPoints);
                context.lineTo(x, y);
            }
            context.closePath();

            context.fillStrokeShape(this);
        },
        // implements Shape.prototype.getWidth()
        getWidth: function() {
            return this.getOuterRadius() * 2;
        },
        // implements Shape.prototype.getHeight()
        getHeight: function() {
            return this.getOuterRadius() * 2;
        },
        // implements Shape.prototype.setWidth()
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            if (this.outerRadius() !== width / 2) {
                this.setOuterRadius(width / 2);
            }
        },
        // implements Shape.prototype.setHeight()
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            if (this.outerRadius() !== height / 2) {
                this.setOuterRadius(height / 2);
            }
        }
    };
    Konva.Util.extend(Konva.Star, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Star, 'numPoints', 5);

    /**
     * set number of points
     * @name setNumPoints
     * @method
     * @memberof Konva.Star.prototype
     * @param {Integer} points
     */

     /**
     * get number of points
     * @name getNumPoints
     * @method
     * @memberof Konva.Star.prototype
     */

    Konva.Factory.addGetterSetter(Konva.Star, 'innerRadius', 0);

    /**
     * set inner radius
     * @name setInnerRadius
     * @method
     * @memberof Konva.Star.prototype
     * @param {Number} radius
     */

     /**
     * get inner radius
     * @name getInnerRadius
     * @method
     * @memberof Konva.Star.prototype
     */

    Konva.Factory.addGetterSetter(Konva.Star, 'outerRadius', 0);

    /**
     * set outer radius
     * @name setOuterRadius
     * @method
     * @memberof Konva.Star.prototype
     * @param {Number} radius
     */

     /**
     * get outer radius
     * @name getOuterRadius
     * @method
     * @memberof Konva.Star.prototype
     */

    Konva.Collection.mapMethods(Konva.Star);
})();

(function() {
    'use strict';
    // constants
    var ATTR_CHANGE_LIST = ['fontFamily', 'fontSize', 'fontStyle', 'padding', 'lineHeight', 'text'],
        CHANGE_KONVA = 'Change.konva',
        NONE = 'none',
        UP = 'up',
        RIGHT = 'right',
        DOWN = 'down',
        LEFT = 'left',
        LABEL = 'Label',

     // cached variables
     attrChangeListLen = ATTR_CHANGE_LIST.length;

    /**
     * Label constructor.&nbsp; Labels are groups that contain a Text and Tag shape
     * @constructor
     * @memberof Konva
     * @param {Object} config
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * // create label
     * var label = new Konva.Label({
     *   x: 100,
     *   y: 100,
     *   draggable: true
     * });
     *
     * // add a tag to the label
     * label.add(new Konva.Tag({
     *   fill: '#bbb',
     *   stroke: '#333',
     *   shadowColor: 'black',
     *   shadowBlur: 10,
     *   shadowOffset: [10, 10],
     *   shadowOpacity: 0.2,
     *   lineJoin: 'round',
     *   pointerDirection: 'up',
     *   pointerWidth: 20,
     *   pointerHeight: 20,
     *   cornerRadius: 5
     * }));
     *
     * // add text to the label
     * label.add(new Konva.Text({
     *   text: 'Hello World!',
     *   fontSize: 50,
     *   lineHeight: 1.2,
     *   padding: 10,
     *   fill: 'green'
     *  }));
     */
    Konva.Label = function(config) {
        this.____init(config);
    };

    Konva.Label.prototype = {
        ____init: function(config) {
            var that = this;

            Konva.Group.call(this, config);
            this.className = LABEL;

            this.on('add.konva', function(evt) {
                that._addListeners(evt.child);
                that._sync();
            });
        },
        /**
         * get Text shape for the label.  You need to access the Text shape in order to update
         * the text properties
         * @name getText
         * @method
         * @memberof Konva.Label.prototype
         */
        getText: function() {
            return this.find('Text')[0];
        },
        /**
         * get Tag shape for the label.  You need to access the Tag shape in order to update
         * the pointer properties and the corner radius
         * @name getTag
         * @method
         * @memberof Konva.Label.prototype
         */
        getTag: function() {
            return this.find('Tag')[0];
        },
        _addListeners: function(text) {
            var that = this,
                n;
            var func = function(){
                    that._sync();
                };

            // update text data for certain attr changes
            for(n = 0; n < attrChangeListLen; n++) {
                text.on(ATTR_CHANGE_LIST[n] + CHANGE_KONVA, func);
            }
        },
        getWidth: function() {
            return this.getText().getWidth();
        },
        getHeight: function() {
            return this.getText().getHeight();
        },
        _sync: function() {
            var text = this.getText(),
                tag = this.getTag(),
                width, height, pointerDirection, pointerWidth, x, y, pointerHeight;

            if (text && tag) {
                width = text.getWidth();
                height = text.getHeight();
                pointerDirection = tag.getPointerDirection();
                pointerWidth = tag.getPointerWidth();
                pointerHeight = tag.getPointerHeight();
                x = 0;
                y = 0;

                switch(pointerDirection) {
                    case UP:
                        x = width / 2;
                        y = -1 * pointerHeight;
                        break;
                    case RIGHT:
                        x = width + pointerWidth;
                        y = height / 2;
                        break;
                    case DOWN:
                        x = width / 2;
                        y = height + pointerHeight;
                        break;
                    case LEFT:
                        x = -1 * pointerWidth;
                        y = height / 2;
                        break;
                }

                tag.setAttrs({
                    x: -1 * x,
                    y: -1 * y,
                    width: width,
                    height: height
                });

                text.setAttrs({
                    x: -1 * x,
                    y: -1 * y
                });
            }
        }
    };

    Konva.Util.extend(Konva.Label, Konva.Group);

    Konva.Collection.mapMethods(Konva.Label);

    /**
     * Tag constructor.&nbsp; A Tag can be configured
     *  to have a pointer element that points up, right, down, or left
     * @constructor
     * @memberof Konva
     * @param {Object} config
     * @param {String} [config.pointerDirection] can be up, right, down, left, or none; the default
     *  is none.  When a pointer is present, the positioning of the label is relative to the tip of the pointer.
     * @param {Number} [config.pointerWidth]
     * @param {Number} [config.pointerHeight]
     * @param {Number} [config.cornerRadius]
     */
    Konva.Tag = function(config) {
        this.___init(config);
    };

    Konva.Tag.prototype = {
        ___init: function(config) {
            Konva.Shape.call(this, config);
            this.className = 'Tag';
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            var width = this.getWidth(),
                height = this.getHeight(),
                pointerDirection = this.getPointerDirection(),
                pointerWidth = this.getPointerWidth(),
                pointerHeight = this.getPointerHeight(),
                cornerRadius = this.getCornerRadius();

            context.beginPath();
            context.moveTo(0, 0);

            if (pointerDirection === UP) {
                context.lineTo((width - pointerWidth) / 2, 0);
                context.lineTo(width / 2, -1 * pointerHeight);
                context.lineTo((width + pointerWidth) / 2, 0);
            }

            if(!cornerRadius) {
                context.lineTo(width, 0);
            } else {
                context.lineTo(width - cornerRadius, 0);
                context.arc(width - cornerRadius, cornerRadius, cornerRadius, Math.PI * 3 / 2, 0, false);
            }

            if (pointerDirection === RIGHT) {
                context.lineTo(width, (height - pointerHeight) / 2);
                context.lineTo(width + pointerWidth, height / 2);
                context.lineTo(width, (height + pointerHeight) / 2);
            }

            if(!cornerRadius) {
                context.lineTo(width, height);
            } else {
                context.lineTo(width, height - cornerRadius);
                context.arc(width - cornerRadius, height - cornerRadius, cornerRadius, 0, Math.PI / 2, false);
            }

            if (pointerDirection === DOWN) {
                context.lineTo((width + pointerWidth) / 2, height);
                context.lineTo(width / 2, height + pointerHeight);
                context.lineTo((width - pointerWidth) / 2, height);
            }

            if(!cornerRadius) {
                context.lineTo(0, height);
            } else {
                context.lineTo(cornerRadius, height);
                context.arc(cornerRadius, height - cornerRadius, cornerRadius, Math.PI / 2, Math.PI, false);
            }

            if (pointerDirection === LEFT) {
                context.lineTo(0, (height + pointerHeight) / 2);
                context.lineTo(-1 * pointerWidth, height / 2);
                context.lineTo(0, (height - pointerHeight) / 2);
            }

            if(cornerRadius) {
                context.lineTo(0, cornerRadius);
                context.arc(cornerRadius, cornerRadius, cornerRadius, Math.PI, Math.PI * 3 / 2, false);
            }

            context.closePath();
            context.fillStrokeShape(this);
        },
        getSelfRect: function() {
            var x = 0,
                y = 0,
                pointerWidth = this.getPointerWidth(),
                pointerHeight = this.getPointerHeight(),
                direction = this.pointerDirection(),
                width = this.getWidth(),
                height = this.getHeight();

            if (direction === UP) {
                y -= pointerHeight;
                height += pointerHeight;
            } else if (direction === DOWN) {
                height += pointerHeight;
            } else if (direction === LEFT) {
                // ARGH!!! I have no idea why should I used magic 1.5!!!!!!!!!
                x -= pointerWidth * 1.5;
                width += pointerWidth;
            } else if (direction === RIGHT) {
                width += pointerWidth * 1.5;
            }
            return {
                x: x,
                y: y,
                width: width,
                height: height
            };
        }
    };

    Konva.Util.extend(Konva.Tag, Konva.Shape);
    Konva.Factory.addGetterSetter(Konva.Tag, 'pointerDirection', NONE);

    /**
     * set pointer Direction
     * @name setPointerDirection
     * @method
     * @memberof Konva.Tag.prototype
     * @param {String} pointerDirection can be up, right, down, left, or none.  The
     *  default is none
     */

     /**
     * get pointer Direction
     * @name getPointerDirection
     * @method
     * @memberof Konva.Tag.prototype
     */

    Konva.Factory.addGetterSetter(Konva.Tag, 'pointerWidth', 0);

    /**
     * set pointer width
     * @name setPointerWidth
     * @method
     * @memberof Konva.Tag.prototype
     * @param {Number} pointerWidth
     */

     /**
     * get pointer width
     * @name getPointerWidth
     * @method
     * @memberof Konva.Tag.prototype
     */

    Konva.Factory.addGetterSetter(Konva.Tag, 'pointerHeight', 0);

    /**
     * set pointer height
     * @name setPointerHeight
     * @method
     * @memberof Konva.Tag.prototype
     * @param {Number} pointerHeight
     */

     /**
     * get pointer height
     * @name getPointerHeight
     * @method
     * @memberof Konva.Tag.prototype
     */

    Konva.Factory.addGetterSetter(Konva.Tag, 'cornerRadius', 0);

    /**
     * set corner radius
     * @name setCornerRadius
     * @method
     * @memberof Konva.Tag.prototype
     * @param {Number} corner radius
     */

    /**
     * get corner radius
     * @name getCornerRadius
     * @method
     * @memberof Konva.Tag.prototype
     */

    Konva.Collection.mapMethods(Konva.Tag);
})();

(function() {
    'use strict';
    /**
     * Arrow constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Array} config.points
     * @param {Number} [config.tension] Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
     *   The default is 0
     * @param {Number} config.pointerLength
     * @param {Number} config.pointerWidth
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var line = new Konva.Line({
     *   points: [73, 70, 340, 23, 450, 60, 500, 20],
     *   stroke: 'red',
     *   tension: 1,
     *   pointerLength : 10,
     *   pointerWidth : 12
     * });
     */
    Konva.Arrow = function(config) {
        this.____init(config);
    };

    Konva.Arrow.prototype = {
        ____init: function(config) {
            // call super constructor
            Konva.Line.call(this, config);
            this.className = 'Arrow';
        },
        _sceneFunc: function(ctx) {
            var PI2 = Math.PI * 2;
            var points = this.points();
            var n = points.length;
            var dx = points[n - 2] - points[n - 4];
            var dy = points[n - 1] - points[n - 3];
            var radians = (Math.atan2(dy, dx) + PI2) % PI2;
            var length = this.pointerLength();
            var width = this.pointerWidth();

            ctx.save();
            ctx.beginPath();
            ctx.translate(points[n - 2], points[n - 1]);
            ctx.rotate(radians);
            ctx.moveTo(0, 0);
            ctx.lineTo(-length, width / 2);
            ctx.lineTo(-length, -width / 2);
            ctx.closePath();
            ctx.restore();

            if (this.pointerAtBeginning()) {
                ctx.save();
                ctx.translate(points[0], points[1]);
                dx = points[2] - points[0];
                dy = points[3] - points[1];
                ctx.rotate((Math.atan2(-dy, -dx) + PI2) % PI2);
                ctx.moveTo(0, 0);
                ctx.lineTo(-10, 6);
                ctx.lineTo(-10, -6);
                ctx.closePath();
                ctx.restore();
            }

            ctx.fillStrokeShape(this);
            Konva.Line.prototype._sceneFunc.apply(this, arguments);
        }
    };

    Konva.Util.extend(Konva.Arrow, Konva.Line);
    /**
     * get/set pointerLength
     * @name pointerLength
     * @method
     * @memberof Konva.Arrow.prototype
     * @param {Number} Length of pointer of arrow.
     *   The default is 10.
     * @returns {Number}
     * @example
     * // get tension
     * var pointerLength = line.pointerLength();
     *
     * // set tension
     * line.pointerLength(15);
     */

    Konva.Factory.addGetterSetter(Konva.Arrow, 'pointerLength', 10);
    /**
     * get/set pointerWidth
     * @name pointerWidth
     * @method
     * @memberof Konva.Arrow.prototype
     * @param {Number} Width of pointer of arrow.
     *   The default is 10.
     * @returns {Number}
     * @example
     * // get tension
     * var pointerWidth = line.pointerWidth();
     *
     * // set tension
     * line.pointerWidth(15);
     */

    Konva.Factory.addGetterSetter(Konva.Arrow, 'pointerWidth', 10);
    /**
     * get/set pointerAtBeginning
     * @name pointerAtBeginning
     * @method
     * @memberof Konva.Arrow.prototype
     * @param {Number} Should pointer displayed at beginning of arrow.
     *   The default is false.
     * @returns {Boolean}
     * @example
     * // get tension
     * var pointerAtBeginning = line.pointerAtBeginning();
     *
     * // set tension
     * line.pointerAtBeginning(true);
     */

    Konva.Factory.addGetterSetter(Konva.Arrow, 'pointerAtBeginning', false);
    Konva.Collection.mapMethods(Konva.Arrow);

})();


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"canvas":1,"jsdom":1}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

function playAnimation(playerHand, aiHand, outcome) {
  var handColors = {
    rock: '#8a4c41',
    scissors: '#c5cae9',
    paper: '#ffe19f',
    lizard: '#00c18a',
    spock: '#748ebd'
  };

  var hexRadius = 75;

  var container = document.getElementById('results');
  container.style.display = 'block';

  var stage = new _konva2['default'].Stage({
    container: 'results',
    width: container.offsetWidth,
    height: container.offsetHeight
  });

  var background = new _konva2['default'].Layer();
  var foreground = new _konva2['default'].Layer({ offset: { y: 35 } });
  var overlay = new _konva2['default'].Layer();

  var left = new _konva2['default'].Group({
    x: -(hexRadius * 3),
    y: stage.height() / 2 - hexRadius * 0.75 - 3
  });
  var right = new _konva2['default'].Group({
    x: stage.width() + hexRadius * 3,
    y: stage.height() / 2 + hexRadius * 0.75 + 3
  });

  var backgroundFill = new _konva2['default'].Rect({
    x: 0,
    y: 0,
    width: stage.width(),
    height: stage.height(),
    fill: 'rgba(50, 60, 80, 1)'
  });

  var hexL = new _konva2['default'].RegularPolygon({
    x: 0,
    y: 0,
    radius: hexRadius,
    sides: 6,
    stroke: handColors[playerHand],
    strokeWidth: 6,
    fill: 'rgba(0, 0, 0, 0.5)'
  });
  var hexR = new _konva2['default'].RegularPolygon({
    x: 0,
    y: 0,
    radius: hexRadius,
    sides: 6,
    stroke: handColors[aiHand],
    strokeWidth: 6,
    fill: 'rgba(0, 0, 0, 0.5)'
  });

  var playerImgEl = document.getElementById('img-' + playerHand);
  var playerImg = new _konva2['default'].Image({
    x: -50,
    y: -50,
    image: playerImgEl,
    width: 100,
    height: 100
  });

  var aiImgEl = document.getElementById('img-' + aiHand);
  var aiImg = new _konva2['default'].Image({
    x: -50,
    y: -50,
    image: aiImgEl,
    width: 100,
    height: 100
  });

  var text = new _konva2['default'].Text({
    x: stage.width() / 2,
    y: stage.height() * 0.8,
    text: outcome.message,
    fontFamily: 'Lato',
    fontSize: 32,
    fill: 'black',
    align: 'center',
    padding: 10
  });
  text.setOffset({
    x: text.width() / 2
  });

  var textBox = new _konva2['default'].Rect({
    x: stage.width() / 2 - text.width() / 2 - 30,
    y: stage.height() * 0.8,
    width: text.width() + 60,
    height: text.height(),
    fill: 'white',
    cornerRadius: 2,
    shadowColor: 'black',
    shadowBlur: 75,
    shadowOpacity: 0.2
  });

  left.add(hexL, playerImg);
  right.add(hexR, aiImg);
  background.add(backgroundFill);
  foreground.add(left, right);
  overlay.add(textBox, text);
  stage.add(background, foreground, overlay);

  new _konva2['default'].Animation(function (frame) {
    left.setX(frame.time / 1.5);
    right.setX(stage.width() - frame.time / 1.5);

    if (left.x() >= stage.width() / 2 - hexRadius / 2 - 3) {
      left.setX(stage.width() / 2 - hexRadius / 2 - 3);
      right.setX(stage.width() / 2 + hexRadius / 2 + 3);

      this.stop();
      outcomeAnimation.start();
    }
  }, stage).start();

  var outcomeAnimation = new _konva2['default'].Animation(function (frame) {
    var scaleMod = frame.time / 3000;

    if (outcome.state == 'win') {
      hexL.scale({ x: 1 + scaleMod, y: 1 + scaleMod });
      hexR.scale({ x: 1 - scaleMod, y: 1 - scaleMod });
      right.opacity(1 - frame.time / 500);
    }
    if (outcome.state == 'lose') {
      hexL.scale({ x: 1 - scaleMod, y: 1 - scaleMod });
      hexR.scale({ x: 1 + scaleMod, y: 1 + scaleMod });
      left.opacity(1 - frame.time / 500);
    }
    if (outcome.state == 'draw') {
      left.opacity(1 - frame.time / 500);
      right.opacity(1 - frame.time / 500);
    }

    if (scaleMod >= 0.1) {
      this.stop();
    }
  }, stage);

  var waitThenHideResult = setTimeout(function () {
    container.style.display = 'none';
  }, 3000);

  function hideResultNow() {
    clearTimeout(waitThenHideResult);
    this.style.display = 'none';
  }

  container.addEventListener('click', hideResultNow);
  container.addEventListener('touchstart', hideResultNow);
}

exports['default'] = playAnimation;
module.exports = exports['default'];

},{"konva":2}],4:[function(require,module,exports){
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _utility = require('./utility');

var utility = _interopRequireWildcard(_utility);

var _animation = require('./animation');

var _animation2 = _interopRequireDefault(_animation);

window.addEventListener('load', game);

function game() {
  /** @type {Object} **/
  var hands = {
    rock: {
      el: document.getElementById('rock'),
      beats: ['scissors', 'lizard']
    },
    scissors: {
      el: document.getElementById('scissors'),
      beats: ['paper', 'lizard']
    },
    paper: {
      el: document.getElementById('paper'),
      beats: ['rock', 'spock']
    },
    lizard: {
      el: document.getElementById('lizard'),
      beats: ['paper', 'spock']
    },
    spock: {
      el: document.getElementById('spock'),
      beats: ['scissors', 'rock']
    }
  };

  /**
   * Bind an event to each hand element so that when a button is clicked that
   * hand is played.
   */
  for (var hand in hands) {
    if (hands.hasOwnProperty(hand)) {
      hands[hand].el.addEventListener('click', play);
    }
  }

  /**
   * Bind an event to the start mgenu game mode buttons to start the game.
   *
   * Currently pressing any game mode button will just reveal the game without
   * actually modifying any rules.
   */
  document.getElementById('infinite').addEventListener('click', function () {
    document.getElementById('start-menu').style.display = 'none';
    document.getElementById('game').style.display = 'block';
  });

  /**
   * Take the user's inputted hand, generate the AI's hand, and pass them along
   * to be judged.
   *
   * @param event {Object}
   */
  function play(event) {
    determineWinner(event.target.getAttribute('data-hand'), chooseAiHand().getAttribute('data-hand'));
  }

  /**
   * Using a random number generator pick one of the hands for the AI to play.
   *
   * @returns {Element}
   */
  function chooseAiHand() {
    var hand = utility.randomProperty(hands);
    return hand.el;
  }

  /**
   * Determine if the player has won, lost or drawn with the AI.
   *
   * @param playerHand {string}
   * @param aiHand {string}
   */
  function determineWinner(playerHand, aiHand) {
    // Draw
    if (playerHand === aiHand) {
      (0, _animation2['default'])(playerHand, aiHand, { state: 'draw', message: 'Draw' });
      score(1, 'draws');
    }
    // Win
    else if (hands[playerHand].beats.indexOf(aiHand) > -1) {
        (0, _animation2['default'])(playerHand, aiHand, { state: 'win', message: 'You win!' });
        score(1, 'player');
      }
      // Lose
      else {
          (0, _animation2['default'])(playerHand, aiHand, { state: 'lose', message: 'You lose' });
          score(1, 'ai');
        }
  }

  /**
   * Add points to a player's score.
   *
   * @param amount {number}
   * @param who {string}
   */
  function score(amount, who) {
    var amountEl = document.querySelectorAll('.' + who + ' > .amount')[0];
    amountEl.innerHTML = Number(amountEl.innerHTML) + amount;
  }
}

},{"./animation":3,"./utility":5}],5:[function(require,module,exports){
/**
 * Return a random integer between the passed parameters.
 *
 * @param min {number}
 * @param max {number}
 * @returns {number}
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.randomInt = randomInt;
exports.randomProperty = randomProperty;

function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}

/**
 * Return a random property from the passed object.
 *
 * @param object {object}
 * @returns {object}
 */

function randomProperty(object) {
  var properties = Object.keys(object);
  var index = randomInt(0, properties.length - 1);
  var propertyKey = properties[index];

  return object[propertyKey];
}

},{}]},{},[4])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2tvbnZhL2tvbnZhLmpzIiwiL1VzZXJzL3JoeXRobS93d3cvcnBzL3NyYy9zY3JpcHRzL2FuaW1hdGlvbi5qcyIsIi9Vc2Vycy9yaHl0aG0vd3d3L3Jwcy9zcmMvc2NyaXB0cy9tYWluLmpzIiwiL1VzZXJzL3JoeXRobS93d3cvcnBzL3NyYy9zY3JpcHRzL3V0aWxpdHkuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O3FCQy9yZmtCLE9BQU87Ozs7QUFFekIsU0FBUyxhQUFhLENBQUMsVUFBVSxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUU7QUFDbEQsTUFBTSxVQUFVLEdBQUc7QUFDakIsUUFBSSxFQUFFLFNBQVM7QUFDZixZQUFRLEVBQUUsU0FBUztBQUNuQixTQUFLLEVBQUUsU0FBUztBQUNoQixVQUFNLEVBQUUsU0FBUztBQUNqQixTQUFLLEVBQUUsU0FBUztHQUNqQixDQUFBOztBQUVELE1BQU0sU0FBUyxHQUFHLEVBQUUsQ0FBQzs7QUFFckIsTUFBSSxTQUFTLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUNuRCxXQUFTLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7O0FBRWxDLE1BQUksS0FBSyxHQUFHLElBQUksbUJBQU0sS0FBSyxDQUFDO0FBQzFCLGFBQVMsRUFBRSxTQUFTO0FBQ3BCLFNBQUssRUFBRSxTQUFTLENBQUMsV0FBVztBQUM1QixVQUFNLEVBQUUsU0FBUyxDQUFDLFlBQVk7R0FDL0IsQ0FBQyxDQUFDOztBQUVILE1BQUksVUFBVSxHQUFHLElBQUksbUJBQU0sS0FBSyxFQUFFLENBQUM7QUFDbkMsTUFBSSxVQUFVLEdBQUcsSUFBSSxtQkFBTSxLQUFLLENBQUMsRUFBRSxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ3hELE1BQUksT0FBTyxHQUFHLElBQUksbUJBQU0sS0FBSyxFQUFFLENBQUM7O0FBRWhDLE1BQUksSUFBSSxHQUFHLElBQUksbUJBQU0sS0FBSyxDQUFDO0FBQ3pCLEtBQUMsRUFBRSxFQUFFLFNBQVMsR0FBRyxDQUFDLENBQUEsQUFBQztBQUNuQixLQUFDLEVBQUUsQUFBQyxLQUFLLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFLLFNBQVMsR0FBRyxJQUFJLEFBQUMsR0FBRyxDQUFDO0dBQ2pELENBQUMsQ0FBQztBQUNILE1BQUksS0FBSyxHQUFHLElBQUksbUJBQU0sS0FBSyxDQUFDO0FBQzFCLEtBQUMsRUFBRSxLQUFLLENBQUMsS0FBSyxFQUFFLEdBQUksU0FBUyxHQUFHLENBQUMsQUFBQztBQUNsQyxLQUFDLEVBQUUsQUFBQyxLQUFLLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFLLFNBQVMsR0FBRyxJQUFJLEFBQUMsR0FBRyxDQUFDO0dBQ2pELENBQUMsQ0FBQzs7QUFFSCxNQUFJLGNBQWMsR0FBRyxJQUFJLG1CQUFNLElBQUksQ0FBQztBQUNsQyxLQUFDLEVBQUUsQ0FBQztBQUNKLEtBQUMsRUFBRSxDQUFDO0FBQ0osU0FBSyxFQUFFLEtBQUssQ0FBQyxLQUFLLEVBQUU7QUFDcEIsVUFBTSxFQUFFLEtBQUssQ0FBQyxNQUFNLEVBQUU7QUFDdEIsUUFBSSxFQUFFLHFCQUFxQjtHQUM1QixDQUFDLENBQUM7O0FBRUgsTUFBSSxJQUFJLEdBQUcsSUFBSSxtQkFBTSxjQUFjLENBQUM7QUFDbEMsS0FBQyxFQUFFLENBQUM7QUFDSixLQUFDLEVBQUUsQ0FBQztBQUNKLFVBQU0sRUFBRSxTQUFTO0FBQ2pCLFNBQUssRUFBRSxDQUFDO0FBQ1IsVUFBTSxFQUFFLFVBQVUsQ0FBQyxVQUFVLENBQUM7QUFDOUIsZUFBVyxFQUFFLENBQUM7QUFDZCxRQUFJLEVBQUUsb0JBQW9CO0dBQzNCLENBQUMsQ0FBQztBQUNILE1BQUksSUFBSSxHQUFHLElBQUksbUJBQU0sY0FBYyxDQUFDO0FBQ2xDLEtBQUMsRUFBRSxDQUFDO0FBQ0osS0FBQyxFQUFFLENBQUM7QUFDSixVQUFNLEVBQUUsU0FBUztBQUNqQixTQUFLLEVBQUUsQ0FBQztBQUNSLFVBQU0sRUFBRSxVQUFVLENBQUMsTUFBTSxDQUFDO0FBQzFCLGVBQVcsRUFBRSxDQUFDO0FBQ2QsUUFBSSxFQUFFLG9CQUFvQjtHQUMzQixDQUFDLENBQUM7O0FBRUgsTUFBSSxXQUFXLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEdBQUcsVUFBVSxDQUFDLENBQUM7QUFDL0QsTUFBSSxTQUFTLEdBQUcsSUFBSSxtQkFBTSxLQUFLLENBQUM7QUFDOUIsS0FBQyxFQUFFLENBQUMsRUFBRTtBQUNOLEtBQUMsRUFBRSxDQUFDLEVBQUU7QUFDTixTQUFLLEVBQUUsV0FBVztBQUNsQixTQUFLLEVBQUUsR0FBRztBQUNWLFVBQU0sRUFBRSxHQUFHO0dBQ1osQ0FBQyxDQUFDOztBQUVILE1BQUksT0FBTyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxDQUFDO0FBQ3ZELE1BQUksS0FBSyxHQUFHLElBQUksbUJBQU0sS0FBSyxDQUFDO0FBQzFCLEtBQUMsRUFBRSxDQUFDLEVBQUU7QUFDTixLQUFDLEVBQUUsQ0FBQyxFQUFFO0FBQ04sU0FBSyxFQUFFLE9BQU87QUFDZCxTQUFLLEVBQUUsR0FBRztBQUNWLFVBQU0sRUFBRSxHQUFHO0dBQ1osQ0FBQyxDQUFDOztBQUVILE1BQUksSUFBSSxHQUFHLElBQUksbUJBQU0sSUFBSSxDQUFDO0FBQ3hCLEtBQUMsRUFBRSxLQUFLLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQztBQUNwQixLQUFDLEVBQUUsS0FBSyxDQUFDLE1BQU0sRUFBRSxHQUFHLEdBQUc7QUFDdkIsUUFBSSxFQUFFLE9BQU8sQ0FBQyxPQUFPO0FBQ3JCLGNBQVUsRUFBRSxNQUFNO0FBQ2xCLFlBQVEsRUFBRSxFQUFFO0FBQ1osUUFBSSxFQUFFLE9BQU87QUFDYixTQUFLLEVBQUUsUUFBUTtBQUNmLFdBQU8sRUFBRSxFQUFFO0dBQ1osQ0FBQyxDQUFDO0FBQ0gsTUFBSSxDQUFDLFNBQVMsQ0FBQztBQUNiLEtBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQztHQUNwQixDQUFDLENBQUM7O0FBRUgsTUFBSSxPQUFPLEdBQUcsSUFBSSxtQkFBTSxJQUFJLENBQUM7QUFDM0IsS0FBQyxFQUFFLEFBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsR0FBSyxJQUFJLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxBQUFDLEdBQUcsRUFBRTtBQUNoRCxLQUFDLEVBQUUsS0FBSyxDQUFDLE1BQU0sRUFBRSxHQUFHLEdBQUc7QUFDdkIsU0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFO0FBQ3hCLFVBQU0sRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFO0FBQ3JCLFFBQUksRUFBRSxPQUFPO0FBQ2IsZ0JBQVksRUFBRSxDQUFDO0FBQ2YsZUFBVyxFQUFFLE9BQU87QUFDcEIsY0FBVSxFQUFFLEVBQUU7QUFDZCxpQkFBYSxFQUFFLEdBQUc7R0FDbkIsQ0FBQyxDQUFDOztBQUVILE1BQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQzFCLE9BQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQ3ZCLFlBQVUsQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDL0IsWUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDNUIsU0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDM0IsT0FBSyxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUUsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFDOztBQUUzQyxNQUFJLG1CQUFNLFNBQVMsQ0FBQyxVQUFTLEtBQUssRUFBRTtBQUNsQyxRQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7QUFDNUIsU0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEdBQUcsS0FBSyxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQzs7QUFFN0MsUUFBSSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQUFBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxHQUFLLFNBQVMsR0FBRyxDQUFDLEFBQUMsR0FBRyxDQUFDLEVBQUU7QUFDekQsVUFBSSxDQUFDLElBQUksQ0FBQyxBQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLEdBQUssU0FBUyxHQUFHLENBQUMsQUFBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ3JELFdBQUssQ0FBQyxJQUFJLENBQUMsQUFBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxHQUFLLFNBQVMsR0FBRyxDQUFDLEFBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzs7QUFFdEQsVUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO0FBQ1osc0JBQWdCLENBQUMsS0FBSyxFQUFFLENBQUM7S0FDMUI7R0FDRixFQUFFLEtBQUssQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDOztBQUVsQixNQUFJLGdCQUFnQixHQUFHLElBQUksbUJBQU0sU0FBUyxDQUFDLFVBQVMsS0FBSyxFQUFFO0FBQ3pELFFBQUksUUFBUSxHQUFHLEtBQUssQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDOztBQUVqQyxRQUFJLE9BQU8sQ0FBQyxLQUFLLElBQUksS0FBSyxFQUFFO0FBQzFCLFVBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsRUFBRSxDQUFDLENBQUM7QUFDakQsVUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxFQUFFLENBQUMsQ0FBQztBQUNqRCxXQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0tBQ3JDO0FBQ0QsUUFBSSxPQUFPLENBQUMsS0FBSyxJQUFJLE1BQU0sRUFBRTtBQUMzQixVQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLEVBQUUsQ0FBQyxDQUFDO0FBQ2pELFVBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsRUFBRSxDQUFDLENBQUM7QUFDakQsVUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztLQUNwQztBQUNELFFBQUksT0FBTyxDQUFDLEtBQUssSUFBSSxNQUFNLEVBQUU7QUFDM0IsVUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztBQUNuQyxXQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0tBQ3JDOztBQUVELFFBQUksUUFBUSxJQUFJLEdBQUcsRUFBRTtBQUNuQixVQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7S0FDYjtHQUNGLEVBQUUsS0FBSyxDQUFDLENBQUM7O0FBRVYsTUFBSSxrQkFBa0IsR0FBRyxVQUFVLENBQUMsWUFBVztBQUM3QyxhQUFTLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7R0FDbEMsRUFBRSxJQUFJLENBQUMsQ0FBQzs7QUFFVCxXQUFTLGFBQWEsR0FBRztBQUN2QixnQkFBWSxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFDakMsUUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO0dBQzdCOztBQUVELFdBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsYUFBYSxDQUFDLENBQUM7QUFDbkQsV0FBUyxDQUFDLGdCQUFnQixDQUFDLFlBQVksRUFBRSxhQUFhLENBQUMsQ0FBQztDQUN6RDs7cUJBRWMsYUFBYTs7Ozs7Ozs7Ozt1QkNsS0gsV0FBVzs7SUFBeEIsT0FBTzs7eUJBQ08sYUFBYTs7OztBQUV2QyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDOztBQUV0QyxTQUFTLElBQUksR0FBRzs7QUFFZCxNQUFNLEtBQUssR0FBRztBQUNaLFFBQUksRUFBRTtBQUNKLFFBQUUsRUFBRSxRQUFRLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQztBQUNuQyxXQUFLLEVBQUUsQ0FBQyxVQUFVLEVBQUUsUUFBUSxDQUFDO0tBQzlCO0FBQ0QsWUFBUSxFQUFFO0FBQ1IsUUFBRSxFQUFFLFFBQVEsQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDO0FBQ3ZDLFdBQUssRUFBRSxDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUM7S0FDM0I7QUFDRCxTQUFLLEVBQUU7QUFDTCxRQUFFLEVBQUUsUUFBUSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUM7QUFDcEMsV0FBSyxFQUFFLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQztLQUN6QjtBQUNELFVBQU0sRUFBRTtBQUNOLFFBQUUsRUFBRSxRQUFRLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQztBQUNyQyxXQUFLLEVBQUUsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDO0tBQzFCO0FBQ0QsU0FBSyxFQUFFO0FBQ0wsUUFBRSxFQUFFLFFBQVEsQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDO0FBQ3BDLFdBQUssRUFBRSxDQUFDLFVBQVUsRUFBRSxNQUFNLENBQUM7S0FDNUI7R0FDRixDQUFBOzs7Ozs7QUFNRCxPQUFLLElBQUksSUFBSSxJQUFJLEtBQUssRUFBRTtBQUN0QixRQUFJLEtBQUssQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEVBQUU7QUFDOUIsV0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7S0FDaEQ7R0FDRjs7Ozs7Ozs7QUFRRCxVQUFRLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxZQUFXO0FBQ3ZFLFlBQVEsQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7QUFDN0QsWUFBUSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztHQUN6RCxDQUFDLENBQUM7Ozs7Ozs7O0FBUUgsV0FBUyxJQUFJLENBQUMsS0FBSyxFQUFFO0FBQ25CLG1CQUFlLENBQ2IsS0FBSyxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLEVBQ3RDLFlBQVksRUFBRSxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUMsQ0FDekMsQ0FBQztHQUNIOzs7Ozs7O0FBT0QsV0FBUyxZQUFZLEdBQUc7QUFDdEIsUUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN6QyxXQUFPLElBQUksQ0FBQyxFQUFFLENBQUM7R0FDaEI7Ozs7Ozs7O0FBUUQsV0FBUyxlQUFlLENBQUMsVUFBVSxFQUFFLE1BQU0sRUFBRTs7QUFFM0MsUUFBSSxVQUFVLEtBQUssTUFBTSxFQUFFO0FBQ3pCLGtDQUFjLFVBQVUsRUFBRSxNQUFNLEVBQUUsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO0FBQ3RFLFdBQUssQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDbkI7O1NBRUksSUFBSSxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtBQUNyRCxvQ0FBYyxVQUFVLEVBQUUsTUFBTSxFQUFFLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLENBQUMsQ0FBQztBQUN6RSxhQUFLLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO09BQ3BCOztXQUVJO0FBQ0gsc0NBQWMsVUFBVSxFQUFFLE1BQU0sRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxDQUFDLENBQUM7QUFDMUUsZUFBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztTQUNoQjtHQUNGOzs7Ozs7OztBQVFELFdBQVMsS0FBSyxDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUU7QUFDMUIsUUFBSSxRQUFRLEdBQUcsUUFBUSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdEUsWUFBUSxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxHQUFHLE1BQU0sQ0FBQztHQUMxRDtDQUNGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyR00sU0FBUyxTQUFTLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRTtBQUNsQyxTQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFBLEFBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztDQUMxRDs7Ozs7Ozs7O0FBUU0sU0FBUyxjQUFjLENBQUMsTUFBTSxFQUFFO0FBQ3JDLE1BQUksVUFBVSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDckMsTUFBSSxLQUFLLEdBQUcsU0FBUyxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ2hELE1BQUksV0FBVyxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQzs7QUFFcEMsU0FBTyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7Q0FDNUIiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIixudWxsLCJcclxuLypcclxuICogS29udmEgSmF2YVNjcmlwdCBGcmFtZXdvcmsgdjAuMTAuMFxyXG4gKiBodHRwOi8va29udmFqcy5naXRodWIuaW8vXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgb3IgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cclxuICogRGF0ZTogVHVlIE9jdCAyNyAyMDE1XHJcbiAqXHJcbiAqIE9yaWdpbmFsIHdvcmsgQ29weXJpZ2h0IChDKSAyMDExIC0gMjAxMyBieSBFcmljIFJvd2VsbCAoS2luZXRpY0pTKVxyXG4gKiBNb2RpZmllZCB3b3JrIENvcHlyaWdodCAoQykgMjAxNCAtIDIwMTUgYnkgQW50b24gTGF2cmVub3YgKEtvbnZhKVxyXG4gKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcclxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xyXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gKlxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxyXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICpcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG4gKiBUSEUgU09GVFdBUkUuXHJcbiAqL1xyXG4vKipcclxuICogQG5hbWVzcGFjZSBLb252YVxyXG4gKi9cclxudmFyIEtvbnZhID0ge307XHJcbihmdW5jdGlvbihyb290KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB2YXIgUElfT1ZFUl8xODAgPSBNYXRoLlBJIC8gMTgwO1xyXG5cclxuICAgIEtvbnZhID0ge1xyXG4gICAgICAgIC8vIHB1YmxpY1xyXG4gICAgICAgIHZlcnNpb246ICcwLjEwLjAnLFxyXG5cclxuICAgICAgICAvLyBwcml2YXRlXHJcbiAgICAgICAgc3RhZ2VzOiBbXSxcclxuICAgICAgICBpZENvdW50ZXI6IDAsXHJcbiAgICAgICAgaWRzOiB7fSxcclxuICAgICAgICBuYW1lczoge30sXHJcbiAgICAgICAgc2hhcGVzOiB7fSxcclxuICAgICAgICBsaXN0ZW5DbGlja1RhcDogZmFsc2UsXHJcbiAgICAgICAgaW5EYmxDbGlja1dpbmRvdzogZmFsc2UsXHJcblxyXG4gICAgICAgIC8vIGNvbmZpZ3VyYXRpb25zXHJcbiAgICAgICAgZW5hYmxlVHJhY2U6IGZhbHNlLFxyXG4gICAgICAgIHRyYWNlQXJyTWF4OiAxMDAsXHJcbiAgICAgICAgZGJsQ2xpY2tXaW5kb3c6IDQwMCxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHbG9iYWwgcGl4ZWwgcmF0aW8gY29uZmlndXJhdGlvbi4gS29udmFKUyBhdXRvbWF0aWNhbGx5IGRldGVjdCBwaXhlbCByYXRpbyBvZiBjdXJyZW50IGRldmljZS5cclxuICAgICAgICAgKiBCdXQgeW91IG1heSBvdmVycmlkZSBzdWNoIHByb3BlcnR5LCBpZiB5b3Ugd2FudCB0byB1c2UgeW91ciB2YWx1ZS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgcGl4ZWxSYXRpb1xyXG4gICAgICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YVxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogS29udmEucGl4ZWxSYXRpbyA9IDE7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGl4ZWxSYXRpbzogdW5kZWZpbmVkLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERyYWcgZGlzdGFuY2UgcHJvcGVydHkuIElmIHlvdSBzdGFydCB0byBkcmFnIGEgbm9kZSB5b3UgbWF5IHdhbnQgdG8gd2FpdCB1bnRpbCBwb2ludGVyIGlzIG1vdmVkIHRvIHNvbWUgZGlzdGFuY2UgZnJvbSBzdGFydCBwb2ludCxcclxuICAgICAgICAgKiBvbmx5IHRoZW4gc3RhcnQgZHJhZ2dpbmcuXHJcbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdEaXN0YW5jZVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmFcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqIEtvbnZhLmRyYWdEaXN0YW5jZSA9IDEwO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRyYWdEaXN0YW5jZTogMCxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVc2UgZGVncmVlIHZhbHVlcyBmb3IgYW5nbGUgcHJvcGVydGllcy4gWW91IG1heSBzZXQgdGhpcyBwcm9wZXJ0eSB0byBmYWxzZSBpZiB5b3Ugd2FudCB0byB1c2UgcmFkaWFudCB2YWx1ZXMuXHJcbiAgICAgICAgICogQHByb3BlcnR5IGFuZ2xlRGVnXHJcbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YVxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogbm9kZS5yb3RhdGlvbig0NSk7IC8vIDQ1IGRlZ3JlZXNcclxuICAgICAgICAgKiBLb252YS5hbmdsZURlZyA9IGZhbHNlO1xyXG4gICAgICAgICAqIG5vZGUucm90YXRpb24oTWF0aC5QSSAvIDIpOyAvLyBQSS8yIHJhZGlhblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFuZ2xlRGVnOiB0cnVlLFxyXG4gICAgICAgICAvKipcclxuICAgICAgICAgKiBTaG93IGRpZmZlcmVudCB3YXJuaW5ncyBhYm91dCBlcnJvcnMgb3Igd3JvbmcgQVBJIHVzYWdlXHJcbiAgICAgICAgICogQHByb3BlcnR5IHNob3dXYXJuaW5nc1xyXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmFcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqIEtvbnZhLnNob3dXYXJuaW5ncyA9IGZhbHNlO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNob3dXYXJuaW5nczogdHJ1ZSxcclxuXHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbmFtZXNwYWNlIEZpbHRlcnNcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmFcclxuICAgICAgICAgKi9cclxuICAgICAgICBGaWx0ZXJzOiB7fSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogcmV0dXJucyB3aGV0aGVyIG9yIG5vdCBkcmFnIGFuZCBkcm9wIGlzIGN1cnJlbnRseSBhY3RpdmVcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNEcmFnZ2luZzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBkZCA9IEtvbnZhLkREO1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgREQgaXMgbm90IGluY2x1ZGVkIHdpdGggdGhlIGJ1aWxkLCB0aGVuXHJcbiAgICAgICAgICAgIC8vIGRyYWcgYW5kIGRyb3AgaXMgbm90IGV2ZW4gcG9zc2libGVcclxuICAgICAgICAgICAgaWYgKGRkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGQuaXNEcmFnZ2luZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAqIHJldHVybnMgd2hldGhlciBvciBub3QgYSBkcmFnIGFuZCBkcm9wIG9wZXJhdGlvbiBpcyByZWFkeSwgYnV0IG1heVxyXG4gICAgICAgICogIG5vdCBuZWNlc3NhcmlseSBoYXZlIHN0YXJ0ZWRcclxuICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YVxyXG4gICAgICAgICovXHJcbiAgICAgICAgaXNEcmFnUmVhZHk6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgZGQgPSBLb252YS5ERDtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIEREIGlzIG5vdCBpbmNsdWRlZCB3aXRoIHRoZSBidWlsZCwgdGhlblxyXG4gICAgICAgICAgICAvLyBkcmFnIGFuZCBkcm9wIGlzIG5vdCBldmVuIHBvc3NpYmxlXHJcbiAgICAgICAgICAgIGlmIChkZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEhZGQubm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfYWRkSWQ6IGZ1bmN0aW9uKG5vZGUsIGlkKSB7XHJcbiAgICAgICAgICAgIGlmKGlkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9yZW1vdmVJZDogZnVuY3Rpb24oaWQpIHtcclxuICAgICAgICAgICAgaWYoaWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaWRzW2lkXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2FkZE5hbWU6IGZ1bmN0aW9uKG5vZGUsIG5hbWUpIHtcclxuICAgICAgICAgICAgaWYobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYoIXRoaXMubmFtZXNbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWVzW25hbWVdID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWVzW25hbWVdLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9yZW1vdmVOYW1lOiBmdW5jdGlvbihuYW1lLCBfaWQpIHtcclxuICAgICAgICAgICAgaWYoIW5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLm5hbWVzW25hbWVdO1xyXG4gICAgICAgICAgICBpZighbm9kZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IodmFyIG4gPSAwOyBuIDwgbm9kZXMubGVuZ3RoOyBuKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBubyA9IG5vZGVzW25dO1xyXG4gICAgICAgICAgICAgICAgaWYobm8uX2lkID09PSBfaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UobiwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYobm9kZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5uYW1lc1tuYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0QW5nbGU6IGZ1bmN0aW9uKGFuZ2xlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuZ2xlRGVnID8gYW5nbGUgKiBQSV9PVkVSXzE4MCA6IGFuZ2xlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3BhcnNlVUE6IGZ1bmN0aW9uKHVzZXJBZ2VudCkge1xyXG4gICAgICAgICAgICB2YXIgdWEgPSB1c2VyQWdlbnQudG9Mb3dlckNhc2UoKSxcclxuICAgICAgICAgICAgICAgIC8vIGpRdWVyeSBVQSByZWdleFxyXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSAvKGNocm9tZSlbIFxcL10oW1xcdy5dKykvLmV4ZWMoIHVhICkgfHxcclxuICAgICAgICAgICAgICAgIC8od2Via2l0KVsgXFwvXShbXFx3Ll0rKS8uZXhlYyggdWEgKSB8fFxyXG4gICAgICAgICAgICAgICAgLyhvcGVyYSkoPzouKnZlcnNpb258KVsgXFwvXShbXFx3Ll0rKS8uZXhlYyggdWEgKSB8fFxyXG4gICAgICAgICAgICAgICAgLyhtc2llKSAoW1xcdy5dKykvLmV4ZWMoIHVhICkgfHxcclxuICAgICAgICAgICAgICAgIHVhLmluZGV4T2YoJ2NvbXBhdGlibGUnKSA8IDAgJiYgLyhtb3ppbGxhKSg/Oi4qPyBydjooW1xcdy5dKyl8KS8uZXhlYyggdWEgKSB8fFxyXG4gICAgICAgICAgICAgICAgW10sXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gYWRkaW5nIG1vYmlsZSBmbGFnIGFzIHdlbGxcclxuICAgICAgICAgICAgICAgIG1vYmlsZSA9ICEhKHVzZXJBZ2VudC5tYXRjaCgvQW5kcm9pZHxCbGFja0JlcnJ5fGlQaG9uZXxpUGFkfGlQb2R8T3BlcmEgTWluaXxJRU1vYmlsZS9pKSksXHJcbiAgICAgICAgICAgICAgICBpZU1vYmlsZSA9ICEhKHVzZXJBZ2VudC5tYXRjaCgvSUVNb2JpbGUvaSkpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGJyb3dzZXI6IG1hdGNoWyAxIF0gfHwgJycsXHJcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBtYXRjaFsgMiBdIHx8ICcwJyxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBhZGRpbmcgbW9iaWxlIGZsYWJcclxuICAgICAgICAgICAgICAgIG1vYmlsZTogbW9iaWxlLFxyXG4gICAgICAgICAgICAgICAgaWVNb2JpbGU6IGllTW9iaWxlICAvLyBJZiB0aGlzIGlzIHRydWUgKGkuZS4sIFdQOCksIHRoZW4gS29udmEgdG91Y2ggZXZlbnRzIGFyZSBleGVjdXRlZCBpbnN0ZWFkIG9mIGVxdWl2YWxlbnQgS29udmEgbW91c2UgZXZlbnRzXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyB1c2VyIGFnZW50XHJcbiAgICAgICAgVUE6IHVuZGVmaW5lZFxyXG4gICAgfTtcclxuXHJcbiAgICBLb252YS5VQSA9IEtvbnZhLl9wYXJzZVVBKChyb290Lm5hdmlnYXRvciAmJiByb290Lm5hdmlnYXRvci51c2VyQWdlbnQpIHx8ICcnKTtcclxuXHJcbn0pKHRoaXMpO1xyXG5cclxuLy8gVXNlcyBOb2RlLCBBTUQgb3IgYnJvd3NlciBnbG9iYWxzIHRvIGNyZWF0ZSBhIG1vZHVsZS5cclxuXHJcbi8vIElmIHlvdSB3YW50IHNvbWV0aGluZyB0aGF0IHdpbGwgd29yayBpbiBvdGhlciBzdHJpY3RlciBDb21tb25KUyBlbnZpcm9ubWVudHMsXHJcbi8vIG9yIGlmIHlvdSBuZWVkIHRvIGNyZWF0ZSBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNlZSBjb21tb25Kc1N0cmljdC5qc1xyXG5cclxuLy8gRGVmaW5lcyBhIG1vZHVsZSBcInJldHVybkV4cG9ydHNcIiB0aGF0IGRlcGVuZHMgYW5vdGhlciBtb2R1bGUgY2FsbGVkIFwiYlwiLlxyXG4vLyBOb3RlIHRoYXQgdGhlIG5hbWUgb2YgdGhlIG1vZHVsZSBpcyBpbXBsaWVkIGJ5IHRoZSBmaWxlIG5hbWUuIEl0IGlzIGJlc3RcclxuLy8gaWYgdGhlIGZpbGUgbmFtZSBhbmQgdGhlIGV4cG9ydGVkIGdsb2JhbCBoYXZlIG1hdGNoaW5nIG5hbWVzLlxyXG5cclxuLy8gSWYgdGhlICdiJyBtb2R1bGUgYWxzbyB1c2VzIHRoaXMgdHlwZSBvZiBib2lsZXJwbGF0ZSwgdGhlblxyXG4vLyBpbiB0aGUgYnJvd3NlciwgaXQgd2lsbCBjcmVhdGUgYSBnbG9iYWwgLmIgdGhhdCBpcyB1c2VkIGJlbG93LlxyXG5cclxuLy8gSWYgeW91IGRvIG5vdCB3YW50IHRvIHN1cHBvcnQgdGhlIGJyb3dzZXIgZ2xvYmFsIHBhdGgsIHRoZW4geW91XHJcbi8vIGNhbiByZW1vdmUgdGhlIGByb290YCB1c2UgYW5kIHRoZSBwYXNzaW5nIGB0aGlzYCBhcyB0aGUgZmlyc3QgYXJnIHRvXHJcbi8vIHRoZSB0b3AgZnVuY3Rpb24uXHJcblxyXG4vLyBpZiB0aGUgbW9kdWxlIGhhcyBubyBkZXBlbmRlbmNpZXMsIHRoZSBhYm92ZSBwYXR0ZXJuIGNhbiBiZSBzaW1wbGlmaWVkIHRvXHJcbiggZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgaWYoIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHZhciBLb252YUpTID0gZmFjdG9yeSgpO1xyXG4gICAgICAgIC8vIHJ1bnRpbWUtY2hlY2sgZm9yIGJyb3dzZXJpZnkgYW5kIG53LmpzIChub2RlLXdlYmtpdClcclxuICAgICAgICBpZihnbG9iYWwud2luZG93ICYmIGdsb2JhbC53aW5kb3cuZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgS29udmEuZG9jdW1lbnQgPSBnbG9iYWwud2luZG93LmRvY3VtZW50O1xyXG4gICAgICAgICAgICBLb252YS53aW5kb3cgPSBnbG9iYWwud2luZG93O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxyXG4gICAgICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxyXG4gICAgICAgICAgICAvLyBsaWtlIE5vZGUuXHJcbiAgICAgICAgICAgIHZhciBDYW52YXMgPSByZXF1aXJlKCdjYW52YXMnKTtcclxuICAgICAgICAgICAgdmFyIGpzZG9tID0gcmVxdWlyZSgnanNkb20nKS5qc2RvbTtcclxuXHJcbiAgICAgICAgICAgIEtvbnZhLmRvY3VtZW50ID0ganNkb20oJzwhRE9DVFlQRSBodG1sPjxodG1sPjxoZWFkPjwvaGVhZD48Ym9keT48L2JvZHk+PC9odG1sPicpO1xyXG4gICAgICAgICAgICBLb252YS53aW5kb3cgPSBLb252YS5kb2N1bWVudC5wYXJlbnRXaW5kb3c7XHJcbiAgICAgICAgICAgIEtvbnZhLndpbmRvdy5JbWFnZSA9IENhbnZhcy5JbWFnZTtcclxuICAgICAgICAgICAgS29udmEuX25vZGVDYW52YXMgPSBDYW52YXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBLb252YS5yb290ID0gcm9vdDtcclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEtvbnZhSlM7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxyXG4gICAgICAgIGRlZmluZShmYWN0b3J5KTtcclxuICAgIH1cclxuICAgIEtvbnZhLmRvY3VtZW50ID0gZG9jdW1lbnQ7XHJcbiAgICBLb252YS53aW5kb3cgPSB3aW5kb3c7XHJcbiAgICBLb252YS5yb290ID0gcm9vdDtcclxufSh0aGlzLCBmdW5jdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8vIEp1c3QgcmV0dXJuIGEgdmFsdWUgdG8gZGVmaW5lIHRoZSBtb2R1bGUgZXhwb3J0LlxyXG4gICAgLy8gVGhpcyBleGFtcGxlIHJldHVybnMgYW4gb2JqZWN0LCBidXQgdGhlIG1vZHVsZVxyXG4gICAgLy8gY2FuIHJldHVybiBhIGZ1bmN0aW9uIGFzIHRoZSBleHBvcnRlZCB2YWx1ZS5cclxuICAgIHJldHVybiBLb252YTtcclxufSkpO1xyXG5cbi8qZXNsaW50LWRpc2FibGUgIGVxZXFlcSwgbm8tY29uZC1hc3NpZ24sIG5vLWVtcHR5Ki9cclxuKGZ1bmN0aW9uKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsZWN0aW9uIGNvbnN0cnVjdG9yLiAgQ29sbGVjdGlvbiBleHRlbmRzXHJcbiAgICAgKiAgQXJyYXkuICBUaGlzIGNsYXNzIGlzIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB7QGxpbmsgS29udmEuQ29udGFpbmVyI2dldH1cclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXHJcbiAgICAgKi9cclxuICAgIEtvbnZhLkNvbGxlY3Rpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwgbGVuZ3RoID0gYXJncy5sZW5ndGgsIGkgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcclxuICAgICAgICBmb3IoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpc1tpXSA9IGFyZ3NbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIEtvbnZhLkNvbGxlY3Rpb24ucHJvdG90eXBlID0gW107XHJcbiAgICAvKipcclxuICAgICAqIGl0ZXJhdGUgdGhyb3VnaCBub2RlIGFycmF5IGFuZCBydW4gYSBmdW5jdGlvbiBmb3IgZWFjaCBub2RlLlxyXG4gICAgICogIFRoZSBub2RlIGFuZCBpbmRleCBpcyBwYXNzZWQgaW50byB0aGUgZnVuY3Rpb25cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db2xsZWN0aW9uLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBhbGwgbm9kZXMgd2l0aCBuYW1lIGZvbyBpbnNpZGUgbGF5ZXIsIGFuZCBzZXQgeCB0byAxMCBmb3IgZWFjaFxyXG4gICAgICogbGF5ZXIuZ2V0KCcuZm9vJykuZWFjaChmdW5jdGlvbihzaGFwZSwgbikge1xyXG4gICAgICogICBzaGFwZS5zZXRYKDEwKTtcclxuICAgICAqIH0pO1xyXG4gICAgICovXHJcbiAgICBLb252YS5Db2xsZWN0aW9uLnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24oZnVuYykge1xyXG4gICAgICAgIGZvcih2YXIgbiA9IDA7IG4gPCB0aGlzLmxlbmd0aDsgbisrKSB7XHJcbiAgICAgICAgICAgIGZ1bmModGhpc1tuXSwgbik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogY29udmVydCBjb2xsZWN0aW9uIGludG8gYW4gYXJyYXlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db2xsZWN0aW9uLnByb3RvdHlwZVxyXG4gICAgICovXHJcbiAgICBLb252YS5Db2xsZWN0aW9uLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGFyciA9IFtdLFxyXG4gICAgICAgICAgICBsZW4gPSB0aGlzLmxlbmd0aCxcclxuICAgICAgICAgICAgbjtcclxuXHJcbiAgICAgICAgZm9yKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcclxuICAgICAgICAgICAgYXJyLnB1c2godGhpc1tuXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnI7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBjb252ZXJ0IGFycmF5IGludG8gYSBjb2xsZWN0aW9uXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29sbGVjdGlvblxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXHJcbiAgICAgKi9cclxuICAgIEtvbnZhLkNvbGxlY3Rpb24udG9Db2xsZWN0aW9uID0gZnVuY3Rpb24oYXJyKSB7XHJcbiAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSBuZXcgS29udmEuQ29sbGVjdGlvbigpLFxyXG4gICAgICAgICAgICBsZW4gPSBhcnIubGVuZ3RoLFxyXG4gICAgICAgICAgICBuO1xyXG5cclxuICAgICAgICBmb3IobiA9IDA7IG4gPCBsZW47IG4rKykge1xyXG4gICAgICAgICAgICBjb2xsZWN0aW9uLnB1c2goYXJyW25dKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIG1hcCBvbmUgbWV0aG9kIGJ5IGl0J3MgbmFtZVxyXG4gICAgS29udmEuQ29sbGVjdGlvbi5fbWFwTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kTmFtZSkge1xyXG4gICAgICAgIEtvbnZhLkNvbGxlY3Rpb24ucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGk7XHJcblxyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXNbaV1bbWV0aG9kTmFtZV0uYXBwbHkodGhpc1tpXSwgYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyA9IGZ1bmN0aW9uKGNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgdmFyIHByb3QgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XHJcbiAgICAgICAgZm9yKHZhciBtZXRob2ROYW1lIGluIHByb3QpIHtcclxuICAgICAgICAgICAgS29udmEuQ29sbGVjdGlvbi5fbWFwTWV0aG9kKG1ldGhvZE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLypcclxuICAgICogTGFzdCB1cGRhdGVkIE5vdmVtYmVyIDIwMTFcclxuICAgICogQnkgU2ltb24gU2FycmlzXHJcbiAgICAqIHd3dy5zaW1vbnNhcnJpcy5jb21cclxuICAgICogc2FycmlzQGFjbS5vcmdcclxuICAgICpcclxuICAgICogRnJlZSB0byB1c2UgYW5kIGRpc3RyaWJ1dGUgYXQgd2lsbFxyXG4gICAgKiBTbyBsb25nIGFzIHlvdSBhcmUgbmljZSB0byBwZW9wbGUsIGV0Y1xyXG4gICAgKi9cclxuXHJcbiAgICAvKlxyXG4gICAgKiBUaGUgdXNhZ2Ugb2YgdGhpcyBjbGFzcyB3YXMgaW5zcGlyZWQgYnkgc29tZSBvZiB0aGUgd29yayBkb25lIGJ5IGEgZm9ya2VkXHJcbiAgICAqIHByb2plY3QsIEtpbmV0aWNKUy1FeHQgYnkgV2FwcHdvcmtzLCB3aGljaCBpcyBiYXNlZCBvbiBTaW1vbidzIFRyYW5zZm9ybVxyXG4gICAgKiBjbGFzcy4gIE1vZGlmaWVkIGJ5IEVyaWMgUm93ZWxsXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtIGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFttXSBPcHRpb25hbCBzaXgtZWxlbWVudCBtYXRyaXhcclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxyXG4gICAgICovXHJcbiAgICBLb252YS5UcmFuc2Zvcm0gPSBmdW5jdGlvbihtKSB7XHJcbiAgICAgICAgdGhpcy5tID0gKG0gJiYgbS5zbGljZSgpKSB8fCBbMSwgMCwgMCwgMSwgMCwgMF07XHJcbiAgICB9O1xyXG5cclxuICAgIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29weSBLb252YS5UcmFuc2Zvcm0gb2JqZWN0XHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb3B5OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBLb252YS5UcmFuc2Zvcm0odGhpcy5tKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyYW5zZm9ybSBwb2ludFxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludCAyRCBwb2ludCh4LCB5KVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IDJEIHBvaW50KHgsIHkpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XHJcbiAgICAgICAgICAgIHZhciBtID0gdGhpcy5tO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgeDogbVswXSAqIHBvaW50LnggKyBtWzJdICogcG9pbnQueSArIG1bNF0sXHJcbiAgICAgICAgICAgICAgICB5OiBtWzFdICogcG9pbnQueCArIG1bM10gKiBwb2ludC55ICsgbVs1XVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbHkgdHJhbnNsYXRpb25cclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geFxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XHJcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgICAgICAgdGhpcy5tWzRdICs9IHRoaXMubVswXSAqIHggKyB0aGlzLm1bMl0gKiB5O1xyXG4gICAgICAgICAgICB0aGlzLm1bNV0gKz0gdGhpcy5tWzFdICogeCArIHRoaXMubVszXSAqIHk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbHkgc2NhbGVcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3hcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3lcclxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuVHJhbnNmb3JtfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNjYWxlOiBmdW5jdGlvbihzeCwgc3kpIHtcclxuICAgICAgICAgICAgdGhpcy5tWzBdICo9IHN4O1xyXG4gICAgICAgICAgICB0aGlzLm1bMV0gKj0gc3g7XHJcbiAgICAgICAgICAgIHRoaXMubVsyXSAqPSBzeTtcclxuICAgICAgICAgICAgdGhpcy5tWzNdICo9IHN5O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGx5IHJvdGF0aW9uXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZCAgQW5nbGUgaW4gcmFkaWFuc1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcm90YXRlOiBmdW5jdGlvbihyYWQpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xyXG4gICAgICAgICAgICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XHJcbiAgICAgICAgICAgIHZhciBtMTEgPSB0aGlzLm1bMF0gKiBjICsgdGhpcy5tWzJdICogcztcclxuICAgICAgICAgICAgdmFyIG0xMiA9IHRoaXMubVsxXSAqIGMgKyB0aGlzLm1bM10gKiBzO1xyXG4gICAgICAgICAgICB2YXIgbTIxID0gdGhpcy5tWzBdICogLXMgKyB0aGlzLm1bMl0gKiBjO1xyXG4gICAgICAgICAgICB2YXIgbTIyID0gdGhpcy5tWzFdICogLXMgKyB0aGlzLm1bM10gKiBjO1xyXG4gICAgICAgICAgICB0aGlzLm1bMF0gPSBtMTE7XHJcbiAgICAgICAgICAgIHRoaXMubVsxXSA9IG0xMjtcclxuICAgICAgICAgICAgdGhpcy5tWzJdID0gbTIxO1xyXG4gICAgICAgICAgICB0aGlzLm1bM10gPSBtMjI7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgdHJhbnNsYXRpb25cclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSAyRCBwb2ludCh4LCB5KVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFRyYW5zbGF0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHg6IHRoaXMubVs0XSxcclxuICAgICAgICAgICAgICAgIHk6IHRoaXMubVs1XVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbHkgc2tld1xyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzeFxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzeVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2tldzogZnVuY3Rpb24oc3gsIHN5KSB7XHJcbiAgICAgICAgICAgIHZhciBtMTEgPSB0aGlzLm1bMF0gKyB0aGlzLm1bMl0gKiBzeTtcclxuICAgICAgICAgICAgdmFyIG0xMiA9IHRoaXMubVsxXSArIHRoaXMubVszXSAqIHN5O1xyXG4gICAgICAgICAgICB2YXIgbTIxID0gdGhpcy5tWzJdICsgdGhpcy5tWzBdICogc3g7XHJcbiAgICAgICAgICAgIHZhciBtMjIgPSB0aGlzLm1bM10gKyB0aGlzLm1bMV0gKiBzeDtcclxuICAgICAgICAgICAgdGhpcy5tWzBdID0gbTExO1xyXG4gICAgICAgICAgICB0aGlzLm1bMV0gPSBtMTI7XHJcbiAgICAgICAgICAgIHRoaXMubVsyXSA9IG0yMTtcclxuICAgICAgICAgICAgdGhpcy5tWzNdID0gbTIyO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmFuc2Zvcm0gbXVsdGlwbGljYXRpb25cclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge0tvbnZhLlRyYW5zZm9ybX0gbWF0cml4XHJcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBtdWx0aXBseTogZnVuY3Rpb24obWF0cml4KSB7XHJcbiAgICAgICAgICAgIHZhciBtMTEgPSB0aGlzLm1bMF0gKiBtYXRyaXgubVswXSArIHRoaXMubVsyXSAqIG1hdHJpeC5tWzFdO1xyXG4gICAgICAgICAgICB2YXIgbTEyID0gdGhpcy5tWzFdICogbWF0cml4Lm1bMF0gKyB0aGlzLm1bM10gKiBtYXRyaXgubVsxXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBtMjEgPSB0aGlzLm1bMF0gKiBtYXRyaXgubVsyXSArIHRoaXMubVsyXSAqIG1hdHJpeC5tWzNdO1xyXG4gICAgICAgICAgICB2YXIgbTIyID0gdGhpcy5tWzFdICogbWF0cml4Lm1bMl0gKyB0aGlzLm1bM10gKiBtYXRyaXgubVszXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkeCA9IHRoaXMubVswXSAqIG1hdHJpeC5tWzRdICsgdGhpcy5tWzJdICogbWF0cml4Lm1bNV0gKyB0aGlzLm1bNF07XHJcbiAgICAgICAgICAgIHZhciBkeSA9IHRoaXMubVsxXSAqIG1hdHJpeC5tWzRdICsgdGhpcy5tWzNdICogbWF0cml4Lm1bNV0gKyB0aGlzLm1bNV07XHJcblxyXG4gICAgICAgICAgICB0aGlzLm1bMF0gPSBtMTE7XHJcbiAgICAgICAgICAgIHRoaXMubVsxXSA9IG0xMjtcclxuICAgICAgICAgICAgdGhpcy5tWzJdID0gbTIxO1xyXG4gICAgICAgICAgICB0aGlzLm1bM10gPSBtMjI7XHJcbiAgICAgICAgICAgIHRoaXMubVs0XSA9IGR4O1xyXG4gICAgICAgICAgICB0aGlzLm1bNV0gPSBkeTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnZlcnQgdGhlIG1hdHJpeFxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW52ZXJ0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGQgPSAxIC8gKHRoaXMubVswXSAqIHRoaXMubVszXSAtIHRoaXMubVsxXSAqIHRoaXMubVsyXSk7XHJcbiAgICAgICAgICAgIHZhciBtMCA9IHRoaXMubVszXSAqIGQ7XHJcbiAgICAgICAgICAgIHZhciBtMSA9IC10aGlzLm1bMV0gKiBkO1xyXG4gICAgICAgICAgICB2YXIgbTIgPSAtdGhpcy5tWzJdICogZDtcclxuICAgICAgICAgICAgdmFyIG0zID0gdGhpcy5tWzBdICogZDtcclxuICAgICAgICAgICAgdmFyIG00ID0gZCAqICh0aGlzLm1bMl0gKiB0aGlzLm1bNV0gLSB0aGlzLm1bM10gKiB0aGlzLm1bNF0pO1xyXG4gICAgICAgICAgICB2YXIgbTUgPSBkICogKHRoaXMubVsxXSAqIHRoaXMubVs0XSAtIHRoaXMubVswXSAqIHRoaXMubVs1XSk7XHJcbiAgICAgICAgICAgIHRoaXMubVswXSA9IG0wO1xyXG4gICAgICAgICAgICB0aGlzLm1bMV0gPSBtMTtcclxuICAgICAgICAgICAgdGhpcy5tWzJdID0gbTI7XHJcbiAgICAgICAgICAgIHRoaXMubVszXSA9IG0zO1xyXG4gICAgICAgICAgICB0aGlzLm1bNF0gPSBtNDtcclxuICAgICAgICAgICAgdGhpcy5tWzVdID0gbTU7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogcmV0dXJuIG1hdHJpeFxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldE1hdHJpeDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm07XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBzZXQgdG8gYWJzb2x1dGUgcG9zaXRpb24gdmlhIHRyYW5zbGF0aW9uXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cclxuICAgICAgICAgKiBAYXV0aG9yIGVyaWNkcm93ZWxsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0QWJzb2x1dGVQb3NpdGlvbjogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICAgICAgICB2YXIgbTAgPSB0aGlzLm1bMF0sXHJcbiAgICAgICAgICAgICAgICBtMSA9IHRoaXMubVsxXSxcclxuICAgICAgICAgICAgICAgIG0yID0gdGhpcy5tWzJdLFxyXG4gICAgICAgICAgICAgICAgbTMgPSB0aGlzLm1bM10sXHJcbiAgICAgICAgICAgICAgICBtNCA9IHRoaXMubVs0XSxcclxuICAgICAgICAgICAgICAgIG01ID0gdGhpcy5tWzVdLFxyXG4gICAgICAgICAgICAgICAgeXQgPSAoKG0wICogKHkgLSBtNSkpIC0gKG0xICogKHggLSBtNCkpKSAvICgobTAgKiBtMykgLSAobTEgKiBtMikpLFxyXG4gICAgICAgICAgICAgICAgeHQgPSAoeCAtIG00IC0gKG0yICogeXQpKSAvIG0wO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlKHh0LCB5dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBDT05TVEFOVFNcclxuICAgIHZhciBDT05URVhUXzJEID0gJzJkJyxcclxuICAgICAgICBPQkpFQ1RfQVJSQVkgPSAnW29iamVjdCBBcnJheV0nLFxyXG4gICAgICAgIE9CSkVDVF9OVU1CRVIgPSAnW29iamVjdCBOdW1iZXJdJyxcclxuICAgICAgICBPQkpFQ1RfU1RSSU5HID0gJ1tvYmplY3QgU3RyaW5nXScsXHJcbiAgICAgICAgUElfT1ZFUl9ERUcxODAgPSBNYXRoLlBJIC8gMTgwLFxyXG4gICAgICAgIERFRzE4MF9PVkVSX1BJID0gMTgwIC8gTWF0aC5QSSxcclxuICAgICAgICBIQVNIID0gJyMnLFxyXG4gICAgICAgIEVNUFRZX1NUUklORyA9ICcnLFxyXG4gICAgICAgIFpFUk8gPSAnMCcsXHJcbiAgICAgICAgS09OVkFfV0FSTklORyA9ICdLb252YSB3YXJuaW5nOiAnLFxyXG4gICAgICAgIEtPTlZBX0VSUk9SID0gJ0tvbnZhIGVycm9yOiAnLFxyXG4gICAgICAgIFJHQl9QQVJFTiA9ICdyZ2IoJyxcclxuICAgICAgICBDT0xPUlMgPSB7XHJcbiAgICAgICAgICAgIGFsaWNlYmx1ZTogWzI0MCwgMjQ4LCAyNTVdLFxyXG4gICAgICAgICAgICBhbnRpcXVld2hpdGU6IFsyNTAsIDIzNSwgMjE1XSxcclxuICAgICAgICAgICAgYXF1YTogWzAsIDI1NSwgMjU1XSxcclxuICAgICAgICAgICAgYXF1YW1hcmluZTogWzEyNywgMjU1LCAyMTJdLFxyXG4gICAgICAgICAgICBhenVyZTogWzI0MCwgMjU1LCAyNTVdLFxyXG4gICAgICAgICAgICBiZWlnZTogWzI0NSwgMjQ1LCAyMjBdLFxyXG4gICAgICAgICAgICBiaXNxdWU6IFsyNTUsIDIyOCwgMTk2XSxcclxuICAgICAgICAgICAgYmxhY2s6IFswLCAwLCAwXSxcclxuICAgICAgICAgICAgYmxhbmNoZWRhbG1vbmQ6IFsyNTUsIDIzNSwgMjA1XSxcclxuICAgICAgICAgICAgYmx1ZTogWzAsIDAsIDI1NV0sXHJcbiAgICAgICAgICAgIGJsdWV2aW9sZXQ6IFsxMzgsIDQzLCAyMjZdLFxyXG4gICAgICAgICAgICBicm93bjogWzE2NSwgNDIsIDQyXSxcclxuICAgICAgICAgICAgYnVybHl3b29kOiBbMjIyLCAxODQsIDEzNV0sXHJcbiAgICAgICAgICAgIGNhZGV0Ymx1ZTogWzk1LCAxNTgsIDE2MF0sXHJcbiAgICAgICAgICAgIGNoYXJ0cmV1c2U6IFsxMjcsIDI1NSwgMF0sXHJcbiAgICAgICAgICAgIGNob2NvbGF0ZTogWzIxMCwgMTA1LCAzMF0sXHJcbiAgICAgICAgICAgIGNvcmFsOiBbMjU1LCAxMjcsIDgwXSxcclxuICAgICAgICAgICAgY29ybmZsb3dlcmJsdWU6IFsxMDAsIDE0OSwgMjM3XSxcclxuICAgICAgICAgICAgY29ybnNpbGs6IFsyNTUsIDI0OCwgMjIwXSxcclxuICAgICAgICAgICAgY3JpbXNvbjogWzIyMCwgMjAsIDYwXSxcclxuICAgICAgICAgICAgY3lhbjogWzAsIDI1NSwgMjU1XSxcclxuICAgICAgICAgICAgZGFya2JsdWU6IFswLCAwLCAxMzldLFxyXG4gICAgICAgICAgICBkYXJrY3lhbjogWzAsIDEzOSwgMTM5XSxcclxuICAgICAgICAgICAgZGFya2dvbGRlbnJvZDogWzE4NCwgMTMyLCAxMV0sXHJcbiAgICAgICAgICAgIGRhcmtncmF5OiBbMTY5LCAxNjksIDE2OV0sXHJcbiAgICAgICAgICAgIGRhcmtncmVlbjogWzAsIDEwMCwgMF0sXHJcbiAgICAgICAgICAgIGRhcmtncmV5OiBbMTY5LCAxNjksIDE2OV0sXHJcbiAgICAgICAgICAgIGRhcmtraGFraTogWzE4OSwgMTgzLCAxMDddLFxyXG4gICAgICAgICAgICBkYXJrbWFnZW50YTogWzEzOSwgMCwgMTM5XSxcclxuICAgICAgICAgICAgZGFya29saXZlZ3JlZW46IFs4NSwgMTA3LCA0N10sXHJcbiAgICAgICAgICAgIGRhcmtvcmFuZ2U6IFsyNTUsIDE0MCwgMF0sXHJcbiAgICAgICAgICAgIGRhcmtvcmNoaWQ6IFsxNTMsIDUwLCAyMDRdLFxyXG4gICAgICAgICAgICBkYXJrcmVkOiBbMTM5LCAwLCAwXSxcclxuICAgICAgICAgICAgZGFya3NhbG1vbjogWzIzMywgMTUwLCAxMjJdLFxyXG4gICAgICAgICAgICBkYXJrc2VhZ3JlZW46IFsxNDMsIDE4OCwgMTQzXSxcclxuICAgICAgICAgICAgZGFya3NsYXRlYmx1ZTogWzcyLCA2MSwgMTM5XSxcclxuICAgICAgICAgICAgZGFya3NsYXRlZ3JheTogWzQ3LCA3OSwgNzldLFxyXG4gICAgICAgICAgICBkYXJrc2xhdGVncmV5OiBbNDcsIDc5LCA3OV0sXHJcbiAgICAgICAgICAgIGRhcmt0dXJxdW9pc2U6IFswLCAyMDYsIDIwOV0sXHJcbiAgICAgICAgICAgIGRhcmt2aW9sZXQ6IFsxNDgsIDAsIDIxMV0sXHJcbiAgICAgICAgICAgIGRlZXBwaW5rOiBbMjU1LCAyMCwgMTQ3XSxcclxuICAgICAgICAgICAgZGVlcHNreWJsdWU6IFswLCAxOTEsIDI1NV0sXHJcbiAgICAgICAgICAgIGRpbWdyYXk6IFsxMDUsIDEwNSwgMTA1XSxcclxuICAgICAgICAgICAgZGltZ3JleTogWzEwNSwgMTA1LCAxMDVdLFxyXG4gICAgICAgICAgICBkb2RnZXJibHVlOiBbMzAsIDE0NCwgMjU1XSxcclxuICAgICAgICAgICAgZmlyZWJyaWNrOiBbMTc4LCAzNCwgMzRdLFxyXG4gICAgICAgICAgICBmbG9yYWx3aGl0ZTogWzI1NSwgMjU1LCAyNDBdLFxyXG4gICAgICAgICAgICBmb3Jlc3RncmVlbjogWzM0LCAxMzksIDM0XSxcclxuICAgICAgICAgICAgZnVjaHNpYTogWzI1NSwgMCwgMjU1XSxcclxuICAgICAgICAgICAgZ2FpbnNib3JvOiBbMjIwLCAyMjAsIDIyMF0sXHJcbiAgICAgICAgICAgIGdob3N0d2hpdGU6IFsyNDgsIDI0OCwgMjU1XSxcclxuICAgICAgICAgICAgZ29sZDogWzI1NSwgMjE1LCAwXSxcclxuICAgICAgICAgICAgZ29sZGVucm9kOiBbMjE4LCAxNjUsIDMyXSxcclxuICAgICAgICAgICAgZ3JheTogWzEyOCwgMTI4LCAxMjhdLFxyXG4gICAgICAgICAgICBncmVlbjogWzAsIDEyOCwgMF0sXHJcbiAgICAgICAgICAgIGdyZWVueWVsbG93OiBbMTczLCAyNTUsIDQ3XSxcclxuICAgICAgICAgICAgZ3JleTogWzEyOCwgMTI4LCAxMjhdLFxyXG4gICAgICAgICAgICBob25leWRldzogWzI0MCwgMjU1LCAyNDBdLFxyXG4gICAgICAgICAgICBob3RwaW5rOiBbMjU1LCAxMDUsIDE4MF0sXHJcbiAgICAgICAgICAgIGluZGlhbnJlZDogWzIwNSwgOTIsIDkyXSxcclxuICAgICAgICAgICAgaW5kaWdvOiBbNzUsIDAsIDEzMF0sXHJcbiAgICAgICAgICAgIGl2b3J5OiBbMjU1LCAyNTUsIDI0MF0sXHJcbiAgICAgICAgICAgIGtoYWtpOiBbMjQwLCAyMzAsIDE0MF0sXHJcbiAgICAgICAgICAgIGxhdmVuZGVyOiBbMjMwLCAyMzAsIDI1MF0sXHJcbiAgICAgICAgICAgIGxhdmVuZGVyYmx1c2g6IFsyNTUsIDI0MCwgMjQ1XSxcclxuICAgICAgICAgICAgbGF3bmdyZWVuOiBbMTI0LCAyNTIsIDBdLFxyXG4gICAgICAgICAgICBsZW1vbmNoaWZmb246IFsyNTUsIDI1MCwgMjA1XSxcclxuICAgICAgICAgICAgbGlnaHRibHVlOiBbMTczLCAyMTYsIDIzMF0sXHJcbiAgICAgICAgICAgIGxpZ2h0Y29yYWw6IFsyNDAsIDEyOCwgMTI4XSxcclxuICAgICAgICAgICAgbGlnaHRjeWFuOiBbMjI0LCAyNTUsIDI1NV0sXHJcbiAgICAgICAgICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiBbMjUwLCAyNTAsIDIxMF0sXHJcbiAgICAgICAgICAgIGxpZ2h0Z3JheTogWzIxMSwgMjExLCAyMTFdLFxyXG4gICAgICAgICAgICBsaWdodGdyZWVuOiBbMTQ0LCAyMzgsIDE0NF0sXHJcbiAgICAgICAgICAgIGxpZ2h0Z3JleTogWzIxMSwgMjExLCAyMTFdLFxyXG4gICAgICAgICAgICBsaWdodHBpbms6IFsyNTUsIDE4MiwgMTkzXSxcclxuICAgICAgICAgICAgbGlnaHRzYWxtb246IFsyNTUsIDE2MCwgMTIyXSxcclxuICAgICAgICAgICAgbGlnaHRzZWFncmVlbjogWzMyLCAxNzgsIDE3MF0sXHJcbiAgICAgICAgICAgIGxpZ2h0c2t5Ymx1ZTogWzEzNSwgMjA2LCAyNTBdLFxyXG4gICAgICAgICAgICBsaWdodHNsYXRlZ3JheTogWzExOSwgMTM2LCAxNTNdLFxyXG4gICAgICAgICAgICBsaWdodHNsYXRlZ3JleTogWzExOSwgMTM2LCAxNTNdLFxyXG4gICAgICAgICAgICBsaWdodHN0ZWVsYmx1ZTogWzE3NiwgMTk2LCAyMjJdLFxyXG4gICAgICAgICAgICBsaWdodHllbGxvdzogWzI1NSwgMjU1LCAyMjRdLFxyXG4gICAgICAgICAgICBsaW1lOiBbMCwgMjU1LCAwXSxcclxuICAgICAgICAgICAgbGltZWdyZWVuOiBbNTAsIDIwNSwgNTBdLFxyXG4gICAgICAgICAgICBsaW5lbjogWzI1MCwgMjQwLCAyMzBdLFxyXG4gICAgICAgICAgICBtYWdlbnRhOiBbMjU1LCAwLCAyNTVdLFxyXG4gICAgICAgICAgICBtYXJvb246IFsxMjgsIDAsIDBdLFxyXG4gICAgICAgICAgICBtZWRpdW1hcXVhbWFyaW5lOiBbMTAyLCAyMDUsIDE3MF0sXHJcbiAgICAgICAgICAgIG1lZGl1bWJsdWU6IFswLCAwLCAyMDVdLFxyXG4gICAgICAgICAgICBtZWRpdW1vcmNoaWQ6IFsxODYsIDg1LCAyMTFdLFxyXG4gICAgICAgICAgICBtZWRpdW1wdXJwbGU6IFsxNDcsIDExMiwgMjE5XSxcclxuICAgICAgICAgICAgbWVkaXVtc2VhZ3JlZW46IFs2MCwgMTc5LCAxMTNdLFxyXG4gICAgICAgICAgICBtZWRpdW1zbGF0ZWJsdWU6IFsxMjMsIDEwNCwgMjM4XSxcclxuICAgICAgICAgICAgbWVkaXVtc3ByaW5nZ3JlZW46IFswLCAyNTAsIDE1NF0sXHJcbiAgICAgICAgICAgIG1lZGl1bXR1cnF1b2lzZTogWzcyLCAyMDksIDIwNF0sXHJcbiAgICAgICAgICAgIG1lZGl1bXZpb2xldHJlZDogWzE5OSwgMjEsIDEzM10sXHJcbiAgICAgICAgICAgIG1pZG5pZ2h0Ymx1ZTogWzI1LCAyNSwgMTEyXSxcclxuICAgICAgICAgICAgbWludGNyZWFtOiBbMjQ1LCAyNTUsIDI1MF0sXHJcbiAgICAgICAgICAgIG1pc3R5cm9zZTogWzI1NSwgMjI4LCAyMjVdLFxyXG4gICAgICAgICAgICBtb2NjYXNpbjogWzI1NSwgMjI4LCAxODFdLFxyXG4gICAgICAgICAgICBuYXZham93aGl0ZTogWzI1NSwgMjIyLCAxNzNdLFxyXG4gICAgICAgICAgICBuYXZ5OiBbMCwgMCwgMTI4XSxcclxuICAgICAgICAgICAgb2xkbGFjZTogWzI1MywgMjQ1LCAyMzBdLFxyXG4gICAgICAgICAgICBvbGl2ZTogWzEyOCwgMTI4LCAwXSxcclxuICAgICAgICAgICAgb2xpdmVkcmFiOiBbMTA3LCAxNDIsIDM1XSxcclxuICAgICAgICAgICAgb3JhbmdlOiBbMjU1LCAxNjUsIDBdLFxyXG4gICAgICAgICAgICBvcmFuZ2VyZWQ6IFsyNTUsIDY5LCAwXSxcclxuICAgICAgICAgICAgb3JjaGlkOiBbMjE4LCAxMTIsIDIxNF0sXHJcbiAgICAgICAgICAgIHBhbGVnb2xkZW5yb2Q6IFsyMzgsIDIzMiwgMTcwXSxcclxuICAgICAgICAgICAgcGFsZWdyZWVuOiBbMTUyLCAyNTEsIDE1Ml0sXHJcbiAgICAgICAgICAgIHBhbGV0dXJxdW9pc2U6IFsxNzUsIDIzOCwgMjM4XSxcclxuICAgICAgICAgICAgcGFsZXZpb2xldHJlZDogWzIxOSwgMTEyLCAxNDddLFxyXG4gICAgICAgICAgICBwYXBheWF3aGlwOiBbMjU1LCAyMzksIDIxM10sXHJcbiAgICAgICAgICAgIHBlYWNocHVmZjogWzI1NSwgMjE4LCAxODVdLFxyXG4gICAgICAgICAgICBwZXJ1OiBbMjA1LCAxMzMsIDYzXSxcclxuICAgICAgICAgICAgcGluazogWzI1NSwgMTkyLCAyMDNdLFxyXG4gICAgICAgICAgICBwbHVtOiBbMjIxLCAxNjAsIDIwM10sXHJcbiAgICAgICAgICAgIHBvd2RlcmJsdWU6IFsxNzYsIDIyNCwgMjMwXSxcclxuICAgICAgICAgICAgcHVycGxlOiBbMTI4LCAwLCAxMjhdLFxyXG4gICAgICAgICAgICByZWJlY2NhcHVycGxlOiBbMTAyLCA1MSwgMTUzXSxcclxuICAgICAgICAgICAgcmVkOiBbMjU1LCAwLCAwXSxcclxuICAgICAgICAgICAgcm9zeWJyb3duOiBbMTg4LCAxNDMsIDE0M10sXHJcbiAgICAgICAgICAgIHJveWFsYmx1ZTogWzY1LCAxMDUsIDIyNV0sXHJcbiAgICAgICAgICAgIHNhZGRsZWJyb3duOiBbMTM5LCA2OSwgMTldLFxyXG4gICAgICAgICAgICBzYWxtb246IFsyNTAsIDEyOCwgMTE0XSxcclxuICAgICAgICAgICAgc2FuZHlicm93bjogWzI0NCwgMTY0LCA5Nl0sXHJcbiAgICAgICAgICAgIHNlYWdyZWVuOiBbNDYsIDEzOSwgODddLFxyXG4gICAgICAgICAgICBzZWFzaGVsbDogWzI1NSwgMjQ1LCAyMzhdLFxyXG4gICAgICAgICAgICBzaWVubmE6IFsxNjAsIDgyLCA0NV0sXHJcbiAgICAgICAgICAgIHNpbHZlcjogWzE5MiwgMTkyLCAxOTJdLFxyXG4gICAgICAgICAgICBza3libHVlOiBbMTM1LCAyMDYsIDIzNV0sXHJcbiAgICAgICAgICAgIHNsYXRlYmx1ZTogWzEwNiwgOTAsIDIwNV0sXHJcbiAgICAgICAgICAgIHNsYXRlZ3JheTogWzExOSwgMTI4LCAxNDRdLFxyXG4gICAgICAgICAgICBzbGF0ZWdyZXk6IFsxMTksIDEyOCwgMTQ0XSxcclxuICAgICAgICAgICAgc25vdzogWzI1NSwgMjU1LCAyNTBdLFxyXG4gICAgICAgICAgICBzcHJpbmdncmVlbjogWzAsIDI1NSwgMTI3XSxcclxuICAgICAgICAgICAgc3RlZWxibHVlOiBbNzAsIDEzMCwgMTgwXSxcclxuICAgICAgICAgICAgdGFuOiBbMjEwLCAxODAsIDE0MF0sXHJcbiAgICAgICAgICAgIHRlYWw6IFswLCAxMjgsIDEyOF0sXHJcbiAgICAgICAgICAgIHRoaXN0bGU6IFsyMTYsIDE5MSwgMjE2XSxcclxuICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IFsyNTUsIDI1NSwgMjU1LCAwXSxcclxuICAgICAgICAgICAgdG9tYXRvOiBbMjU1LCA5OSwgNzFdLFxyXG4gICAgICAgICAgICB0dXJxdW9pc2U6IFs2NCwgMjI0LCAyMDhdLFxyXG4gICAgICAgICAgICB2aW9sZXQ6IFsyMzgsIDEzMCwgMjM4XSxcclxuICAgICAgICAgICAgd2hlYXQ6IFsyNDUsIDIyMiwgMTc5XSxcclxuICAgICAgICAgICAgd2hpdGU6IFsyNTUsIDI1NSwgMjU1XSxcclxuICAgICAgICAgICAgd2hpdGVzbW9rZTogWzI0NSwgMjQ1LCAyNDVdLFxyXG4gICAgICAgICAgICB5ZWxsb3c6IFsyNTUsIDI1NSwgMF0sXHJcbiAgICAgICAgICAgIHllbGxvd2dyZWVuOiBbMTU0LCAyMDUsIDVdXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgUkdCX1JFR0VYID0gL3JnYlxcKChcXGR7MSwzfSksKFxcZHsxLDN9KSwoXFxkezEsM30pXFwpLztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lc3BhY2UgVXRpbFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXHJcbiAgICAgKi9cclxuICAgIEtvbnZhLlV0aWwgPSB7XHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBjaGVycnktcGlja2VkIHV0aWxpdGllcyBmcm9tIHVuZGVyc2NvcmUuanNcclxuICAgICAgICAgKi9cclxuICAgICAgICBfaXNFbGVtZW50OiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT0gMSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfaXNGdW5jdGlvbjogZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIShvYmogJiYgb2JqLmNvbnN0cnVjdG9yICYmIG9iai5jYWxsICYmIG9iai5hcHBseSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfaXNPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gKCEhb2JqICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pc0FycmF5OiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBPQkpFQ1RfQVJSQVk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfaXNOdW1iZXI6IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9OVU1CRVI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfaXNTdHJpbmc6IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9TVFJJTkc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcclxuICAgICAgICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cclxuICAgICAgICAvLyBhcyBtdWNoIGFzIGl0IGNhbiwgd2l0aG91dCBldmVyIGdvaW5nIG1vcmUgdGhhbiBvbmNlIHBlciBgd2FpdGAgZHVyYXRpb247XHJcbiAgICAgICAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcclxuICAgICAgICAvLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cclxuICAgICAgICBfdGhyb3R0bGU6IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdHMpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcclxuICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgcHJldmlvdXMgPSAwO1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge307XHJcbiAgICAgICAgICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IG5vdztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcclxuICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmcgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IG5vdztcclxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIG90aGVyIHV0aWxzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2hhc01ldGhvZHM6IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICAgICAgICB2YXIgbmFtZXMgPSBbXSxcclxuICAgICAgICAgICAgICAgIGtleTtcclxuXHJcbiAgICAgICAgICAgIGZvcihrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9pc0Z1bmN0aW9uKG9ialtrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmFtZXMubGVuZ3RoID4gMDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNyZWF0ZUNhbnZhc0VsZW1lbnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gS29udmEuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgIC8vIG9uIHNvbWUgZW52aXJvbm1lbnRzIGNhbnZhcy5zdHlsZSBpcyByZWFkb25seVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlID0gY2FudmFzLnN0eWxlIHx8IHt9O1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNhbnZhcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzQnJvd3NlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIGV4cG9ydHMgIT09ICdvYmplY3QnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pc0luRG9jdW1lbnQ6IGZ1bmN0aW9uKGVsKSB7XHJcbiAgICAgICAgICAgIHdoaWxlKGVsID0gZWwucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgaWYoZWwgPT0gS29udmEuZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfc2ltcGxpZnlBcnJheTogZnVuY3Rpb24oYXJyKSB7XHJcbiAgICAgICAgICAgIHZhciByZXRBcnIgPSBbXSxcclxuICAgICAgICAgICAgICAgIGxlbiA9IGFyci5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICB1dGlsID0gS29udmEuVXRpbCxcclxuICAgICAgICAgICAgICAgIG4sIHZhbDtcclxuXHJcbiAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gYXJyW25dO1xyXG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuX2lzTnVtYmVyKHZhbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBNYXRoLnJvdW5kKHZhbCAqIDEwMDApIC8gMTAwMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF1dGlsLl9pc1N0cmluZyh2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2godmFsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJldEFycjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogYXJnIGNhbiBiZSBhbiBpbWFnZSBvYmplY3Qgb3IgaW1hZ2UgZGF0YVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9nZXRJbWFnZTogZnVuY3Rpb24oYXJnLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICB2YXIgaW1hZ2VPYmosIGNhbnZhcztcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIGFyZyBpcyBudWxsIG9yIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICBpZighYXJnKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gaWYgYXJnIGlzIGFscmVhZHkgYW4gaW1hZ2Ugb2JqZWN0XHJcbiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5faXNFbGVtZW50KGFyZykpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGFyZyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGlmIGFyZyBpcyBhIHN0cmluZywgdGhlbiBpdCdzIGEgZGF0YSB1cmxcclxuICAgICAgICAgICAgZWxzZSBpZih0aGlzLl9pc1N0cmluZyhhcmcpKSB7XHJcbiAgICAgICAgICAgICAgICBpbWFnZU9iaiA9IG5ldyBLb252YS53aW5kb3cuSW1hZ2UoKTtcclxuICAgICAgICAgICAgICAgIGltYWdlT2JqLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGltYWdlT2JqKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpbWFnZU9iai5zcmMgPSBhcmc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vaWYgYXJnIGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBkYXRhIHByb3BlcnR5LCBpdCdzIGFuIGltYWdlIG9iamVjdFxyXG4gICAgICAgICAgICBlbHNlIGlmKGFyZy5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBjYW52YXMgPSBLb252YS5VdGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGFyZy53aWR0aDtcclxuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBhcmcuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoQ09OVEVYVF8yRCk7XHJcbiAgICAgICAgICAgICAgICBfY29udGV4dC5wdXRJbWFnZURhdGEoYXJnLCAwLCAwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dldEltYWdlKGNhbnZhcy50b0RhdGFVUkwoKSwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRSR0JBU3RyaW5nOiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICAgICAgdmFyIHJlZCA9IG9iai5yZWQgfHwgMCxcclxuICAgICAgICAgICAgICAgIGdyZWVuID0gb2JqLmdyZWVuIHx8IDAsXHJcbiAgICAgICAgICAgICAgICBibHVlID0gb2JqLmJsdWUgfHwgMCxcclxuICAgICAgICAgICAgICAgIGFscGhhID0gb2JqLmFscGhhIHx8IDE7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgJ3JnYmEoJyxcclxuICAgICAgICAgICAgICAgIHJlZCxcclxuICAgICAgICAgICAgICAgICcsJyxcclxuICAgICAgICAgICAgICAgIGdyZWVuLFxyXG4gICAgICAgICAgICAgICAgJywnLFxyXG4gICAgICAgICAgICAgICAgYmx1ZSxcclxuICAgICAgICAgICAgICAgICcsJyxcclxuICAgICAgICAgICAgICAgIGFscGhhLFxyXG4gICAgICAgICAgICAgICAgJyknXHJcbiAgICAgICAgICAgIF0uam9pbihFTVBUWV9TVFJJTkcpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3JnYlRvSGV4OiBmdW5jdGlvbihyLCBnLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKDEgPDwgMjQpICsgKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiKS50b1N0cmluZygxNikuc2xpY2UoMSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfaGV4VG9SZ2I6IGZ1bmN0aW9uKGhleCkge1xyXG4gICAgICAgICAgICBoZXggPSBoZXgucmVwbGFjZShIQVNILCBFTVBUWV9TVFJJTkcpO1xyXG4gICAgICAgICAgICB2YXIgYmlnaW50ID0gcGFyc2VJbnQoaGV4LCAxNik7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICByOiAoYmlnaW50ID4+IDE2KSAmIDI1NSxcclxuICAgICAgICAgICAgICAgIGc6IChiaWdpbnQgPj4gOCkgJiAyNTUsXHJcbiAgICAgICAgICAgICAgICBiOiBiaWdpbnQgJiAyNTVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHJldHVybiByYW5kb20gaGV4IGNvbG9yXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5VdGlsLnByb3RvdHlwZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFJhbmRvbUNvbG9yOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHJhbmRDb2xvciA9IChNYXRoLnJhbmRvbSgpICogMHhGRkZGRkYgPDwgMCkudG9TdHJpbmcoMTYpO1xyXG4gICAgICAgICAgICB3aGlsZSAocmFuZENvbG9yLmxlbmd0aCA8IDYpIHtcclxuICAgICAgICAgICAgICAgIHJhbmRDb2xvciA9IFpFUk8gKyByYW5kQ29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIEhBU0ggKyByYW5kQ29sb3I7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiByZXR1cm4gdmFsdWUgd2l0aCBkZWZhdWx0IGZhbGxiYWNrXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5VdGlsLnByb3RvdHlwZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24odmFsLCBkZWYpIHtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogZ2V0IFJHQiBjb21wb25lbnRzIG9mIGEgY29sb3JcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlV0aWwucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAvLyBlYWNoIG9mIHRoZSBmb2xsb3dpbmcgZXhhbXBsZXMgcmV0dXJuIHtyOjAsIGc6MCwgYjoyNTV9XHJcbiAgICAgICAgICogdmFyIHJnYiA9IEtvbnZhLlV0aWwuZ2V0UkdCKCdibHVlJyk7XHJcbiAgICAgICAgICogdmFyIHJnYiA9IEtvbnZhLlV0aWwuZ2V0UkdCKCcjMDAwMGZmJyk7XHJcbiAgICAgICAgICogdmFyIHJnYiA9IEtvbnZhLlV0aWwuZ2V0UkdCKCdyZ2IoMCwwLDI1NSknKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRSR0I6IGZ1bmN0aW9uKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHZhciByZ2I7XHJcbiAgICAgICAgICAgIC8vIGNvbG9yIHN0cmluZ1xyXG4gICAgICAgICAgICBpZiAoY29sb3IgaW4gQ09MT1JTKSB7XHJcbiAgICAgICAgICAgICAgICByZ2IgPSBDT0xPUlNbY29sb3JdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByOiByZ2JbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgZzogcmdiWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIGI6IHJnYlsyXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBoZXhcclxuICAgICAgICAgICAgZWxzZSBpZiAoY29sb3JbMF0gPT09IEhBU0gpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZXhUb1JnYihjb2xvci5zdWJzdHJpbmcoMSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJnYiBzdHJpbmdcclxuICAgICAgICAgICAgZWxzZSBpZiAoY29sb3Iuc3Vic3RyKDAsIDQpID09PSBSR0JfUEFSRU4pIHtcclxuICAgICAgICAgICAgICAgIHJnYiA9IFJHQl9SRUdFWC5leGVjKGNvbG9yLnJlcGxhY2UoLyAvZywgJycpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcjogcGFyc2VJbnQocmdiWzFdLCAxMCksXHJcbiAgICAgICAgICAgICAgICAgICAgZzogcGFyc2VJbnQocmdiWzJdLCAxMCksXHJcbiAgICAgICAgICAgICAgICAgICAgYjogcGFyc2VJbnQocmdiWzNdLCAxMClcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZGVmYXVsdFxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcjogMCxcclxuICAgICAgICAgICAgICAgICAgICBnOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGI6IDBcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIGNvbnZlcnQgYW55IGNvbG9yIHN0cmluZyB0byBSR0JBIG9iamVjdFxyXG4gICAgICAgIC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2NvbXBvbmVudC9jb2xvci1wYXJzZXJcclxuICAgICAgICBjb2xvclRvUkdCQTogZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgICAgIHN0ciA9IHN0ciB8fCAnYmxhY2snO1xyXG4gICAgICAgICAgICByZXR1cm4gS29udmEuVXRpbC5fbmFtZWRDb2xvclRvUkJBKHN0cilcclxuICAgICAgICAgICAgICAgIHx8IEtvbnZhLlV0aWwuX2hleDNDb2xvclRvUkdCQShzdHIpXHJcbiAgICAgICAgICAgICAgICB8fCBLb252YS5VdGlsLl9oZXg2Q29sb3JUb1JHQkEoc3RyKVxyXG4gICAgICAgICAgICAgICAgfHwgS29udmEuVXRpbC5fcmdiQ29sb3JUb1JHQkEoc3RyKVxyXG4gICAgICAgICAgICAgICAgfHwgS29udmEuVXRpbC5fcmdiYUNvbG9yVG9SR0JBKHN0cik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBQYXJzZSBuYW1lZCBjc3MgY29sb3IuIExpa2UgXCJncmVlblwiXHJcbiAgICAgICAgX25hbWVkQ29sb3JUb1JCQTogZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gQ09MT1JTW3N0ci50b0xvd2VyQ2FzZSgpXTtcclxuICAgICAgICAgICAgaWYgKCFjKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgcjogY1swXSxcclxuICAgICAgICAgICAgICAgIGc6IGNbMV0sXHJcbiAgICAgICAgICAgICAgICBiOiBjWzJdLFxyXG4gICAgICAgICAgICAgICAgYTogMVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gUGFyc2UgcmdiKG4sIG4sIG4pXHJcbiAgICAgICAgX3JnYkNvbG9yVG9SR0JBOiBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICAgICAgaWYgKHN0ci5pbmRleE9mKCdyZ2IoJykgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5tYXRjaCgvcmdiXFwoKFteKV0rKVxcKS8pWzFdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KC8gKiwgKi8pLm1hcChOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByOiBwYXJ0c1swXSxcclxuICAgICAgICAgICAgICAgICAgICBnOiBwYXJ0c1sxXSxcclxuICAgICAgICAgICAgICAgICAgICBiOiBwYXJ0c1syXSxcclxuICAgICAgICAgICAgICAgICAgICBhOiAxXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBQYXJzZSByZ2JhKG4sIG4sIG4sIG4pXHJcbiAgICAgICAgX3JnYmFDb2xvclRvUkdCQTogZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgICAgIGlmIChzdHIuaW5kZXhPZigncmdiYSgnKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLm1hdGNoKC9yZ2JhXFwoKFteKV0rKVxcKS8pWzFdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KC8gKiwgKi8pLm1hcChOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByOiBwYXJ0c1swXSxcclxuICAgICAgICAgICAgICAgICAgICBnOiBwYXJ0c1sxXSxcclxuICAgICAgICAgICAgICAgICAgICBiOiBwYXJ0c1syXSxcclxuICAgICAgICAgICAgICAgICAgICBhOiBwYXJ0c1szXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIFBhcnNlICNubm5ubm5cclxuICAgICAgICBfaGV4NkNvbG9yVG9SR0JBOiBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICAgICAgaWYgKChzdHJbMF0gPT09ICcjJykgJiYgKHN0ci5sZW5ndGggPT09IDcpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHI6IHBhcnNlSW50KHN0ci5zbGljZSgxLCAzKSwgMTYpLFxyXG4gICAgICAgICAgICAgICAgICAgIGc6IHBhcnNlSW50KHN0ci5zbGljZSgzLCA1KSwgMTYpLFxyXG4gICAgICAgICAgICAgICAgICAgIGI6IHBhcnNlSW50KHN0ci5zbGljZSg1LCA3KSwgMTYpLFxyXG4gICAgICAgICAgICAgICAgICAgIGE6IDFcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIFBhcnNlICNubm5cclxuICAgICAgICBfaGV4M0NvbG9yVG9SR0JBOiBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICAgICAgaWYgKChzdHJbMF0gPT09ICcjJykgJiYgKHN0ci5sZW5ndGggPT09IDQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHI6IHBhcnNlSW50KHN0clsxXSArIHN0clsxXSwgMTYpLFxyXG4gICAgICAgICAgICAgICAgICAgIGc6IHBhcnNlSW50KHN0clsyXSArIHN0clsyXSwgMTYpLFxyXG4gICAgICAgICAgICAgICAgICAgIGI6IHBhcnNlSW50KHN0clszXSArIHN0clszXSwgMTYpLFxyXG4gICAgICAgICAgICAgICAgICAgIGE6IDFcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIG8xIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBvMlxyXG4gICAgICAgIF9tZXJnZTogZnVuY3Rpb24obzEsIG8yKSB7XHJcbiAgICAgICAgICAgIHZhciByZXRPYmogPSB0aGlzLl9jbG9uZShvMik7XHJcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIG8xKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9pc09iamVjdChvMVtrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldE9ialtrZXldID0gdGhpcy5fbWVyZ2UobzFba2V5XSwgcmV0T2JqW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0T2JqW2tleV0gPSBvMVtrZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXRPYmo7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbG9uZU9iamVjdDogZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgICAgIHZhciByZXRPYmogPSB7fTtcclxuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9pc09iamVjdChvYmpba2V5XSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXRPYmpba2V5XSA9IHRoaXMuY2xvbmVPYmplY3Qob2JqW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faXNBcnJheShvYmpba2V5XSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXRPYmpba2V5XSA9IHRoaXMuY2xvbmVBcnJheShvYmpba2V5XSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldE9ialtrZXldID0gb2JqW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJldE9iajtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsb25lQXJyYXk6IGZ1bmN0aW9uKGFycikge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyLnNsaWNlKDApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2RlZ1RvUmFkOiBmdW5jdGlvbihkZWcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRlZyAqIFBJX09WRVJfREVHMTgwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3JhZFRvRGVnOiBmdW5jdGlvbihyYWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJhZCAqIERFRzE4MF9PVkVSX1BJO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2NhcGl0YWxpemU6IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdGhyb3c6IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoS09OVkFfRVJST1IgKyBzdHIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihLT05WQV9FUlJPUiArIHN0cik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB3YXJuOiBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICogSUU5IG9uIFdpbmRvd3M3IDY0Yml0IHdpbGwgdGhyb3cgYSBKUyBlcnJvclxyXG4gICAgICAgICAgICAgKiBpZiB3ZSBkb24ndCB1c2Ugd2luZG93LmNvbnNvbGUgaW4gdGhlIGNvbmRpdGlvbmFsXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZihLb252YS5yb290LmNvbnNvbGUgJiYgY29uc29sZS53YXJuICYmIEtvbnZhLnNob3dXYXJuaW5ncykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKEtPTlZBX1dBUk5JTkcgKyBzdHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQ3RvcigpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBDdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XHJcbiAgICAgICAgICAgIHZhciBvbGRQcm90byA9IGNoaWxkLnByb3RvdHlwZTtcclxuICAgICAgICAgICAgY2hpbGQucHJvdG90eXBlID0gbmV3IEN0b3IoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9sZFByb3RvKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2xkUHJvdG8uaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnByb3RvdHlwZVtrZXldID0gb2xkUHJvdG9ba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlO1xyXG4gICAgICAgICAgICAvLyBjcmVhdGUgcmVmZXJlbmNlIHRvIHBhcmVudFxyXG4gICAgICAgICAgICBjaGlsZC5zdXBlciA9IHBhcmVudDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGFkZHMgbWV0aG9kcyB0byBhIGNvbnN0cnVjdG9yIHByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVXRpbC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRob2RzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWRkTWV0aG9kczogZnVuY3Rpb24oY29uc3RydWN0b3IsIG1ldGhvZHMpIHtcclxuICAgICAgICAgICAgdmFyIGtleTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVtrZXldID0gbWV0aG9kc1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0Q29udHJvbFBvaW50czogZnVuY3Rpb24oeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgdCkge1xyXG4gICAgICAgICAgICB2YXIgZDAxID0gTWF0aC5zcXJ0KE1hdGgucG93KHgxIC0geDAsIDIpICsgTWF0aC5wb3coeTEgLSB5MCwgMikpLFxyXG4gICAgICAgICAgICAgICAgZDEyID0gTWF0aC5zcXJ0KE1hdGgucG93KHgyIC0geDEsIDIpICsgTWF0aC5wb3coeTIgLSB5MSwgMikpLFxyXG4gICAgICAgICAgICAgICAgZmEgPSB0ICogZDAxIC8gKGQwMSArIGQxMiksXHJcbiAgICAgICAgICAgICAgICBmYiA9IHQgKiBkMTIgLyAoZDAxICsgZDEyKSxcclxuICAgICAgICAgICAgICAgIHAxeCA9IHgxIC0gZmEgKiAoeDIgLSB4MCksXHJcbiAgICAgICAgICAgICAgICBwMXkgPSB5MSAtIGZhICogKHkyIC0geTApLFxyXG4gICAgICAgICAgICAgICAgcDJ4ID0geDEgKyBmYiAqICh4MiAtIHgwKSxcclxuICAgICAgICAgICAgICAgIHAyeSA9IHkxICsgZmIgKiAoeTIgLSB5MCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gW3AxeCwgcDF5LCBwMngsIHAyeV07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZXhwYW5kUG9pbnRzOiBmdW5jdGlvbihwLCB0ZW5zaW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBsZW4gPSBwLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGFsbFBvaW50cyA9IFtdLFxyXG4gICAgICAgICAgICAgICAgbiwgY3A7XHJcblxyXG4gICAgICAgICAgICBmb3IgKG4gPSAyOyBuIDwgbGVuIC0gMjsgbiArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICBjcCA9IEtvbnZhLlV0aWwuX2dldENvbnRyb2xQb2ludHMocFtuIC0gMl0sIHBbbiAtIDFdLCBwW25dLCBwW24gKyAxXSwgcFtuICsgMl0sIHBbbiArIDNdLCB0ZW5zaW9uKTtcclxuICAgICAgICAgICAgICAgIGFsbFBvaW50cy5wdXNoKGNwWzBdKTtcclxuICAgICAgICAgICAgICAgIGFsbFBvaW50cy5wdXNoKGNwWzFdKTtcclxuICAgICAgICAgICAgICAgIGFsbFBvaW50cy5wdXNoKHBbbl0pO1xyXG4gICAgICAgICAgICAgICAgYWxsUG9pbnRzLnB1c2gocFtuICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgYWxsUG9pbnRzLnB1c2goY3BbMl0pO1xyXG4gICAgICAgICAgICAgICAgYWxsUG9pbnRzLnB1c2goY3BbM10pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYWxsUG9pbnRzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3JlbW92ZUxhc3RMZXR0ZXI6IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlYWNoOiBmdW5jdGlvbihvYmosIGZ1bmMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xyXG4gICAgICAgICAgICAgICAgZnVuYyhrZXksIG9ialtrZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldFByb2plY3Rpb25Ub1NlZ21lbnQ6IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcclxuICAgICAgICAgICAgdmFyIHgsIHksIGRpc3Q7XHJcblxyXG4gICAgICAgICAgICB2YXIgcGQyID0gKHgxIC0geDIpICogKHgxIC0geDIpICsgKHkxIC0geTIpICogKHkxIC0geTIpO1xyXG4gICAgICAgICAgICBpZihwZDIgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgeCA9IHgxO1xyXG4gICAgICAgICAgICAgICAgeSA9IHkxO1xyXG4gICAgICAgICAgICAgICAgZGlzdCA9ICh4MyAtIHgyKSAqICh4MyAtIHgyKSArICh5MyAtIHkyKSAqICh5MyAtIHkyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciB1ID0gKCh4MyAtIHgxKSAqICh4MiAtIHgxKSArICh5MyAtIHkxKSAqICh5MiAtIHkxKSkgLyBwZDI7XHJcbiAgICAgICAgICAgICAgICBpZih1IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSB4MTtcclxuICAgICAgICAgICAgICAgICAgICB5ID0geTE7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdCA9ICh4MSAtIHgzKSAqICh4MSAtIHgzKSArICh5MSAtIHkzKSAqICh5MSAtIHkzKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodSA+IDEuMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSB4MjtcclxuICAgICAgICAgICAgICAgICAgICB5ID0geTI7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdCA9ICh4MiAtIHgzKSAqICh4MiAtIHgzKSArICh5MiAtIHkzKSAqICh5MiAtIHkzKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IHgxICsgdSAqICh4MiAtIHgxKTtcclxuICAgICAgICAgICAgICAgICAgICB5ID0geTEgKyB1ICogKHkyIC0geTEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3QgPSAoeCAtIHgzKSAqICh4IC0geDMpICsgKHkgLSB5MykgKiAoeSAtIHkzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gW3gsIHksIGRpc3RdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gbGluZSBhcyBhcnJheSBvZiBwb2ludHMuXHJcbiAgICAgICAgLy8gbGluZSBtaWdodCBiZSBjbG9zZWRcclxuICAgICAgICBfZ2V0UHJvamVjdGlvblRvTGluZTogZnVuY3Rpb24ocHQsIGxpbmUsIGlzQ2xvc2VkKSB7XHJcbiAgICAgICAgICAgIHZhciBwYyA9IEtvbnZhLlV0aWwuY2xvbmVPYmplY3QocHQpO1xyXG4gICAgICAgICAgICB2YXIgZGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgICAgIGxpbmUuZm9yRWFjaChmdW5jdGlvbihwMSwgaSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0Nsb3NlZCAmJiBpID09PSBsaW5lLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcDIgPSBsaW5lWyhpICsgMSkgJSBsaW5lLmxlbmd0aF07XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvaiA9IEtvbnZhLlV0aWwuX2dldFByb2plY3Rpb25Ub1NlZ21lbnQocDEueCwgcDEueSwgcDIueCwgcDIueSwgcHQueCwgcHQueSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHggPSBwcm9qWzBdLCBweSA9IHByb2pbMV0sIHBkaXN0ID0gcHJvalsyXTtcclxuICAgICAgICAgICAgICAgIGlmIChwZGlzdCA8IGRpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYy54ID0gcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgcGMueSA9IHB5O1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3QgPSBwZGlzdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwYztcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9wcmVwYXJlQXJyYXlGb3JUd2VlbjogZnVuY3Rpb24oc3RhcnRBcnJheSwgZW5kQXJyYXksIGlzQ2xvc2VkKSB7XHJcbiAgICAgICAgICAgIHZhciBuLCBzdGFydCA9IFtdLCBlbmQgPSBbXTtcclxuICAgICAgICAgICAgaWYgKHN0YXJ0QXJyYXkubGVuZ3RoID4gZW5kQXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IGVuZEFycmF5O1xyXG4gICAgICAgICAgICAgICAgZW5kQXJyYXkgPSBzdGFydEFycmF5O1xyXG4gICAgICAgICAgICAgICAgc3RhcnRBcnJheSA9IHRlbXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IHN0YXJ0QXJyYXkubGVuZ3RoOyBuICs9IDIpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IHN0YXJ0QXJyYXlbbl0sXHJcbiAgICAgICAgICAgICAgICAgICAgeTogc3RhcnRBcnJheVtuICsgMV1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBlbmRBcnJheS5sZW5ndGg7IG4gKz0gMikge1xyXG4gICAgICAgICAgICAgICAgZW5kLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IGVuZEFycmF5W25dLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IGVuZEFycmF5W24gKyAxXVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgbmV3U3RhcnQgPSBbXTtcclxuICAgICAgICAgICAgZW5kLmZvckVhY2goZnVuY3Rpb24ocG9pbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwciA9IEtvbnZhLlV0aWwuX2dldFByb2plY3Rpb25Ub0xpbmUocG9pbnQsIHN0YXJ0LCBpc0Nsb3NlZCk7XHJcbiAgICAgICAgICAgICAgICBuZXdTdGFydC5wdXNoKHByLngpO1xyXG4gICAgICAgICAgICAgICAgbmV3U3RhcnQucHVzaChwci55KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdTdGFydDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59KSgpO1xyXG5cbihmdW5jdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8vIGNhbGN1bGF0ZSBwaXhlbCByYXRpb1xyXG4gICAgdmFyIGNhbnZhcyA9IEtvbnZhLlV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLFxyXG4gICAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcclxuICAgICAgICBfcGl4ZWxSYXRpbyA9IChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB2YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IEtvbnZhLndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsXHJcbiAgICAgICAgICAgIGJhY2tpbmdTdG9yZVJhdGlvID0gY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvXHJcbiAgICAgICAgICAgICAgICB8fCBjb250ZXh0Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW9cclxuICAgICAgICAgICAgICAgIHx8IGNvbnRleHQubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvXHJcbiAgICAgICAgICAgICAgICB8fCBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvXHJcbiAgICAgICAgICAgICAgICB8fCBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW9cclxuICAgICAgICAgICAgICAgIHx8IDE7XHJcbiAgICAgICAgICAgIHJldHVybiBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XHJcbiAgICAgICAgfSkoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbnZhcyBSZW5kZXJlciBjb25zdHJ1Y3RvclxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy53aWR0aFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5oZWlnaHRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcucGl4ZWxSYXRpbyBLb252YUpTIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBwaXhlbCByYXRpbyBhZGp1c3RtZW50cyBpbiBvcmRlciB0byByZW5kZXIgY3Jpc3AgZHJhd2luZ3NcclxuICAgICAqICBvbiBhbGwgZGV2aWNlcy4gTW9zdCBkZXNrdG9wcywgbG93IGVuZCB0YWJsZXRzLCBhbmQgbG93IGVuZCBwaG9uZXMsIGhhdmUgZGV2aWNlIHBpeGVsIHJhdGlvc1xyXG4gICAgICogIG9mIDEuICBTb21lIGhpZ2ggZW5kIHRhYmxldHMgYW5kIHBob25lcywgbGlrZSBpUGhvbmVzIGFuZCBpUGFkcyAobm90IHRoZSBtaW5pKSBoYXZlIGEgZGV2aWNlIHBpeGVsIHJhdGlvXHJcbiAgICAgKiAgb2YgMi4gIFNvbWUgTWFjYm9vayBQcm9zLCBhbmQgaU1hY3MgYWxzbyBoYXZlIGEgZGV2aWNlIHBpeGVsIHJhdGlvIG9mIDIuICBTb21lIGhpZ2ggZW5kIEFuZHJvaWQgZGV2aWNlcyBoYXZlIHBpeGVsXHJcbiAgICAgKiAgcmF0aW9zIG9mIDIgb3IgMy4gIFNvbWUgYnJvd3NlcnMgbGlrZSBGaXJlZm94IGFsbG93IHlvdSB0byBjb25maWd1cmUgdGhlIHBpeGVsIHJhdGlvIG9mIHRoZSB2aWV3cG9ydC4gIFVubGVzcyBvdGhlcndpc2VcclxuICAgICAqICBzcGVjaWZpZWQsIHRoZSBwaXhlbCByYXRpbyB3aWxsIGJlIGRlZmF1bHRlZCB0byB0aGUgYWN0dWFsIGRldmljZSBwaXhlbCByYXRpby4gIFlvdSBjYW4gb3ZlcnJpZGUgdGhlIGRldmljZSBwaXhlbFxyXG4gICAgICogIHJhdGlvIGZvciBzcGVjaWFsIHNpdHVhdGlvbnMsIG9yLCBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgcGl4ZWwgcmF0aW8gdG8gYmUgdGFrZW4gaW50byBhY2NvdW50LCB5b3UgY2FuIHNldCBpdCB0byAxLlxyXG4gICAgICovXHJcbiAgICBLb252YS5DYW52YXMgPSBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICB0aGlzLmluaXQoY29uZmlnKTtcclxuICAgIH07XHJcblxyXG4gICAgS29udmEuQ2FudmFzLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBpbml0OiBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICAgICAgdmFyIGNvbmYgPSBjb25maWcgfHwge307XHJcblxyXG4gICAgICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IGNvbmYucGl4ZWxSYXRpbyB8fCBLb252YS5waXhlbFJhdGlvIHx8IF9waXhlbFJhdGlvO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcclxuICAgICAgICAgICAgdGhpcy5fY2FudmFzID0gS29udmEuVXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBzZXQgaW5saW5lIHN0eWxlc1xyXG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUucGFkZGluZyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5tYXJnaW4gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUuYm9yZGVyID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLmJhY2tncm91bmQgPSAndHJhbnNwYXJlbnQnO1xyXG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUudG9wID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLmxlZnQgPSAwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogZ2V0IGNhbnZhcyBjb250ZXh0XHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge0NhbnZhc0NvbnRleHR9IGNvbnRleHRcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRDb250ZXh0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGdldCBwaXhlbCByYXRpb1xyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ2FudmFzLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHBpeGVsIHJhdGlvXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0UGl4ZWxSYXRpbzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBpeGVsUmF0aW87XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBnZXQgcGl4ZWwgcmF0aW9cclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcGl4ZWxSYXRpbyBLb252YUpTIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBwaXhlbCByYXRpbyBhZHVzdG1lbnRzIGluIG9yZGVyIHRvIHJlbmRlciBjcmlzcCBkcmF3aW5nc1xyXG4gICAgICAgICAqICBvbiBhbGwgZGV2aWNlcy4gTW9zdCBkZXNrdG9wcywgbG93IGVuZCB0YWJsZXRzLCBhbmQgbG93IGVuZCBwaG9uZXMsIGhhdmUgZGV2aWNlIHBpeGVsIHJhdGlvc1xyXG4gICAgICAgICAqICBvZiAxLiAgU29tZSBoaWdoIGVuZCB0YWJsZXRzIGFuZCBwaG9uZXMsIGxpa2UgaVBob25lcyBhbmQgaVBhZHMgaGF2ZSBhIGRldmljZSBwaXhlbCByYXRpb1xyXG4gICAgICAgICAqICBvZiAyLiAgU29tZSBNYWNib29rIFByb3MsIGFuZCBpTWFjcyBhbHNvIGhhdmUgYSBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgMi4gIFNvbWUgaGlnaCBlbmQgQW5kcm9pZCBkZXZpY2VzIGhhdmUgcGl4ZWxcclxuICAgICAgICAgKiAgcmF0aW9zIG9mIDIgb3IgMy4gIFNvbWUgYnJvd3NlcnMgbGlrZSBGaXJlZm94IGFsbG93IHlvdSB0byBjb25maWd1cmUgdGhlIHBpeGVsIHJhdGlvIG9mIHRoZSB2aWV3cG9ydC4gIFVubGVzcyBvdGhlcndpc2VcclxuICAgICAgICAgKiAgc3BlY2lmaWNlZCwgdGhlIHBpeGVsIHJhdGlvIHdpbGwgYmUgZGVmYXVsdGVkIHRvIHRoZSBhY3R1YWwgZGV2aWNlIHBpeGVsIHJhdGlvLiAgWW91IGNhbiBvdmVycmlkZSB0aGUgZGV2aWNlIHBpeGVsXHJcbiAgICAgICAgICogIHJhdGlvIGZvciBzcGVjaWFsIHNpdHVhdGlvbnMsIG9yLCBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgcGl4ZWwgcmF0aW8gdG8gYmUgdGFrZW4gaW50byBhY2NvdW50LCB5b3UgY2FuIHNldCBpdCB0byAxLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldFBpeGVsUmF0aW86IGZ1bmN0aW9uKHBpeGVsUmF0aW8pIHtcclxuICAgICAgICAgICAgdmFyIHByZXZpb3VzUmF0aW8gPSB0aGlzLnBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U2l6ZSh0aGlzLmdldFdpZHRoKCkgLyBwcmV2aW91c1JhdGlvLCB0aGlzLmdldEhlaWdodCgpIC8gcHJldmlvdXNSYXRpbyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBzZXQgd2lkdGhcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcclxuICAgICAgICAgICAgLy8gdGFrZSBpbnRvIGFjY291bnQgcGl4ZWwgcmF0aW9cclxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuX2NhbnZhcy53aWR0aCA9IHdpZHRoICogdGhpcy5waXhlbFJhdGlvO1xyXG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XHJcblxyXG4gICAgICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IHRoaXMucGl4ZWxSYXRpbyxcclxuICAgICAgICAgICAgICAgIF9jb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KCkuX2NvbnRleHQ7XHJcbiAgICAgICAgICAgIF9jb250ZXh0LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogc2V0IGhlaWdodFxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ2FudmFzLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xyXG4gICAgICAgICAgICAvLyB0YWtlIGludG8gYWNjb3VudCBwaXhlbCByYXRpb1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX2NhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xyXG4gICAgICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IHRoaXMucGl4ZWxSYXRpbyxcclxuICAgICAgICAgICAgICAgIF9jb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KCkuX2NvbnRleHQ7XHJcbiAgICAgICAgICAgIF9jb250ZXh0LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogZ2V0IHdpZHRoXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge051bWJlcn0gd2lkdGhcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogZ2V0IGhlaWdodFxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ2FudmFzLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IGhlaWdodFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHNldCBzaXplXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldFNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRXaWR0aCh3aWR0aCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KGhlaWdodCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiB0byBkYXRhIHVybFxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ2FudmFzLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lVHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBxdWFsaXR5IGJldHdlZW4gMCBhbmQgMSBmb3IganBnIG1pbWUgdHlwZXNcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBkYXRhIHVybCBzdHJpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICB0b0RhdGFVUkw6IGZ1bmN0aW9uKG1pbWVUeXBlLCBxdWFsaXR5KSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGNhbGwgZmFpbHMgKGR1ZSB0byBicm93c2VyIGJ1ZywgbGlrZSBpbiBGaXJlZm94IDMuNiksXHJcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHJldmVydCB0byBwcmV2aW91cyBuby1wYXJhbWV0ZXIgaW1hZ2UvcG5nIGJlaGF2aW9yXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzLnRvRGF0YVVSTChtaW1lVHlwZSwgcXVhbGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzLnRvRGF0YVVSTCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2goZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdVbmFibGUgdG8gZ2V0IGRhdGEgVVJMLiAnICsgZXJyLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgS29udmEuU2NlbmVDYW52YXMgPSBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICB2YXIgY29uZiA9IGNvbmZpZyB8fCB7fTtcclxuICAgICAgICB2YXIgd2lkdGggPSBjb25mLndpZHRoIHx8IDAsXHJcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbmYuaGVpZ2h0IHx8IDA7XHJcblxyXG4gICAgICAgIEtvbnZhLkNhbnZhcy5jYWxsKHRoaXMsIGNvbmYpO1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IG5ldyBLb252YS5TY2VuZUNvbnRleHQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5TY2VuZUNhbnZhcywgS29udmEuQ2FudmFzKTtcclxuXHJcbiAgICBLb252YS5IaXRDYW52YXMgPSBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICB2YXIgY29uZiA9IGNvbmZpZyB8fCB7fTtcclxuICAgICAgICB2YXIgd2lkdGggPSBjb25mLndpZHRoIHx8IDAsXHJcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbmYuaGVpZ2h0IHx8IDA7XHJcblxyXG4gICAgICAgIEtvbnZhLkNhbnZhcy5jYWxsKHRoaXMsIGNvbmYpO1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IG5ldyBLb252YS5IaXRDb250ZXh0KHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmhpdENhbnZhcyA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuSGl0Q2FudmFzLCBLb252YS5DYW52YXMpO1xyXG5cclxufSkoKTtcclxuXG4oZnVuY3Rpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB2YXIgQ09NTUEgPSAnLCcsXHJcbiAgICAgICAgT1BFTl9QQVJFTiA9ICcoJyxcclxuICAgICAgICBDTE9TRV9QQVJFTiA9ICcpJyxcclxuICAgICAgICBPUEVOX1BBUkVOX0JSQUNLRVQgPSAnKFsnLFxyXG4gICAgICAgIENMT1NFX0JSQUNLRVRfUEFSRU4gPSAnXSknLFxyXG4gICAgICAgIFNFTUlDT0xPTiA9ICc7JyxcclxuICAgICAgICBET1VCTEVfUEFSRU4gPSAnKCknLFxyXG4gICAgICAgIC8vIEVNUFRZX1NUUklORyA9ICcnLFxyXG4gICAgICAgIEVRVUFMUyA9ICc9JyxcclxuICAgICAgICAvLyBTRVQgPSAnc2V0JyxcclxuICAgICAgICBDT05URVhUX01FVEhPRFMgPSBbXHJcbiAgICAgICAgICAgICdhcmMnLFxyXG4gICAgICAgICAgICAnYXJjVG8nLFxyXG4gICAgICAgICAgICAnYmVnaW5QYXRoJyxcclxuICAgICAgICAgICAgJ2JlemllckN1cnZlVG8nLFxyXG4gICAgICAgICAgICAnY2xlYXJSZWN0JyxcclxuICAgICAgICAgICAgJ2NsaXAnLFxyXG4gICAgICAgICAgICAnY2xvc2VQYXRoJyxcclxuICAgICAgICAgICAgJ2NyZWF0ZUxpbmVhckdyYWRpZW50JyxcclxuICAgICAgICAgICAgJ2NyZWF0ZVBhdHRlcm4nLFxyXG4gICAgICAgICAgICAnY3JlYXRlUmFkaWFsR3JhZGllbnQnLFxyXG4gICAgICAgICAgICAnZHJhd0ltYWdlJyxcclxuICAgICAgICAgICAgJ2ZpbGwnLFxyXG4gICAgICAgICAgICAnZmlsbFRleHQnLFxyXG4gICAgICAgICAgICAnZ2V0SW1hZ2VEYXRhJyxcclxuICAgICAgICAgICAgJ2NyZWF0ZUltYWdlRGF0YScsXHJcbiAgICAgICAgICAgICdsaW5lVG8nLFxyXG4gICAgICAgICAgICAnbW92ZVRvJyxcclxuICAgICAgICAgICAgJ3B1dEltYWdlRGF0YScsXHJcbiAgICAgICAgICAgICdxdWFkcmF0aWNDdXJ2ZVRvJyxcclxuICAgICAgICAgICAgJ3JlY3QnLFxyXG4gICAgICAgICAgICAncmVzdG9yZScsXHJcbiAgICAgICAgICAgICdyb3RhdGUnLFxyXG4gICAgICAgICAgICAnc2F2ZScsXHJcbiAgICAgICAgICAgICdzY2FsZScsXHJcbiAgICAgICAgICAgICdzZXRMaW5lRGFzaCcsXHJcbiAgICAgICAgICAgICdzZXRUcmFuc2Zvcm0nLFxyXG4gICAgICAgICAgICAnc3Ryb2tlJyxcclxuICAgICAgICAgICAgJ3N0cm9rZVRleHQnLFxyXG4gICAgICAgICAgICAndHJhbnNmb3JtJyxcclxuICAgICAgICAgICAgJ3RyYW5zbGF0ZSdcclxuICAgICAgICBdO1xyXG5cclxuICAgIHZhciBDT05URVhUX1BST1BFUlRJRVMgPSBbJ2ZpbGxTdHlsZScsICdzdHJva2VTdHlsZScsICdzaGFkb3dDb2xvcicsICdzaGFkb3dCbHVyJywgJ3NoYWRvd09mZnNldFgnLFxyXG4gICAgICAgICdzaGFkb3dPZmZzZXRZJywgJ2xpbmVDYXAnLCAnbGluZUpvaW4nLCAnbGluZVdpZHRoJywgJ21pdGVyTGltaXQnLCAnZm9udCcsICd0ZXh0QWxpZ24nLCAndGV4dEJhc2VsaW5lJyxcclxuICAgICAgICAnZ2xvYmFsQWxwaGEnLCAnZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uJ107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW52YXMgQ29udGV4dCBjb25zdHJ1Y3RvclxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxyXG4gICAgICovXHJcbiAgICBLb252YS5Db250ZXh0ID0gZnVuY3Rpb24oY2FudmFzKSB7XHJcbiAgICAgICAgdGhpcy5pbml0KGNhbnZhcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIEtvbnZhLkNvbnRleHQucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKGNhbnZhcykge1xyXG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dCA9IGNhbnZhcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoS29udmEuZW5hYmxlVHJhY2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2VBcnIgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VuYWJsZVRyYWNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGZpbGwgc2hhcGVcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRleHQucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtLb252YS5TaGFwZX0gc2hhcGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBmaWxsU2hhcGU6IGZ1bmN0aW9uKHNoYXBlKSB7XHJcbiAgICAgICAgICAgIGlmKHNoYXBlLmdldEZpbGxFbmFibGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGwoc2hhcGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBzdHJva2Ugc2hhcGVcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRleHQucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtLb252YS5TaGFwZX0gc2hhcGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBzdHJva2VTaGFwZTogZnVuY3Rpb24oc2hhcGUpIHtcclxuICAgICAgICAgICAgaWYoc2hhcGUuZ2V0U3Ryb2tlRW5hYmxlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJva2Uoc2hhcGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBmaWxsIHRoZW4gc3Ryb2tlXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250ZXh0LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7S29udmEuU2hhcGV9IHNoYXBlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZmlsbFN0cm9rZVNoYXBlOiBmdW5jdGlvbihzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgZmlsbEVuYWJsZWQgPSBzaGFwZS5nZXRGaWxsRW5hYmxlZCgpO1xyXG4gICAgICAgICAgICBpZihmaWxsRW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsbChzaGFwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoc2hhcGUuZ2V0U3Ryb2tlRW5hYmxlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJva2Uoc2hhcGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBnZXQgY29udGV4dCB0cmFjZSBpZiB0cmFjZSBpcyBlbmFibGVkXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250ZXh0LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVsYXhlZCBpZiBmYWxzZSwgcmV0dXJuIHN0cmljdCBjb250ZXh0IHRyYWNlLCB3aGljaCBpbmNsdWRlcyBtZXRob2QgbmFtZXMsIG1ldGhvZCBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICogIHByb3BlcnRpZXMsIGFuZCBwcm9wZXJ0eSB2YWx1ZXMuICBJZiB0cnVlLCByZXR1cm4gcmVsYXhlZCBjb250ZXh0IHRyYWNlLCB3aGljaCBvbmx5IHJldHVybnMgbWV0aG9kIG5hbWVzIGFuZFxyXG4gICAgICAgICAqICBwcm9wZXJpdGVzLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0VHJhY2U6IGZ1bmN0aW9uKHJlbGF4ZWQpIHtcclxuICAgICAgICAgICAgdmFyIHRyYWNlQXJyID0gdGhpcy50cmFjZUFycixcclxuICAgICAgICAgICAgICAgIGxlbiA9IHRyYWNlQXJyLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIHN0ciA9ICcnLFxyXG4gICAgICAgICAgICAgICAgbiwgdHJhY2UsIG1ldGhvZCwgYXJncztcclxuXHJcbiAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xyXG4gICAgICAgICAgICAgICAgdHJhY2UgPSB0cmFjZUFycltuXTtcclxuICAgICAgICAgICAgICAgIG1ldGhvZCA9IHRyYWNlLm1ldGhvZDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBtZXRob2RzXHJcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IHRyYWNlLmFyZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9IG1ldGhvZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVsYXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gRE9VQkxFX1BBUkVOO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEtvbnZhLlV0aWwuX2lzQXJyYXkoYXJnc1swXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBPUEVOX1BBUkVOX0JSQUNLRVQgKyBhcmdzLmpvaW4oQ09NTUEpICsgQ0xPU0VfQlJBQ0tFVF9QQVJFTjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBPUEVOX1BBUkVOICsgYXJncy5qb2luKENPTU1BKSArIENMT1NFX1BBUkVOO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9IHRyYWNlLnByb3BlcnR5O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVsYXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gRVFVQUxTICsgdHJhY2UudmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gU0VNSUNPTE9OO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogY2xlYXIgdHJhY2UgaWYgdHJhY2UgaXMgZW5hYmxlZFxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGV4dC5wcm90b3R5cGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGVhclRyYWNlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy50cmFjZUFyciA9IFtdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3RyYWNlOiBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICAgICAgdmFyIHRyYWNlQXJyID0gdGhpcy50cmFjZUFycixcclxuICAgICAgICAgICAgICAgIGxlbjtcclxuXHJcbiAgICAgICAgICAgIHRyYWNlQXJyLnB1c2goc3RyKTtcclxuICAgICAgICAgICAgbGVuID0gdHJhY2VBcnIubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxlbiA+PSBLb252YS50cmFjZUFyck1heCkge1xyXG4gICAgICAgICAgICAgICAgdHJhY2VBcnIuc2hpZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogcmVzZXQgY2FudmFzIGNvbnRleHQgdHJhbnNmb3JtXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250ZXh0LnByb3RvdHlwZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSB0aGlzLmdldENhbnZhcygpLmdldFBpeGVsUmF0aW8oKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oMSAqIHBpeGVsUmF0aW8sIDAsIDAsIDEgKiBwaXhlbFJhdGlvLCAwLCAwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGdldCBjYW52YXNcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRleHQucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLkNhbnZhc31cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRDYW52YXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYW52YXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBjbGVhciBjYW52YXNcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRleHQucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtib3VuZHNdXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMueF1cclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2JvdW5kcy55XVxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbYm91bmRzLndpZHRoXVxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbYm91bmRzLmhlaWdodF1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGVhcjogZnVuY3Rpb24oYm91bmRzKSB7XHJcbiAgICAgICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGJvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclJlY3QoYm91bmRzLnggfHwgMCwgYm91bmRzLnkgfHwgMCwgYm91bmRzLndpZHRoIHx8IDAsIGJvdW5kcy5oZWlnaHQgfHwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyUmVjdCgwLCAwLCBjYW52YXMuZ2V0V2lkdGgoKSAvIGNhbnZhcy5waXhlbFJhdGlvLCBjYW52YXMuZ2V0SGVpZ2h0KCkgLyBjYW52YXMucGl4ZWxSYXRpbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9hcHBseUxpbmVDYXA6IGZ1bmN0aW9uKHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBsaW5lQ2FwID0gc2hhcGUuZ2V0TGluZUNhcCgpO1xyXG4gICAgICAgICAgICBpZihsaW5lQ2FwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHIoJ2xpbmVDYXAnLCBsaW5lQ2FwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2FwcGx5T3BhY2l0eTogZnVuY3Rpb24oc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIGFic09wYWNpdHkgPSBzaGFwZS5nZXRBYnNvbHV0ZU9wYWNpdHkoKTtcclxuICAgICAgICAgICAgaWYoYWJzT3BhY2l0eSAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdnbG9iYWxBbHBoYScsIGFic09wYWNpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfYXBwbHlMaW5lSm9pbjogZnVuY3Rpb24oc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIGxpbmVKb2luID0gc2hhcGUuZ2V0TGluZUpvaW4oKTtcclxuICAgICAgICAgICAgaWYobGluZUpvaW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cignbGluZUpvaW4nLCBsaW5lSm9pbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldEF0dHI6IGZ1bmN0aW9uKGF0dHIsIHZhbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0W2F0dHJdID0gdmFsO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIGNvbnRleHQgcGFzcyB0aHJvdWdoIG1ldGhvZHNcclxuICAgICAgICBhcmM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5hcmMoYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBiZWdpblBhdGg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYmV6aWVyQ3VydmVUbzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmJlemllckN1cnZlVG8oYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbGVhclJlY3Q6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbGVhclJlY3QoYVswXSwgYVsxXSwgYVsyXSwgYVszXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbGlwOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbGlwKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbG9zZVBhdGg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3JlYXRlSW1hZ2VEYXRhOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgICAgIGlmKGEubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5jcmVhdGVJbWFnZURhdGEoYVswXSwgYVsxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihhLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKGFbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjcmVhdGVMaW5lYXJHcmFkaWVudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNyZWF0ZVBhdHRlcm46IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuY3JlYXRlUGF0dGVybihhWzBdLCBhWzFdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNyZWF0ZVJhZGlhbEdyYWRpZW50OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmNyZWF0ZVJhZGlhbEdyYWRpZW50KGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZHJhd0ltYWdlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHMsXHJcbiAgICAgICAgICAgICAgICBfY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XHJcblxyXG4gICAgICAgICAgICBpZihhLmxlbmd0aCA9PT0gMykge1xyXG4gICAgICAgICAgICAgICAgX2NvbnRleHQuZHJhd0ltYWdlKGFbMF0sIGFbMV0sIGFbMl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoYS5sZW5ndGggPT09IDUpIHtcclxuICAgICAgICAgICAgICAgIF9jb250ZXh0LmRyYXdJbWFnZShhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGEubGVuZ3RoID09PSA5KSB7XHJcbiAgICAgICAgICAgICAgICBfY29udGV4dC5kcmF3SW1hZ2UoYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSwgYVs2XSwgYVs3XSwgYVs4XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzUG9pbnRJblBhdGg6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuaXNQb2ludEluUGF0aCh4LCB5KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZpbGw6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGwoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZpbGxSZWN0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdHJva2VSZWN0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc3Ryb2tlUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZpbGxUZXh0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFRleHQoYVswXSwgYVsxXSwgYVsyXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtZWFzdXJlVGV4dDogZnVuY3Rpb24odGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldEltYWdlRGF0YTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5nZXRJbWFnZURhdGEoYVswXSwgYVsxXSwgYVsyXSwgYVszXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaW5lVG86IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oYVswXSwgYVsxXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtb3ZlVG86IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oYVswXSwgYVsxXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWN0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQucmVjdChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHB1dEltYWdlRGF0YTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnB1dEltYWdlRGF0YShhWzBdLCBhWzFdLCBhWzJdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVzdG9yZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcm90YXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQucm90YXRlKGFbMF0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2F2ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2NhbGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zY2FsZShhWzBdLCBhWzFdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldExpbmVEYXNoOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHMsXHJcbiAgICAgICAgICAgICAgICBfY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XHJcblxyXG4gICAgICAgICAgICAvLyB3b3JrcyBmb3IgQ2hyb21lIGFuZCBJRTExXHJcbiAgICAgICAgICAgIGlmKHRoaXMuX2NvbnRleHQuc2V0TGluZURhc2gpIHtcclxuICAgICAgICAgICAgICAgIF9jb250ZXh0LnNldExpbmVEYXNoKGFbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHZlcmlmaWVkIHRoYXQgdGhpcyB3b3JrcyBpbiBmaXJlZm94XHJcbiAgICAgICAgICAgIGVsc2UgaWYoJ21vekRhc2gnIGluIF9jb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBfY29udGV4dC5tb3pEYXNoID0gYVswXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBkb2VzIG5vdCBjdXJyZW50bHkgd29yayBmb3IgU2FmYXJpXHJcbiAgICAgICAgICAgIGVsc2UgaWYoJ3dlYmtpdExpbmVEYXNoJyBpbiBfY29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgX2NvbnRleHQud2Via2l0TGluZURhc2ggPSBhWzBdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBubyBzdXBwb3J0IGZvciBJRTkgYW5kIElFMTBcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldExpbmVEYXNoOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZ2V0TGluZURhc2goKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldFRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNldFRyYW5zZm9ybShhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN0cm9rZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc3Ryb2tlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdHJva2VUZXh0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc3Ryb2tlVGV4dChhWzBdLCBhWzFdLCBhWzJdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnRyYW5zZm9ybShhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnRyYW5zbGF0ZShhWzBdLCBhWzFdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9lbmFibGVUcmFjZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIGxlbiA9IENPTlRFWFRfTUVUSE9EUy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBfc2ltcGxpZnlBcnJheSA9IEtvbnZhLlV0aWwuX3NpbXBsaWZ5QXJyYXksXHJcbiAgICAgICAgICAgICAgICBvcmlnU2V0dGVyID0gdGhpcy5zZXRBdHRyLFxyXG4gICAgICAgICAgICAgICAgbiwgYXJncztcclxuXHJcbiAgICAgICAgICAgIC8vIHRvIHByZXZlbnQgY3JlYXRpbmcgc2NvcGUgZnVuY3Rpb24gYXQgZWFjaCBsb29wXHJcbiAgICAgICAgICAgIHZhciBmdW5jID0gZnVuY3Rpb24obWV0aG9kTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmlnTWV0aG9kID0gdGhhdFttZXRob2ROYW1lXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGF0W21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBfc2ltcGxpZnlBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gb3JpZ01ldGhvZC5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdjbGVhclJlY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzWzJdID0gYXJnc1syXSAvIHRoYXQuY2FudmFzLmdldFBpeGVsUmF0aW8oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbM10gPSBhcmdzWzNdIC8gdGhhdC5jYW52YXMuZ2V0UGl4ZWxSYXRpbygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3RyYWNlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIG1ldGhvZHNcclxuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jKENPTlRFWFRfTUVUSE9EU1tuXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGF0dHJzXHJcbiAgICAgICAgICAgIHRoYXQuc2V0QXR0ciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgb3JpZ1NldHRlci5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fdHJhY2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBhcmd1bWVudHNbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsOiBhcmd1bWVudHNbMV1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgQ09OVEVYVF9QUk9QRVJUSUVTLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShLb252YS5Db250ZXh0LnByb3RvdHlwZSwgcHJvcCwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0W3Byb3BdO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHRbcHJvcF0gPSB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIEtvbnZhLlNjZW5lQ29udGV4dCA9IGZ1bmN0aW9uKGNhbnZhcykge1xyXG4gICAgICAgIEtvbnZhLkNvbnRleHQuY2FsbCh0aGlzLCBjYW52YXMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBLb252YS5TY2VuZUNvbnRleHQucHJvdG90eXBlID0ge1xyXG4gICAgICAgIF9maWxsQ29sb3I6IGZ1bmN0aW9uKHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBmaWxsID0gc2hhcGUuZmlsbCgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdmaWxsU3R5bGUnLCBmaWxsKTtcclxuICAgICAgICAgICAgc2hhcGUuX2ZpbGxGdW5jKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2ZpbGxQYXR0ZXJuOiBmdW5jdGlvbihzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgZmlsbFBhdHRlcm5YID0gc2hhcGUuZ2V0RmlsbFBhdHRlcm5YKCksXHJcbiAgICAgICAgICAgICAgICBmaWxsUGF0dGVyblkgPSBzaGFwZS5nZXRGaWxsUGF0dGVyblkoKSxcclxuICAgICAgICAgICAgICAgIGZpbGxQYXR0ZXJuU2NhbGUgPSBzaGFwZS5nZXRGaWxsUGF0dGVyblNjYWxlKCksXHJcbiAgICAgICAgICAgICAgICBmaWxsUGF0dGVyblJvdGF0aW9uID0gS29udmEuZ2V0QW5nbGUoc2hhcGUuZ2V0RmlsbFBhdHRlcm5Sb3RhdGlvbigpKSxcclxuICAgICAgICAgICAgICAgIGZpbGxQYXR0ZXJuT2Zmc2V0ID0gc2hhcGUuZ2V0RmlsbFBhdHRlcm5PZmZzZXQoKTtcclxuXHJcbiAgICAgICAgICAgIGlmKGZpbGxQYXR0ZXJuWCB8fCBmaWxsUGF0dGVyblkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlKGZpbGxQYXR0ZXJuWCB8fCAwLCBmaWxsUGF0dGVyblkgfHwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoZmlsbFBhdHRlcm5Sb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGUoZmlsbFBhdHRlcm5Sb3RhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoZmlsbFBhdHRlcm5TY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZShmaWxsUGF0dGVyblNjYWxlLngsIGZpbGxQYXR0ZXJuU2NhbGUueSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoZmlsbFBhdHRlcm5PZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlKC0xICogZmlsbFBhdHRlcm5PZmZzZXQueCwgLTEgKiBmaWxsUGF0dGVybk9mZnNldC55KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdmaWxsU3R5bGUnLCB0aGlzLmNyZWF0ZVBhdHRlcm4oc2hhcGUuZ2V0RmlsbFBhdHRlcm5JbWFnZSgpLCBzaGFwZS5nZXRGaWxsUGF0dGVyblJlcGVhdCgpIHx8ICdyZXBlYXQnKSk7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsbCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2ZpbGxMaW5lYXJHcmFkaWVudDogZnVuY3Rpb24oc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gc2hhcGUuZ2V0RmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludCgpLFxyXG4gICAgICAgICAgICAgICAgZW5kID0gc2hhcGUuZ2V0RmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnQoKSxcclxuICAgICAgICAgICAgICAgIGNvbG9yU3RvcHMgPSBzaGFwZS5nZXRGaWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzKCksXHJcbiAgICAgICAgICAgICAgICBncmQgPSB0aGlzLmNyZWF0ZUxpbmVhckdyYWRpZW50KHN0YXJ0LngsIHN0YXJ0LnksIGVuZC54LCBlbmQueSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29sb3JTdG9wcykge1xyXG4gICAgICAgICAgICAgICAgLy8gYnVpbGQgY29sb3Igc3RvcHNcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgbiA9IDA7IG4gPCBjb2xvclN0b3BzLmxlbmd0aDsgbiArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JkLmFkZENvbG9yU3RvcChjb2xvclN0b3BzW25dLCBjb2xvclN0b3BzW24gKyAxXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHIoJ2ZpbGxTdHlsZScsIGdyZCk7XHJcbiAgICAgICAgICAgICAgICBzaGFwZS5fZmlsbEZ1bmModGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9maWxsUmFkaWFsR3JhZGllbnQ6IGZ1bmN0aW9uKHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHNoYXBlLmdldEZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnQoKSxcclxuICAgICAgICAgICAgICAgIGVuZCA9IHNoYXBlLmdldEZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50KCksXHJcbiAgICAgICAgICAgICAgICBzdGFydFJhZGl1cyA9IHNoYXBlLmdldEZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzKCksXHJcbiAgICAgICAgICAgICAgICBlbmRSYWRpdXMgPSBzaGFwZS5nZXRGaWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXMoKSxcclxuICAgICAgICAgICAgICAgIGNvbG9yU3RvcHMgPSBzaGFwZS5nZXRGaWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzKCksXHJcbiAgICAgICAgICAgICAgICBncmQgPSB0aGlzLmNyZWF0ZVJhZGlhbEdyYWRpZW50KHN0YXJ0LngsIHN0YXJ0LnksIHN0YXJ0UmFkaXVzLCBlbmQueCwgZW5kLnksIGVuZFJhZGl1cyk7XHJcblxyXG4gICAgICAgICAgICAvLyBidWlsZCBjb2xvciBzdG9wc1xyXG4gICAgICAgICAgICBmb3IodmFyIG4gPSAwOyBuIDwgY29sb3JTdG9wcy5sZW5ndGg7IG4gKz0gMikge1xyXG4gICAgICAgICAgICAgICAgZ3JkLmFkZENvbG9yU3RvcChjb2xvclN0b3BzW25dLCBjb2xvclN0b3BzW24gKyAxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdmaWxsU3R5bGUnLCBncmQpO1xyXG4gICAgICAgICAgICB0aGlzLmZpbGwoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9maWxsOiBmdW5jdGlvbihzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgaGFzQ29sb3IgPSBzaGFwZS5maWxsKCksXHJcbiAgICAgICAgICAgICAgICBoYXNQYXR0ZXJuID0gc2hhcGUuZ2V0RmlsbFBhdHRlcm5JbWFnZSgpLFxyXG4gICAgICAgICAgICAgICAgaGFzTGluZWFyR3JhZGllbnQgPSBzaGFwZS5nZXRGaWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzKCksXHJcbiAgICAgICAgICAgICAgICBoYXNSYWRpYWxHcmFkaWVudCA9IHNoYXBlLmdldEZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMoKSxcclxuICAgICAgICAgICAgICAgIGZpbGxQcmlvcml0eSA9IHNoYXBlLmdldEZpbGxQcmlvcml0eSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gcHJpb3JpdHkgZmlsbHNcclxuICAgICAgICAgICAgaWYoaGFzQ29sb3IgJiYgZmlsbFByaW9yaXR5ID09PSAnY29sb3InKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9maWxsQ29sb3Ioc2hhcGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoaGFzUGF0dGVybiAmJiBmaWxsUHJpb3JpdHkgPT09ICdwYXR0ZXJuJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsbFBhdHRlcm4oc2hhcGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoaGFzTGluZWFyR3JhZGllbnQgJiYgZmlsbFByaW9yaXR5ID09PSAnbGluZWFyLWdyYWRpZW50Jykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsbExpbmVhckdyYWRpZW50KHNoYXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGhhc1JhZGlhbEdyYWRpZW50ICYmIGZpbGxQcmlvcml0eSA9PT0gJ3JhZGlhbC1ncmFkaWVudCcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGxSYWRpYWxHcmFkaWVudChzaGFwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbm93IGp1c3QgdHJ5IGFuZCBmaWxsIHdpdGggd2hhdGV2ZXIgaXMgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgIGVsc2UgaWYoaGFzQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGxDb2xvcihzaGFwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihoYXNQYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9maWxsUGF0dGVybihzaGFwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihoYXNMaW5lYXJHcmFkaWVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsbExpbmVhckdyYWRpZW50KHNoYXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGhhc1JhZGlhbEdyYWRpZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9maWxsUmFkaWFsR3JhZGllbnQoc2hhcGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfc3Ryb2tlOiBmdW5jdGlvbihzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgZGFzaCA9IHNoYXBlLmRhc2goKSxcclxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBzdHJva2VTY2FsZUVuYWJsZWQgZm9yIFRleHRcclxuICAgICAgICAgICAgICAgIHN0cm9rZVNjYWxlRW5hYmxlZCA9IChzaGFwZS5nZXRTdHJva2VTY2FsZUVuYWJsZWQoKSB8fCAoc2hhcGUgaW5zdGFuY2VvZiBLb252YS5UZXh0KSk7XHJcblxyXG4gICAgICAgICAgICBpZihzaGFwZS5oYXNTdHJva2UoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzdHJva2VTY2FsZUVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUxpbmVDYXAoc2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgaWYoZGFzaCAmJiBzaGFwZS5kYXNoRW5hYmxlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRMaW5lRGFzaChkYXNoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHIoJ2xpbmVXaWR0aCcsIHNoYXBlLnN0cm9rZVdpZHRoKCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdzdHJva2VTdHlsZScsIHNoYXBlLnN0cm9rZSgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXNoYXBlLmdldFNoYWRvd0ZvclN0cm9rZUVuYWJsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cignc2hhZG93Q29sb3InLCAncmdiYSgwLDAsMCwwKScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2hhcGUuX3N0cm9rZUZ1bmModGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFzdHJva2VTY2FsZUVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2FwcGx5U2hhZG93OiBmdW5jdGlvbihzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgdXRpbCA9IEtvbnZhLlV0aWwsXHJcbiAgICAgICAgICAgICAgICBjb2xvciA9IHV0aWwuZ2V0KHNoYXBlLmdldFNoYWRvd1JHQkEoKSwgJ2JsYWNrJyksXHJcbiAgICAgICAgICAgICAgICBibHVyID0gdXRpbC5nZXQoc2hhcGUuZ2V0U2hhZG93Qmx1cigpLCA1KSxcclxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHV0aWwuZ2V0KHNoYXBlLmdldFNoYWRvd09mZnNldCgpLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgICAgICAgICB5OiAwXHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgIG0gPSBzaGFwZS5nZXRBYnNvbHV0ZVRyYW5zZm9ybSgpLm0sXHJcbiAgICAgICAgICAgICAgICBzY2FsZVggPSBtWzBdLFxyXG4gICAgICAgICAgICAgICAgc2NhbGVZID0gbVszXTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignc2hhZG93Q29sb3InLCBjb2xvcik7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignc2hhZG93Qmx1cicsIGJsdXIpO1xyXG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3NoYWRvd09mZnNldFgnLCBvZmZzZXQueCAqIHNjYWxlWCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignc2hhZG93T2Zmc2V0WScsIG9mZnNldC55ICogc2NhbGVZKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuU2NlbmVDb250ZXh0LCBLb252YS5Db250ZXh0KTtcclxuXHJcbiAgICBLb252YS5IaXRDb250ZXh0ID0gZnVuY3Rpb24oY2FudmFzKSB7XHJcbiAgICAgICAgS29udmEuQ29udGV4dC5jYWxsKHRoaXMsIGNhbnZhcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIEtvbnZhLkhpdENvbnRleHQucHJvdG90eXBlID0ge1xyXG4gICAgICAgIF9maWxsOiBmdW5jdGlvbihzaGFwZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNhdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdmaWxsU3R5bGUnLCBzaGFwZS5jb2xvcktleSk7XHJcbiAgICAgICAgICAgIHNoYXBlLl9maWxsRnVuY0hpdCh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5yZXN0b3JlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfc3Ryb2tlOiBmdW5jdGlvbihzaGFwZSkge1xyXG4gICAgICAgICAgICBpZihzaGFwZS5oYXNTdHJva2UoKSAmJiBzaGFwZS5zdHJva2VIaXRFbmFibGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBzdHJva2VTY2FsZUVuYWJsZWQgZm9yIFRleHRcclxuICAgICAgICAgICAgICAgIHZhciBzdHJva2VTY2FsZUVuYWJsZWQgPSAoc2hhcGUuZ2V0U3Ryb2tlU2NhbGVFbmFibGVkKCkgfHwgKHNoYXBlIGluc3RhbmNlb2YgS29udmEuVGV4dCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzdHJva2VTY2FsZUVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5TGluZUNhcChzaGFwZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHIoJ2xpbmVXaWR0aCcsIHNoYXBlLnN0cm9rZVdpZHRoKCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdzdHJva2VTdHlsZScsIHNoYXBlLmNvbG9yS2V5KTtcclxuICAgICAgICAgICAgICAgIHNoYXBlLl9zdHJva2VGdW5jSGl0KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzdHJva2VTY2FsZUVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5IaXRDb250ZXh0LCBLb252YS5Db250ZXh0KTtcclxufSkoKTtcclxuXG4oZnVuY3Rpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICAvLyBDT05TVEFOVFNcclxuICAgIHZhciBHRVQgPSAnZ2V0JyxcclxuICAgICAgICBTRVQgPSAnc2V0JztcclxuXHJcbiAgICBLb252YS5GYWN0b3J5ID0ge1xyXG4gICAgICAgIGFkZEdldHRlclNldHRlcjogZnVuY3Rpb24oY29uc3RydWN0b3IsIGF0dHIsIGRlZiwgdmFsaWRhdG9yLCBhZnRlcikge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEdldHRlcihjb25zdHJ1Y3RvciwgYXR0ciwgZGVmKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRTZXR0ZXIoY29uc3RydWN0b3IsIGF0dHIsIHZhbGlkYXRvciwgYWZ0ZXIpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoY29uc3RydWN0b3IsIGF0dHIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkR2V0dGVyOiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgYXR0ciwgZGVmKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBHRVQgKyBLb252YS5VdGlsLl9jYXBpdGFsaXplKGF0dHIpO1xyXG5cclxuICAgICAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLmF0dHJzW2F0dHJdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkID8gZGVmIDogdmFsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkU2V0dGVyOiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgYXR0ciwgdmFsaWRhdG9yLCBhZnRlcikge1xyXG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gU0VUICsgS29udmEuVXRpbC5fY2FwaXRhbGl6ZShhdHRyKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odmFsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsaWRhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsaWRhdG9yLmNhbGwodGhpcywgdmFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRBdHRyKGF0dHIsIHZhbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGFmdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXI6IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBhdHRyLCBjb21wb25lbnRzLCB2YWxpZGF0b3IsIGFmdGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBsZW4gPSBjb21wb25lbnRzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGNhcGl0YWxpemUgPSBLb252YS5VdGlsLl9jYXBpdGFsaXplLFxyXG4gICAgICAgICAgICAgICAgZ2V0dGVyID0gR0VUICsgY2FwaXRhbGl6ZShhdHRyKSxcclxuICAgICAgICAgICAgICAgIHNldHRlciA9IFNFVCArIGNhcGl0YWxpemUoYXR0ciksXHJcbiAgICAgICAgICAgICAgICBuLCBjb21wb25lbnQ7XHJcblxyXG4gICAgICAgICAgICAvLyBnZXR0ZXJcclxuICAgICAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlW2dldHRlcl0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXQgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnRzW25dO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldFtjb21wb25lbnRdID0gdGhpcy5nZXRBdHRyKGF0dHIgKyBjYXBpdGFsaXplKGNvbXBvbmVudCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBzZXR0ZXJcclxuICAgICAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlW3NldHRlcl0gPSBmdW5jdGlvbih2YWwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvbGRWYWwgPSB0aGlzLmF0dHJzW2F0dHJdLFxyXG4gICAgICAgICAgICAgICAgICAgIGtleTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodmFsaWRhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsaWRhdG9yLmNhbGwodGhpcywgdmFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiB2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRBdHRyKGF0dHIgKyBjYXBpdGFsaXplKGtleSksIHZhbFtrZXldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlQ2hhbmdlRXZlbnQoYXR0ciwgb2xkVmFsLCB2YWwpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChhZnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoY29uc3RydWN0b3IsIGF0dHIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcjogZnVuY3Rpb24oY29uc3RydWN0b3IsIGF0dHIpIHtcclxuICAgICAgICAgICAgdmFyIGNhcGl0YWxpemVkQXR0ciA9IEtvbnZhLlV0aWwuX2NhcGl0YWxpemUoYXR0ciksXHJcbiAgICAgICAgICAgICAgICBzZXR0ZXIgPSBTRVQgKyBjYXBpdGFsaXplZEF0dHIsXHJcbiAgICAgICAgICAgICAgICBnZXR0ZXIgPSBHRVQgKyBjYXBpdGFsaXplZEF0dHI7XHJcblxyXG4gICAgICAgICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbYXR0cl0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIC8vIHNldHRpbmdcclxuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tzZXR0ZXJdKGFyZ3VtZW50c1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBnZXR0aW5nXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tnZXR0ZXJdKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyOiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgYXR0ciwgZGVmLCB2YWxpZGF0b3IpIHtcclxuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IEdFVCArIEtvbnZhLlV0aWwuX2NhcGl0YWxpemUoYXR0cik7XHJcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gYXR0ciArICcgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIHNvb24uIExvb2sgYXQgS29udmEgY2hhbmdlIGxvZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nO1xyXG4gICAgICAgICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgS29udmEuVXRpbC5lcnJvcihtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLmF0dHJzW2F0dHJdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkID8gZGVmIDogdmFsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmFkZFNldHRlcihjb25zdHJ1Y3RvciwgYXR0ciwgdmFsaWRhdG9yLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICBLb252YS5VdGlsLmVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKGNvbnN0cnVjdG9yLCBhdHRyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJhY2tDb21wYXQ6IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBtZXRob2RzKSB7XHJcbiAgICAgICAgICAgIEtvbnZhLlV0aWwuZWFjaChtZXRob2RzLCBmdW5jdGlvbihvbGRNZXRob2ROYW1lLCBuZXdNZXRob2ROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gY29uc3RydWN0b3IucHJvdG90eXBlW25ld01ldGhvZE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlW29sZE1ldGhvZE5hbWVdID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICBLb252YS5VdGlsLmVycm9yKG9sZE1ldGhvZE5hbWUgKyAnIG1ldGhvZCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgc29vbi4gVXNlICcgKyBuZXdNZXRob2ROYW1lICsgJyBpbnN0ZWFkJyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFmdGVyU2V0RmlsdGVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIEtvbnZhLlZhbGlkYXRvcnMgPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJHQkNvbXBvbmVudDogZnVuY3Rpb24odmFsKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWwgPiAyNTUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAyNTU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFscGhhQ29tcG9uZW50OiBmdW5jdGlvbih2YWwpIHtcclxuICAgICAgICAgICAgaWYgKHZhbCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNocm9tZSBkb2VzIG5vdCBob25vciBhbHBoYSB2YWx1ZXMgb2YgMFxyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPCAwLjAwMDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwLjAwMDE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufSkoKTtcclxuXG4oZnVuY3Rpb24oS29udmEpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8vIENPTlNUQU5UU1xyXG4gICAgdmFyIEFCU09MVVRFX09QQUNJVFkgPSAnYWJzb2x1dGVPcGFjaXR5JyxcclxuICAgICAgICBBQlNPTFVURV9UUkFOU0ZPUk0gPSAnYWJzb2x1dGVUcmFuc2Zvcm0nLFxyXG4gICAgICAgIENIQU5HRSA9ICdDaGFuZ2UnLFxyXG4gICAgICAgIENISUxEUkVOID0gJ2NoaWxkcmVuJyxcclxuICAgICAgICBET1QgPSAnLicsXHJcbiAgICAgICAgRU1QVFlfU1RSSU5HID0gJycsXHJcbiAgICAgICAgR0VUID0gJ2dldCcsXHJcbiAgICAgICAgSUQgPSAnaWQnLFxyXG4gICAgICAgIEtPTlZBID0gJ2tvbnZhJyxcclxuICAgICAgICBMSVNURU5JTkcgPSAnbGlzdGVuaW5nJyxcclxuICAgICAgICBNT1VTRUVOVEVSID0gJ21vdXNlZW50ZXInLFxyXG4gICAgICAgIE1PVVNFTEVBVkUgPSAnbW91c2VsZWF2ZScsXHJcbiAgICAgICAgTkFNRSA9ICduYW1lJyxcclxuICAgICAgICBTRVQgPSAnc2V0JyxcclxuICAgICAgICBTSEFQRSA9ICdTaGFwZScsXHJcbiAgICAgICAgU1BBQ0UgPSAnICcsXHJcbiAgICAgICAgU1RBR0UgPSAnc3RhZ2UnLFxyXG4gICAgICAgIFRSQU5TRk9STSA9ICd0cmFuc2Zvcm0nLFxyXG4gICAgICAgIFVQUEVSX1NUQUdFID0gJ1N0YWdlJyxcclxuICAgICAgICBWSVNJQkxFID0gJ3Zpc2libGUnLFxyXG4gICAgICAgIENMT05FX0JMQUNLX0xJU1QgPSBbJ2lkJ10sXHJcblxyXG4gICAgICAgIFRSQU5TRk9STV9DSEFOR0VfU1RSID0gW1xyXG4gICAgICAgICAgICAneENoYW5nZS5rb252YScsXHJcbiAgICAgICAgICAgICd5Q2hhbmdlLmtvbnZhJyxcclxuICAgICAgICAgICAgJ3NjYWxlWENoYW5nZS5rb252YScsXHJcbiAgICAgICAgICAgICdzY2FsZVlDaGFuZ2Uua29udmEnLFxyXG4gICAgICAgICAgICAnc2tld1hDaGFuZ2Uua29udmEnLFxyXG4gICAgICAgICAgICAnc2tld1lDaGFuZ2Uua29udmEnLFxyXG4gICAgICAgICAgICAncm90YXRpb25DaGFuZ2Uua29udmEnLFxyXG4gICAgICAgICAgICAnb2Zmc2V0WENoYW5nZS5rb252YScsXHJcbiAgICAgICAgICAgICdvZmZzZXRZQ2hhbmdlLmtvbnZhJyxcclxuICAgICAgICAgICAgJ3RyYW5zZm9ybXNFbmFibGVkQ2hhbmdlLmtvbnZhJ1xyXG4gICAgICAgIF0uam9pbihTUEFDRSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb2RlIGNvbnN0cnVjdG9yLiBOb2RlcyBhcmUgZW50aXRpZXMgdGhhdCBjYW4gYmUgdHJhbnNmb3JtZWQsIGxheWVyZWQsXHJcbiAgICAgKiBhbmQgaGF2ZSBib3VuZCBldmVudHMuIFRoZSBzdGFnZSwgbGF5ZXJzLCBncm91cHMsIGFuZCBzaGFwZXMgYWxsIGV4dGVuZCBOb2RlLlxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cclxuICAgICAqL1xyXG4gICAgS29udmEuTm9kZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuX2luaXQoY29uZmlnKTtcclxuICAgIH07XHJcblxyXG4gICAgS29udmEuVXRpbC5hZGRNZXRob2RzKEtvbnZhLk5vZGUsIHtcclxuICAgICAgICBfaW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5faWQgPSBLb252YS5pZENvdW50ZXIrKztcclxuICAgICAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycyA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLmF0dHJzID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlclVwVG9EYXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cnMoY29uZmlnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGV2ZW50IGJpbmRpbmdzIGZvciBjYWNoZSBoYW5kbGluZ1xyXG4gICAgICAgICAgICB0aGlzLm9uKFRSQU5TRk9STV9DSEFOR0VfU1RSLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFyQ2FjaGUoVFJBTlNGT1JNKTtcclxuICAgICAgICAgICAgICAgIHRoYXQuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9UUkFOU0ZPUk0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5vbigndmlzaWJsZUNoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKFZJU0lCTEUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5vbignbGlzdGVuaW5nQ2hhbmdlLmtvbnZhJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoTElTVEVOSU5HKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMub24oJ29wYWNpdHlDaGFuZ2Uua29udmEnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9PUEFDSVRZKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfY2xlYXJDYWNoZTogZnVuY3Rpb24oYXR0cil7XHJcbiAgICAgICAgICAgIGlmIChhdHRyKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fY2FjaGVbYXR0cl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZSA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0Q2FjaGU6IGZ1bmN0aW9uKGF0dHIsIHByaXZhdGVHZXR0ZXIpe1xyXG4gICAgICAgICAgICB2YXIgY2FjaGUgPSB0aGlzLl9jYWNoZVthdHRyXTtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIG5vdCBjYWNoZWQsIHdlIG5lZWQgdG8gc2V0IGl0IHVzaW5nIHRoZSBwcml2YXRlIGdldHRlciBtZXRob2QuXHJcbiAgICAgICAgICAgIGlmIChjYWNoZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZVthdHRyXSA9IHByaXZhdGVHZXR0ZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlW2F0dHJdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiB3aGVuIHRoZSBsb2dpYyBmb3IgYSBjYWNoZWQgcmVzdWx0IGRlcGVuZHMgb24gYW5jZXN0b3IgcHJvcGFnYXRpb24sIHVzZSB0aGlzXHJcbiAgICAgICAgICogbWV0aG9kIHRvIGNsZWFyIHNlbGYgYW5kIGNoaWxkcmVuIGNhY2hlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZTogZnVuY3Rpb24oYXR0cikge1xyXG4gICAgICAgICAgICB0aGlzLl9jbGVhckNhY2hlKGF0dHIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoYXR0cik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBjbGVhciBjYWNoZWQgY2FudmFzXHJcbiAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIG5vZGUuY2xlYXJDYWNoZSgpO1xyXG4gICAgICAgICovXHJcbiAgICAgICAgY2xlYXJDYWNoZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jYWNoZS5jYW52YXM7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlclVwVG9EYXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiAgY2FjaGUgbm9kZSB0byBpbXByb3ZlIGRyYXdpbmcgcGVyZm9ybWFuY2UsIGFwcGx5IGZpbHRlcnMsIG9yIGNyZWF0ZSBtb3JlIGFjY3VyYXRlXHJcbiAgICAgICAgKiAgaGl0IHJlZ2lvbnMuIEZvciBhbGwgYmFzaWMgc2hhcGVzIHNpemUgb2YgY2FjaGUgY2FudmFzIHdpbGwgYmUgYXV0b21hdGljYWxseSBkZXRlY3RlZC5cclxuICAgICAgICAqICBJZiB5b3UgbmVlZCB0byBjYWNoZSB5b3VyIGN1c3RvbSBgS29udmEuU2hhcGVgIGluc3RhbmNlIHlvdSBoYXZlIHRvIHBhc3Mgc2hhcGUncyBib3VuZGluZyBib3hcclxuICAgICAgICAqICBwcm9wZXJ0aWVzLiBMb29rIGF0IFtsaW5rIHRvIGRlbW8gcGFnZV0obGluayB0byBkZW1vIHBhZ2UpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ11cclxuICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXHJcbiAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxyXG4gICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXHJcbiAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXHJcbiAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRdICBpbmNyZWFzZSBjYW52YXMgc2l6ZSBieSBgb2Zmc2V0YCBwaXhlbCBpbiBhbGwgZGlyZWN0aW9ucy5cclxuICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmF3Qm9yZGVyXSB3aGVuIHNldCB0byB0cnVlLCBhIHJlZCBib3JkZXIgd2lsbCBiZSBkcmF3biBhcm91bmQgdGhlIGNhY2hlZFxyXG4gICAgICAgICogIHJlZ2lvbiBmb3IgZGVidWdnaW5nIHB1cnBvc2VzXHJcbiAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiAvLyBjYWNoZSBhIHNoYXBlIHdpdGggdGhlIHgseSBwb3NpdGlvbiBvZiB0aGUgYm91bmRpbmcgYm94IGF0IHRoZSBjZW50ZXIgYW5kXHJcbiAgICAgICAgKiAvLyB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgYm91bmRpbmcgYm94IGVxdWFsIHRvIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mXHJcbiAgICAgICAgKiAvLyB0aGUgc2hhcGUgb2J0YWluZWQgZnJvbSBzaGFwZS53aWR0aCgpIGFuZCBzaGFwZS5oZWlnaHQoKVxyXG4gICAgICAgICogaW1hZ2UuY2FjaGUoKTtcclxuICAgICAgICAqXHJcbiAgICAgICAgKiAvLyBjYWNoZSBhIG5vZGUgYW5kIGRlZmluZSB0aGUgYm91bmRpbmcgYm94IHBvc2l0aW9uIGFuZCBzaXplXHJcbiAgICAgICAgKiBub2RlLmNhY2hlKHtcclxuICAgICAgICAqICAgeDogLTMwLFxyXG4gICAgICAgICogICB5OiAtMzAsXHJcbiAgICAgICAgKiAgIHdpZHRoOiAxMDAsXHJcbiAgICAgICAgKiAgIGhlaWdodDogMjAwXHJcbiAgICAgICAgKiB9KTtcclxuICAgICAgICAqXHJcbiAgICAgICAgKiAvLyBjYWNoZSBhIG5vZGUgYW5kIGRyYXcgYSByZWQgYm9yZGVyIGFyb3VuZCB0aGUgYm91bmRpbmcgYm94XHJcbiAgICAgICAgKiAvLyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzXHJcbiAgICAgICAgKiBub2RlLmNhY2hlKHtcclxuICAgICAgICAqICAgeDogLTMwLFxyXG4gICAgICAgICogICB5OiAtMzAsXHJcbiAgICAgICAgKiAgIHdpZHRoOiAxMDAsXHJcbiAgICAgICAgKiAgIGhlaWdodDogMjAwLFxyXG4gICAgICAgICogICBvZmZzZXQgOiAxMCxcclxuICAgICAgICAqICAgZHJhd0JvcmRlcjogdHJ1ZVxyXG4gICAgICAgICogfSk7XHJcbiAgICAgICAgKi9cclxuICAgICAgICBjYWNoZTogZnVuY3Rpb24oY29uZmlnKSB7XHJcbiAgICAgICAgICAgIHZhciBjb25mID0gY29uZmlnIHx8IHt9LFxyXG4gICAgICAgICAgICAgICAgcmVjdCA9IHRoaXMuZ2V0Q2xpZW50UmVjdCh0cnVlKSxcclxuICAgICAgICAgICAgICAgIHdpZHRoID0gY29uZi53aWR0aCB8fCByZWN0LndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gY29uZi5oZWlnaHQgfHwgcmVjdC5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICB4ID0gY29uZi54IHx8IHJlY3QueCxcclxuICAgICAgICAgICAgICAgIHkgPSBjb25mLnkgfHwgcmVjdC55LFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gY29uZi5vZmZzZXQgfHwgMCxcclxuICAgICAgICAgICAgICAgIGRyYXdCb3JkZXIgPSBjb25mLmRyYXdCb3JkZXIgfHwgZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2lkdGggb3IgaGVpZ2h0IG9mIGNhY2hpbmcgY29uZmlndXJhdGlvbiBlcXVhbHMgMC4nKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgd2lkdGggKz0gb2Zmc2V0ICogMjtcclxuICAgICAgICAgICAgaGVpZ2h0ICs9IG9mZnNldCAqIDI7XHJcblxyXG4gICAgICAgICAgICB4IC09IG9mZnNldDtcclxuICAgICAgICAgICAgeSAtPSBvZmZzZXQ7XHJcblxyXG5cclxuICAgICAgICAgICAgdmFyIGNhY2hlZFNjZW5lQ2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBjYWNoZWRGaWx0ZXJDYW52YXMgPSBuZXcgS29udmEuU2NlbmVDYW52YXMoe1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIGNhY2hlZEhpdENhbnZhcyA9IG5ldyBLb252YS5IaXRDYW52YXMoe1xyXG4gICAgICAgICAgICAgICAgcGl4ZWxSYXRpbzogMSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBzY2VuZUNvbnRleHQgPSBjYWNoZWRTY2VuZUNhbnZhcy5nZXRDb250ZXh0KCksXHJcbiAgICAgICAgICAgIGhpdENvbnRleHQgPSBjYWNoZWRIaXRDYW52YXMuZ2V0Q29udGV4dCgpO1xyXG5cclxuICAgICAgICAgICAgY2FjaGVkSGl0Q2FudmFzLmlzQ2FjaGUgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jbGVhckNhY2hlKCk7XHJcblxyXG4gICAgICAgICAgICBzY2VuZUNvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgICAgICBoaXRDb250ZXh0LnNhdmUoKTtcclxuXHJcbiAgICAgICAgICAgIHNjZW5lQ29udGV4dC50cmFuc2xhdGUoLXgsIC15KTtcclxuICAgICAgICAgICAgaGl0Q29udGV4dC50cmFuc2xhdGUoLXgsIC15KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZHJhd1NjZW5lKGNhY2hlZFNjZW5lQ2FudmFzLCB0aGlzLCB0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy5kcmF3SGl0KGNhY2hlZEhpdENhbnZhcywgdGhpcywgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICBzY2VuZUNvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICBoaXRDb250ZXh0LnJlc3RvcmUoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBkcmF3IGEgcmVkIGJvcmRlciBhcm91bmQgdGhlIGNhY2hlZCBib3ggZm9yXHJcbiAgICAgICAgICAgIC8vIGRlYnVnZ2luZyBwdXJwb3Nlc1xyXG4gICAgICAgICAgICBpZiAoZHJhd0JvcmRlcikge1xyXG4gICAgICAgICAgICAgICAgc2NlbmVDb250ZXh0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgIHNjZW5lQ29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIHNjZW5lQ29udGV4dC5yZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgc2NlbmVDb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgc2NlbmVDb250ZXh0LnNldEF0dHIoJ3N0cm9rZVN0eWxlJywgJ3JlZCcpO1xyXG4gICAgICAgICAgICAgICAgc2NlbmVDb250ZXh0LnNldEF0dHIoJ2xpbmVXaWR0aCcsIDUpO1xyXG4gICAgICAgICAgICAgICAgc2NlbmVDb250ZXh0LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICAgICAgc2NlbmVDb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fY2FjaGUuY2FudmFzID0ge1xyXG4gICAgICAgICAgICAgICAgc2NlbmU6IGNhY2hlZFNjZW5lQ2FudmFzLFxyXG4gICAgICAgICAgICAgICAgZmlsdGVyOiBjYWNoZWRGaWx0ZXJDYW52YXMsXHJcbiAgICAgICAgICAgICAgICBoaXQ6IGNhY2hlZEhpdENhbnZhcyxcclxuICAgICAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgICAgICB5OiB5XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybiBjbGllbnQgcmVjdGFuZ2xlIHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSBvZiBub2RlLiBUaGlzIHJlY3RhbmdsZSBhbHNvIGluY2x1ZGUgYWxsIHN0eWxpbmcgKHN0cm9rZXMsIHNoYWRvd3MsIGV0YykuXHJcbiAgICAgICAgICogVGhlIHJlY3RhbmdsZSBwb3NpdGlvbiBpcyByZWxhdGl2ZSB0byBwYXJlbnQgY29udGFpbmVyLlxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwVHJhbnNmb3JtXSBmbGFnIHNob3VsZCB3ZSBza2lwIHRyYW5zZm9ybWF0aW9uIHRvIHJlY3RhbmdsZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHJlY3Qgd2l0aCB7eCwgeSwgd2lkdGgsIGhlaWdodH0gcHJvcGVydGllc1xyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogdmFyIHJlY3QgPSBuZXcgS29udmEuUmVjdCh7XHJcbiAgICAgICAgICogICAgICB3aWR0aCA6IDEwMCxcclxuICAgICAgICAgKiAgICAgIGhlaWdodCA6IDEwMCxcclxuICAgICAgICAgKiAgICAgIHggOiA1MCxcclxuICAgICAgICAgKiAgICAgIHkgOiA1MCxcclxuICAgICAgICAgKiAgICAgIHN0cm9rZVdpZHRoIDogNCxcclxuICAgICAgICAgKiAgICAgIHN0cm9rZSA6ICdibGFjaycsXHJcbiAgICAgICAgICogICAgICBvZmZzZXRYIDogNTAsXHJcbiAgICAgICAgICogICAgICBzY2FsZVkgOiAyXHJcbiAgICAgICAgICogfSk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAvLyBnZXQgY2xpZW50IHJlY3Qgd2l0aG91dCB0aGluayBvZmYgdHJhbnNmb3JtYXRpb25zIChwb3NpdGlvbiwgcm90YXRpb24sIHNjYWxlLCBvZmZzZXQsIGV0YylcclxuICAgICAgICAgKiByZWN0LmdldENsaWVudFJlY3QodHJ1ZSk7XHJcbiAgICAgICAgICogLy8gcmV0dXJucyB7XHJcbiAgICAgICAgICogLy8gICAgIHggOiAtMiwgICAvLyB0d28gcGl4ZWxzIGZvciBzdHJva2UgLyAyXHJcbiAgICAgICAgICogLy8gICAgIHkgOiAtMixcclxuICAgICAgICAgKiAvLyAgICAgd2lkdGggOiAxMDQsIC8vIGluY3JlYXNlZCBieSA0IGZvciBzdHJva2VcclxuICAgICAgICAgKiAvLyAgICAgaGVpZ2h0IDogMTA0XHJcbiAgICAgICAgICogLy99XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAvLyBnZXQgY2xpZW50IHJlY3Qgd2l0aCB0cmFuc2Zvcm1hdGlvbiBhcHBsaWVkXHJcbiAgICAgICAgICogcmVjdC5nZXRDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICogLy8gcmV0dXJucyBPYmplY3Qge3g6IC0yLCB5OiA0Niwgd2lkdGg6IDEwNCwgaGVpZ2h0OiAyMDh9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0Q2xpZW50UmVjdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vIGFic3RyYWN0IG1ldGhvZFxyXG4gICAgICAgICAgICAvLyByZWRlZmluZSBpbiBDb250YWluZXIgYW5kIFNoYXBlXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWJzdHJhY3QgXCJnZXRDbGllbnRSZWN0XCIgbWV0aG9kIGNhbGwnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF90cmFuc2Zvcm1lZFJlY3Q6IGZ1bmN0aW9uKHJlY3QpIHtcclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtcclxuICAgICAgICAgICAgICAgIHt4OiByZWN0LngsIHk6IHJlY3QueX0sXHJcbiAgICAgICAgICAgICAgICB7eDogcmVjdC54ICsgcmVjdC53aWR0aCwgeTogcmVjdC55fSxcclxuICAgICAgICAgICAgICAgIHt4OiByZWN0LnggKyByZWN0LndpZHRoLCB5OiByZWN0LnkgKyByZWN0LmhlaWdodH0sXHJcbiAgICAgICAgICAgICAgICB7eDogcmVjdC54LCB5OiByZWN0LnkgKyByZWN0LmhlaWdodH1cclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFk7XHJcbiAgICAgICAgICAgIHZhciB0cmFucyA9IHRoaXMuZ2V0VHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIHBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uKHBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWQgPSB0cmFucy5wb2ludChwb2ludCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWluWCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluWCA9IG1heFggPSB0cmFuc2Zvcm1lZC54O1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblkgPSBtYXhZID0gdHJhbnNmb3JtZWQueTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB0cmFuc2Zvcm1lZC54KTtcclxuICAgICAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB0cmFuc2Zvcm1lZC55KTtcclxuICAgICAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB0cmFuc2Zvcm1lZC54KTtcclxuICAgICAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB0cmFuc2Zvcm1lZC55KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiBNYXRoLnJvdW5kKG1pblgpLFxyXG4gICAgICAgICAgICAgICAgeTogTWF0aC5yb3VuZChtaW5ZKSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKG1heFggLSBtaW5YKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogTWF0aC5yb3VuZChtYXhZIC0gbWluWSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9kcmF3Q2FjaGVkU2NlbmVDYW52YXM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5T3BhY2l0eSh0aGlzKTtcclxuICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jYW52YXMueCxcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmNhbnZhcy55XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY2FjaGVDYW52YXMgPSB0aGlzLl9nZXRDYWNoZWRTY2VuZUNhbnZhcygpO1xyXG4gICAgICAgICAgICB2YXIgcmF0aW8gPSBjYWNoZUNhbnZhcy5waXhlbFJhdGlvO1xyXG5cclxuICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoY2FjaGVDYW52YXMuX2NhbnZhcywgMCwgMCwgY2FjaGVDYW52YXMud2lkdGggLyByYXRpbywgY2FjaGVDYW52YXMuaGVpZ2h0IC8gcmF0aW8pO1xyXG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9kcmF3Q2FjaGVkSGl0Q2FudmFzOiBmdW5jdGlvbihjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBjYWNoZWRDYW52YXMgPSB0aGlzLl9jYWNoZS5jYW52YXMsXHJcbiAgICAgICAgICAgICAgICBoaXRDYW52YXMgPSBjYWNoZWRDYW52YXMuaGl0O1xyXG4gICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcclxuICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jYW52YXMueCxcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmNhbnZhcy55XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGhpdENhbnZhcy5fY2FudmFzLCAwLCAwKTtcclxuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0Q2FjaGVkU2NlbmVDYW52YXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgZmlsdGVycyA9IHRoaXMuZmlsdGVycygpLFxyXG4gICAgICAgICAgICAgICAgY2FjaGVkQ2FudmFzID0gdGhpcy5fY2FjaGUuY2FudmFzLFxyXG4gICAgICAgICAgICAgICAgc2NlbmVDYW52YXMgPSBjYWNoZWRDYW52YXMuc2NlbmUsXHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJDYW52YXMgPSBjYWNoZWRDYW52YXMuZmlsdGVyLFxyXG4gICAgICAgICAgICAgICAgZmlsdGVyQ29udGV4dCA9IGZpbHRlckNhbnZhcy5nZXRDb250ZXh0KCksXHJcbiAgICAgICAgICAgICAgICBsZW4sIGltYWdlRGF0YSwgbiwgZmlsdGVyO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZpbHRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZmlsdGVyVXBUb0RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmF0aW8gPSBzY2VuZUNhbnZhcy5waXhlbFJhdGlvO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBmaWx0ZXJzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyQ29udGV4dC5jbGVhcigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29weSBjYWNoZWQgY2FudmFzIG9udG8gZmlsdGVyIGNvbnRleHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyQ29udGV4dC5kcmF3SW1hZ2Uoc2NlbmVDYW52YXMuX2NhbnZhcywgMCwgMCwgc2NlbmVDYW52YXMuZ2V0V2lkdGgoKSAvIHJhdGlvLCBzY2VuZUNhbnZhcy5nZXRIZWlnaHQoKSAvIHJhdGlvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhID0gZmlsdGVyQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgZmlsdGVyQ2FudmFzLmdldFdpZHRoKCksIGZpbHRlckNhbnZhcy5nZXRIZWlnaHQoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcHBseSBmaWx0ZXJzIHRvIGZpbHRlciBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gZmlsdGVyc1tuXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlci5jYWxsKHRoaXMsIGltYWdlRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJDb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdVbmFibGUgdG8gYXBwbHkgZmlsdGVyLiAnICsgZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbHRlclVwVG9EYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyQ2FudmFzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzY2VuZUNhbnZhcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGJpbmQgZXZlbnRzIHRvIHRoZSBub2RlLiBLb252YUpTIHN1cHBvcnRzIG1vdXNlb3ZlciwgbW91c2Vtb3ZlLFxyXG4gICAgICAgICAqICBtb3VzZW91dCwgbW91c2VlbnRlciwgbW91c2VsZWF2ZSwgbW91c2Vkb3duLCBtb3VzZXVwLCBtb3VzZXdoZWVsLCBjbGljaywgZGJsY2xpY2ssIHRvdWNoc3RhcnQsIHRvdWNobW92ZSxcclxuICAgICAgICAgKiAgdG91Y2hlbmQsIHRhcCwgZGJsdGFwLCBkcmFnc3RhcnQsIGRyYWdtb3ZlLCBhbmQgZHJhZ2VuZCBldmVudHMuIFRoZSBLb252YSBTdGFnZSBzdXBwb3J0c1xyXG4gICAgICAgICAqICBjb250ZW50TW91c2VvdmVyLCBjb250ZW50TW91c2Vtb3ZlLCBjb250ZW50TW91c2VvdXQsIGNvbnRlbnRNb3VzZWRvd24sIGNvbnRlbnRNb3VzZXVwLFxyXG4gICAgICAgICAqICBjb250ZW50Q2xpY2ssIGNvbnRlbnREYmxjbGljaywgY29udGVudFRvdWNoc3RhcnQsIGNvbnRlbnRUb3VjaG1vdmUsIGNvbnRlbnRUb3VjaGVuZCwgY29udGVudFRhcCxcclxuICAgICAgICAgKiAgYW5kIGNvbnRlbnREYmxUYXAuICBQYXNzIGluIGEgc3RyaW5nIG9mIGV2ZW50cyBkZWxpbW1pdGVkIGJ5IGEgc3BhY2UgdG8gYmluZCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxyXG4gICAgICAgICAqICBzdWNoIGFzICdtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUnLiBJbmNsdWRlIGEgbmFtZXNwYWNlIHRvIGJpbmQgYW5cclxuICAgICAgICAgKiAgZXZlbnQgYnkgbmFtZSBzdWNoIGFzICdjbGljay5mb29iYXInLlxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZ0U3RyIGUuZy4gJ2NsaWNrJywgJ21vdXNlZG93biB0b3VjaHN0YXJ0JywgJ21vdXNlZG93bi5mb28gdG91Y2hzdGFydC5mb28nXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgaGFuZGxlciBmdW5jdGlvbiBpcyBwYXNzZWQgYW4gZXZlbnQgb2JqZWN0XHJcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAvLyBhZGQgY2xpY2sgbGlzdGVuZXJcclxuICAgICAgICAgKiBub2RlLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAqICAgY29uc29sZS5sb2coJ3lvdSBjbGlja2VkIG1lIScpO1xyXG4gICAgICAgICAqIH0pO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogLy8gZ2V0IHRoZSB0YXJnZXQgbm9kZVxyXG4gICAgICAgICAqIG5vZGUub24oJ2NsaWNrJywgZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhldnQudGFyZ2V0KTtcclxuICAgICAgICAgKiB9KTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIC8vIHN0b3AgZXZlbnQgcHJvcGFnYXRpb25cclxuICAgICAgICAgKiBub2RlLm9uKCdjbGljaycsIGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgICAqICAgZXZ0LmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICogfSk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAvLyBiaW5kIG11bHRpcGxlIGxpc3RlbmVyc1xyXG4gICAgICAgICAqIG5vZGUub24oJ2NsaWNrIHRvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKCd5b3UgY2xpY2tlZC90b3VjaGVkIG1lIScpO1xyXG4gICAgICAgICAqIH0pO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogLy8gbmFtZXNwYWNlIGxpc3RlbmVyXHJcbiAgICAgICAgICogbm9kZS5vbignY2xpY2suZm9vJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICogICBjb25zb2xlLmxvZygneW91IGNsaWNrZWQvdG91Y2hlZCBtZSEnKTtcclxuICAgICAgICAgKiB9KTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIC8vIGdldCB0aGUgZXZlbnQgdHlwZVxyXG4gICAgICAgICAqIG5vZGUub24oJ2NsaWNrIHRhcCcsIGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgICAqICAgdmFyIGV2ZW50VHlwZSA9IGV2dC50eXBlO1xyXG4gICAgICAgICAqIH0pO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogLy8gZ2V0IG5hdGl2ZSBldmVudCBvYmplY3RcclxuICAgICAgICAgKiBub2RlLm9uKCdjbGljayB0YXAnLCBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICAgKiAgIHZhciBuYXRpdmVFdmVudCA9IGV2dC5ldnQ7XHJcbiAgICAgICAgICogfSk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAvLyBmb3IgY2hhbmdlIGV2ZW50cywgZ2V0IHRoZSBvbGQgYW5kIG5ldyB2YWxcclxuICAgICAgICAgKiBub2RlLm9uKCd4Q2hhbmdlJywgZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICogICB2YXIgb2xkVmFsID0gZXZ0Lm9sZFZhbDtcclxuICAgICAgICAgKiAgIHZhciBuZXdWYWwgPSBldnQubmV3VmFsO1xyXG4gICAgICAgICAqIH0pO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9uOiBmdW5jdGlvbihldnRTdHIsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdmFyIGV2ZW50cyA9IGV2dFN0ci5zcGxpdChTUEFDRSksXHJcbiAgICAgICAgICAgICAgICBsZW4gPSBldmVudHMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgbiwgZXZlbnQsIHBhcnRzLCBiYXNlRXZlbnQsIG5hbWU7XHJcblxyXG4gICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICogbG9vcCB0aHJvdWdoIHR5cGVzIGFuZCBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzIHRvXHJcbiAgICAgICAgICAgICAqIGVhY2ggb25lLiAgZWcuICdjbGljayBtb3VzZW92ZXIubmFtZXNwYWNlIG1vdXNlb3V0J1xyXG4gICAgICAgICAgICAgKiB3aWxsIGNyZWF0ZSB0aHJlZSBldmVudCBiaW5kaW5nc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZm9yKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50ID0gZXZlbnRzW25dO1xyXG4gICAgICAgICAgICAgICAgcGFydHMgPSBldmVudC5zcGxpdChET1QpO1xyXG4gICAgICAgICAgICAgICAgYmFzZUV2ZW50ID0gcGFydHNbMF07XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gcGFydHNbMV0gfHwgRU1QVFlfU1RSSU5HO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBldmVudHMgYXJyYXkgaWYgaXQgZG9lc24ndCBleGlzdFxyXG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuZXZlbnRMaXN0ZW5lcnNbYmFzZUV2ZW50XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnNbYmFzZUV2ZW50XSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnNbYmFzZUV2ZW50XS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHJlbW92ZSBldmVudCBiaW5kaW5ncyBmcm9tIHRoZSBub2RlLiBQYXNzIGluIGEgc3RyaW5nIG9mXHJcbiAgICAgICAgICogIGV2ZW50IHR5cGVzIGRlbGltbWl0ZWQgYnkgYSBzcGFjZSB0byByZW1vdmUgbXVsdGlwbGUgZXZlbnRcclxuICAgICAgICAgKiAgYmluZGluZ3MgYXQgb25jZSBzdWNoIGFzICdtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUnLlxyXG4gICAgICAgICAqICBpbmNsdWRlIGEgbmFtZXNwYWNlIHRvIHJlbW92ZSBhbiBldmVudCBiaW5kaW5nIGJ5IG5hbWVcclxuICAgICAgICAgKiAgc3VjaCBhcyAnY2xpY2suZm9vYmFyJy4gSWYgeW91IG9ubHkgZ2l2ZSBhIG5hbWUgbGlrZSAnLmZvb2JhcicsXHJcbiAgICAgICAgICogIGFsbCBldmVudHMgaW4gdGhhdCBuYW1lc3BhY2Ugd2lsbCBiZSByZW1vdmVkLlxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZ0U3RyIGUuZy4gJ2NsaWNrJywgJ21vdXNlZG93biB0b3VjaHN0YXJ0JywgJy5mb29iYXInXHJcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAvLyByZW1vdmUgbGlzdGVuZXJcclxuICAgICAgICAgKiBub2RlLm9mZignY2xpY2snKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIC8vIHJlbW92ZSBtdWx0aXBsZSBsaXN0ZW5lcnNcclxuICAgICAgICAgKiBub2RlLm9mZignY2xpY2sgdG91Y2hzdGFydCcpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogLy8gcmVtb3ZlIGxpc3RlbmVyIGJ5IG5hbWVcclxuICAgICAgICAgKiBub2RlLm9mZignY2xpY2suZm9vJyk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb2ZmOiBmdW5jdGlvbihldnRTdHIpIHtcclxuICAgICAgICAgICAgdmFyIGV2ZW50cyA9IChldnRTdHIgfHwgJycpLnNwbGl0KFNQQUNFKSxcclxuICAgICAgICAgICAgICAgIGxlbiA9IGV2ZW50cy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBuLCB0LCBldmVudCwgcGFydHMsIGJhc2VFdmVudCwgbmFtZTtcclxuXHJcbiAgICAgICAgICAgIGlmICghZXZ0U3RyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgYWxsIGV2ZW50c1xyXG4gICAgICAgICAgICAgICAgZm9yKHQgaW4gdGhpcy5ldmVudExpc3RlbmVycykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZih0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IobiA9IDA7IG4gPCBsZW47IG4rKykge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQgPSBldmVudHNbbl07XHJcbiAgICAgICAgICAgICAgICBwYXJ0cyA9IGV2ZW50LnNwbGl0KERPVCk7XHJcbiAgICAgICAgICAgICAgICBiYXNlRXZlbnQgPSBwYXJ0c1swXTtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBwYXJ0c1sxXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihiYXNlRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmV2ZW50TGlzdGVuZXJzW2Jhc2VFdmVudF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2ZmKGJhc2VFdmVudCwgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHQgaW4gdGhpcy5ldmVudExpc3RlbmVycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZmYodCwgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gc29tZSBldmVudCBhbGlhc2VzIGZvciB0aGlyZCBwYXJ0eSBpbnRlZ3JhdGlvbiBsaWtlIEhhbW1lckpTXHJcbiAgICAgICAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgIHZhciBlID0ge1xyXG4gICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcclxuICAgICAgICAgICAgICB0eXBlOiBldnQudHlwZSxcclxuICAgICAgICAgICAgICBldnQ6IGV2dFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmZpcmUoZXZ0LnR5cGUsIGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24odHlwZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIHBhc3MgbmF0aXZlIGV2ZW50IHRvIGhhbmRsZXJcclxuICAgICAgICAgICAgdGhpcy5vbih0eXBlLCBmdW5jdGlvbihldnQpe1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGV2dC5ldnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmYodHlwZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiByZW1vdmUgc2VsZiBmcm9tIHBhcmVudCwgYnV0IGRvbid0IGRlc3Ryb3lcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiBub2RlLnJlbW92ZSgpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xyXG5cclxuICAgICAgICAgICAgaWYocGFyZW50ICYmIHBhcmVudC5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudC5fc2V0Q2hpbGRyZW5JbmRpY2VzKCk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGV2ZXJ5IGNhY2hlZCBhdHRyIHRoYXQgaXMgY2FsY3VsYXRlZCB2aWEgbm9kZSB0cmVlXHJcbiAgICAgICAgICAgIC8vIHRyYXZlcnNhbCBtdXN0IGJlIGNsZWFyZWQgd2hlbiByZW1vdmluZyBhIG5vZGVcclxuICAgICAgICAgICAgdGhpcy5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKFNUQUdFKTtcclxuICAgICAgICAgICAgdGhpcy5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKEFCU09MVVRFX1RSQU5TRk9STSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShWSVNJQkxFKTtcclxuICAgICAgICAgICAgdGhpcy5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKExJU1RFTklORyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9PUEFDSVRZKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogcmVtb3ZlIGFuZCBkZXN0cm95IHNlbGZcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiBub2RlLmRlc3Ryb3koKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gaWRzIGFuZCBuYW1lcyBoYXNoZXNcclxuICAgICAgICAgICAgS29udmEuX3JlbW92ZUlkKHRoaXMuZ2V0SWQoKSk7XHJcbiAgICAgICAgICAgIEtvbnZhLl9yZW1vdmVOYW1lKHRoaXMuZ2V0TmFtZSgpLCB0aGlzLl9pZCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogZ2V0IGF0dHJcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJcclxuICAgICAgICAgKiBAcmV0dXJucyB7SW50ZWdlcnxTdHJpbmd8T2JqZWN0fEFycmF5fVxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogdmFyIHggPSBub2RlLmdldEF0dHIoJ3gnKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRBdHRyOiBmdW5jdGlvbihhdHRyKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBHRVQgKyBLb252YS5VdGlsLl9jYXBpdGFsaXplKGF0dHIpO1xyXG4gICAgICAgICAgICBpZihLb252YS5VdGlsLl9pc0Z1bmN0aW9uKHRoaXNbbWV0aG9kXSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW21ldGhvZF0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgZ2V0IGRpcmVjdGx5XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJzW2F0dHJdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBnZXQgYW5jZXN0b3JzXHJcbiAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Db2xsZWN0aW9ufVxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIHNoYXBlLmdldEFuY2VzdG9ycygpLmVhY2goZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICogICBjb25zb2xlLmxvZyhub2RlLmdldElkKCkpO1xyXG4gICAgICAgICogfSlcclxuICAgICAgICAqL1xyXG4gICAgICAgIGdldEFuY2VzdG9yczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpLFxyXG4gICAgICAgICAgICAgICAgYW5jZXN0b3JzID0gbmV3IEtvbnZhLkNvbGxlY3Rpb24oKTtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGFuY2VzdG9ycy5wdXNoKHBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhbmNlc3RvcnM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBnZXQgYXR0cnMgb2JqZWN0IGxpdGVyYWxcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJzIHx8IHt9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogc2V0IG11bHRpcGxlIGF0dHJzIGF0IG9uY2UgdXNpbmcgYW4gb2JqZWN0IGxpdGVyYWxcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBvYmplY3QgY29udGFpbmluZyBrZXkgdmFsdWUgcGFpcnNcclxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqIG5vZGUuc2V0QXR0cnMoe1xyXG4gICAgICAgICAqICAgeDogNSxcclxuICAgICAgICAgKiAgIGZpbGw6ICdyZWQnXHJcbiAgICAgICAgICogfSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0QXR0cnM6IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgICAgICAgICB2YXIga2V5LCBtZXRob2Q7XHJcblxyXG4gICAgICAgICAgICBpZighY29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3Ioa2V5IGluIGNvbmZpZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gQ0hJTERSRU4pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1ldGhvZCA9IFNFVCArIEtvbnZhLlV0aWwuX2NhcGl0YWxpemUoa2V5KTtcclxuICAgICAgICAgICAgICAgIC8vIHVzZSBzZXR0ZXIgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgICAgICBpZihLb252YS5VdGlsLl9pc0Z1bmN0aW9uKHRoaXNbbWV0aG9kXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzW21ldGhvZF0oY29uZmlnW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHNldCBkaXJlY3RseVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0QXR0cihrZXksIGNvbmZpZ1trZXldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGRldGVybWluZSBpZiBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzIGJ5IHRha2luZyBpbnRvIGFjY291bnQgYW5jZXN0b3JzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogUGFyZW50ICAgIHwgU2VsZiAgICAgIHwgaXNMaXN0ZW5pbmdcclxuICAgICAgICAgKiBsaXN0ZW5pbmcgfCBsaXN0ZW5pbmcgfFxyXG4gICAgICAgICAqIC0tLS0tLS0tLS0rLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgICogVCAgICAgICAgIHwgVCAgICAgICAgIHwgVFxyXG4gICAgICAgICAqIFQgICAgICAgICB8IEYgICAgICAgICB8IEZcclxuICAgICAgICAgKiBGICAgICAgICAgfCBUICAgICAgICAgfCBUXHJcbiAgICAgICAgICogRiAgICAgICAgIHwgRiAgICAgICAgIHwgRlxyXG4gICAgICAgICAqIC0tLS0tLS0tLS0rLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgICogVCAgICAgICAgIHwgSSAgICAgICAgIHwgVFxyXG4gICAgICAgICAqIEYgICAgICAgICB8IEkgICAgICAgICB8IEZcclxuICAgICAgICAgKiBJICAgICAgICAgfCBJICAgICAgICAgfCBUXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNMaXN0ZW5pbmc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoTElTVEVOSU5HLCB0aGlzLl9pc0xpc3RlbmluZyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfaXNMaXN0ZW5pbmc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgbGlzdGVuaW5nID0gdGhpcy5nZXRMaXN0ZW5pbmcoKSxcclxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XHJcblxyXG4gICAgICAgICAgICAvLyB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIGEgc2ltcGxpZmljYXRpb24gb2YgdGhlIHRydXRoIHRhYmxlIGFib3ZlLlxyXG4gICAgICAgICAgICAvLyBwbGVhc2UgbW9kaWZ5IGNhcmVmdWxseVxyXG4gICAgICAgICAgICBpZiAobGlzdGVuaW5nID09PSAnaW5oZXJpdCcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50LmlzTGlzdGVuaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5pbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGRldGVybWluZSBpZiBub2RlIGlzIHZpc2libGUgYnkgdGFraW5nIGludG8gYWNjb3VudCBhbmNlc3RvcnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBQYXJlbnQgICAgfCBTZWxmICAgICAgfCBpc1Zpc2libGVcclxuICAgICAgICAgKiB2aXNpYmxlICAgfCB2aXNpYmxlICAgfFxyXG4gICAgICAgICAqIC0tLS0tLS0tLS0rLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgICogVCAgICAgICAgIHwgVCAgICAgICAgIHwgVFxyXG4gICAgICAgICAqIFQgICAgICAgICB8IEYgICAgICAgICB8IEZcclxuICAgICAgICAgKiBGICAgICAgICAgfCBUICAgICAgICAgfCBUXHJcbiAgICAgICAgICogRiAgICAgICAgIHwgRiAgICAgICAgIHwgRlxyXG4gICAgICAgICAqIC0tLS0tLS0tLS0rLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgICogVCAgICAgICAgIHwgSSAgICAgICAgIHwgVFxyXG4gICAgICAgICAqIEYgICAgICAgICB8IEkgICAgICAgICB8IEZcclxuICAgICAgICAgKiBJICAgICAgICAgfCBJICAgICAgICAgfCBUXHJcblxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBpc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoVklTSUJMRSwgdGhpcy5faXNWaXNpYmxlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgdmlzaWJsZSA9IHRoaXMuZ2V0VmlzaWJsZSgpLFxyXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgYSBzaW1wbGlmaWNhdGlvbiBvZiB0aGUgdHJ1dGggdGFibGUgYWJvdmUuXHJcbiAgICAgICAgICAgIC8vIHBsZWFzZSBtb2RpZnkgY2FyZWZ1bGx5XHJcbiAgICAgICAgICAgIGlmICh2aXNpYmxlID09PSAnaW5oZXJpdCcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50LmlzVmlzaWJsZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaWJsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogZGV0ZXJtaW5lIGlmIGxpc3RlbmluZyBpcyBlbmFibGVkIGJ5IHRha2luZyBpbnRvIGFjY291bnQgZGVzY2VuZGFudHMuICBJZiBzZWxmIG9yIGFueSBjaGlsZHJlblxyXG4gICAgICAgICAqIGhhdmUgX2lzTGlzdGVuaW5nRW5hYmxlZCBzZXQgdG8gdHJ1ZSwgdGhlbiBzZWxmIGFsc28gaGFzIGxpc3RlbmluZyBlbmFibGVkLlxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBzaG91bGREcmF3SGl0OiBmdW5jdGlvbihjYW52YXMpIHtcclxuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gKGNhbnZhcyAmJiBjYW52YXMuaXNDYWNoZSkgfHwgKGxheWVyICYmIGxheWVyLmhpdEdyYXBoRW5hYmxlZCgpKVxyXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5pc0xpc3RlbmluZygpICYmIHRoaXMuaXNWaXNpYmxlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBzaG93IG5vZGVcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hvdzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VmlzaWJsZSh0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBoaWRlIG5vZGUuICBIaWRkZW4gbm9kZXMgYXJlIG5vIGxvbmdlciBkZXRlY3RhYmxlXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFZpc2libGUoZmFsc2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGdldCB6SW5kZXggcmVsYXRpdmUgdG8gdGhlIG5vZGUncyBzaWJsaW5ncyB3aG8gc2hhcmUgdGhlIHNhbWUgcGFyZW50XHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFpJbmRleDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4IHx8IDA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBnZXQgYWJzb2x1dGUgei1pbmRleCB3aGljaCB0YWtlcyBpbnRvIGFjY291bnQgc2libGluZ1xyXG4gICAgICAgICAqICBhbmQgYW5jZXN0b3IgaW5kaWNlc1xyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRBYnNvbHV0ZVpJbmRleDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBkZXB0aCA9IHRoaXMuZ2V0RGVwdGgoKSxcclxuICAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgaW5kZXggPSAwLFxyXG4gICAgICAgICAgICAgICAgbm9kZXMsIGxlbiwgbiwgY2hpbGQ7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRDaGlsZHJlbihjaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgbm9kZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvcihuID0gMDsgbiA8IGxlbjsgbisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltuXTtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihjaGlsZC5ub2RlVHlwZSAhPT0gU0hBUEUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMgPSBub2Rlcy5jb25jYXQoY2hpbGQuZ2V0Q2hpbGRyZW4oKS50b0FycmF5KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY2hpbGQuX2lkID09PSB0aGF0Ll9pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gbGVuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZihub2Rlcy5sZW5ndGggPiAwICYmIG5vZGVzWzBdLmdldERlcHRoKCkgPD0gZGVwdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRDaGlsZHJlbihub2Rlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYodGhhdC5ub2RlVHlwZSAhPT0gVVBQRVJfU1RBR0UpIHtcclxuICAgICAgICAgICAgICAgIGFkZENoaWxkcmVuKHRoYXQuZ2V0U3RhZ2UoKS5nZXRDaGlsZHJlbigpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogZ2V0IG5vZGUgZGVwdGggaW4gbm9kZSB0cmVlLiAgUmV0dXJucyBhbiBpbnRlZ2VyLlxyXG4gICAgICAgICAqICBlLmcuIFN0YWdlIGRlcHRoIHdpbGwgYWx3YXlzIGJlIDAuICBMYXllcnMgd2lsbCBhbHdheXMgYmUgMS4gIEdyb3VwcyBhbmQgU2hhcGVzIHdpbGwgYWx3YXlzXHJcbiAgICAgICAgICogIGJlID49IDJcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge0ludGVnZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0RGVwdGg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgZGVwdGggPSAwLFxyXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcblxyXG4gICAgICAgICAgICB3aGlsZShwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGRlcHRoKys7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkZXB0aDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbihwb3MpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRYKHBvcy54KTtcclxuICAgICAgICAgICAgdGhpcy5zZXRZKHBvcy55KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRQb3NpdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiB0aGlzLmdldFgoKSxcclxuICAgICAgICAgICAgICAgIHk6IHRoaXMuZ2V0WSgpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBnZXQgYWJzb2x1dGUgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgc3RhZ2UgY29udGFpbmVyIGRpdlxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEFic29sdXRlUG9zaXRpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgYWJzb2x1dGVNYXRyaXggPSB0aGlzLmdldEFic29sdXRlVHJhbnNmb3JtKCkuZ2V0TWF0cml4KCksXHJcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZVRyYW5zZm9ybSA9IG5ldyBLb252YS5UcmFuc2Zvcm0oKSxcclxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBjbG9uZSB0aGUgbWF0cml4IGFycmF5XHJcbiAgICAgICAgICAgIGFic29sdXRlVHJhbnNmb3JtLm0gPSBhYnNvbHV0ZU1hdHJpeC5zbGljZSgpO1xyXG4gICAgICAgICAgICBhYnNvbHV0ZVRyYW5zZm9ybS50cmFuc2xhdGUob2Zmc2V0LngsIG9mZnNldC55KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhYnNvbHV0ZVRyYW5zZm9ybS5nZXRUcmFuc2xhdGlvbigpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogc2V0IGFic29sdXRlIHBvc2l0aW9uXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb3NcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zLnhcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zLnlcclxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRBYnNvbHV0ZVBvc2l0aW9uOiBmdW5jdGlvbihwb3MpIHtcclxuICAgICAgICAgICAgdmFyIG9yaWdUcmFucyA9IHRoaXMuX2NsZWFyVHJhbnNmb3JtKCksXHJcbiAgICAgICAgICAgICAgICBpdDtcclxuXHJcbiAgICAgICAgICAgIC8vIGRvbid0IGNsZWFyIHRyYW5zbGF0aW9uXHJcbiAgICAgICAgICAgIHRoaXMuYXR0cnMueCA9IG9yaWdUcmFucy54O1xyXG4gICAgICAgICAgICB0aGlzLmF0dHJzLnkgPSBvcmlnVHJhbnMueTtcclxuICAgICAgICAgICAgZGVsZXRlIG9yaWdUcmFucy54O1xyXG4gICAgICAgICAgICBkZWxldGUgb3JpZ1RyYW5zLnk7XHJcblxyXG4gICAgICAgICAgICAvLyB1bnJhdmVsIHRyYW5zZm9ybVxyXG4gICAgICAgICAgICBpdCA9IHRoaXMuZ2V0QWJzb2x1dGVUcmFuc2Zvcm0oKTtcclxuXHJcbiAgICAgICAgICAgIGl0LmludmVydCgpO1xyXG4gICAgICAgICAgICBpdC50cmFuc2xhdGUocG9zLngsIHBvcy55KTtcclxuICAgICAgICAgICAgcG9zID0ge1xyXG4gICAgICAgICAgICAgICAgeDogdGhpcy5hdHRycy54ICsgaXQuZ2V0VHJhbnNsYXRpb24oKS54LFxyXG4gICAgICAgICAgICAgICAgeTogdGhpcy5hdHRycy55ICsgaXQuZ2V0VHJhbnNsYXRpb24oKS55XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHt4OiBwb3MueCwgeTogcG9zLnl9KTtcclxuICAgICAgICAgICAgdGhpcy5fc2V0VHJhbnNmb3JtKG9yaWdUcmFucyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9zZXRUcmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXk7XHJcblxyXG4gICAgICAgICAgICBmb3Ioa2V5IGluIHRyYW5zKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJzW2tleV0gPSB0cmFuc1trZXldO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9jbGVhckNhY2hlKFRSQU5TRk9STSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9UUkFOU0ZPUk0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2NsZWFyVHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHRyYW5zID0ge1xyXG4gICAgICAgICAgICAgICAgeDogdGhpcy5nZXRYKCksXHJcbiAgICAgICAgICAgICAgICB5OiB0aGlzLmdldFkoKSxcclxuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiB0aGlzLmdldFJvdGF0aW9uKCksXHJcbiAgICAgICAgICAgICAgICBzY2FsZVg6IHRoaXMuZ2V0U2NhbGVYKCksXHJcbiAgICAgICAgICAgICAgICBzY2FsZVk6IHRoaXMuZ2V0U2NhbGVZKCksXHJcbiAgICAgICAgICAgICAgICBvZmZzZXRYOiB0aGlzLmdldE9mZnNldFgoKSxcclxuICAgICAgICAgICAgICAgIG9mZnNldFk6IHRoaXMuZ2V0T2Zmc2V0WSgpLFxyXG4gICAgICAgICAgICAgICAgc2tld1g6IHRoaXMuZ2V0U2tld1goKSxcclxuICAgICAgICAgICAgICAgIHNrZXdZOiB0aGlzLmdldFNrZXdZKClcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYXR0cnMueCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cnMueSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cnMucm90YXRpb24gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmF0dHJzLnNjYWxlWCA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cnMuc2NhbGVZID0gMTtcclxuICAgICAgICAgICAgdGhpcy5hdHRycy5vZmZzZXRYID0gMDtcclxuICAgICAgICAgICAgdGhpcy5hdHRycy5vZmZzZXRZID0gMDtcclxuICAgICAgICAgICAgdGhpcy5hdHRycy5za2V3WCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cnMuc2tld1kgPSAwO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fY2xlYXJDYWNoZShUUkFOU0ZPUk0pO1xyXG4gICAgICAgICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoQUJTT0xVVEVfVFJBTlNGT1JNKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHJldHVybiBvcmlnaW5hbCB0cmFuc2Zvcm1cclxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogbW92ZSBub2RlIGJ5IGFuIGFtb3VudCByZWxhdGl2ZSB0byBpdHMgY3VycmVudCBwb3NpdGlvblxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hhbmdlXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYW5nZS54XHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYW5nZS55XHJcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAvLyBtb3ZlIG5vZGUgaW4geCBkaXJlY3Rpb24gYnkgMXB4IGFuZCB5IGRpcmVjdGlvbiBieSAycHhcclxuICAgICAgICAgKiBub2RlLm1vdmUoe1xyXG4gICAgICAgICAqICAgeDogMSxcclxuICAgICAgICAgKiAgIHk6IDIpXHJcbiAgICAgICAgICogfSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbW92ZTogZnVuY3Rpb24oY2hhbmdlKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGFuZ2VYID0gY2hhbmdlLngsXHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VZID0gY2hhbmdlLnksXHJcbiAgICAgICAgICAgICAgICB4ID0gdGhpcy5nZXRYKCksXHJcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5nZXRZKCk7XHJcblxyXG4gICAgICAgICAgICBpZihjaGFuZ2VYICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHggKz0gY2hhbmdlWDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoY2hhbmdlWSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB5ICs9IGNoYW5nZVk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24oe3g6IHgsIHk6IHl9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZWFjaEFuY2VzdG9yUmV2ZXJzZTogZnVuY3Rpb24oZnVuYywgdG9wKSB7XHJcbiAgICAgICAgICAgIHZhciBmYW1pbHkgPSBbXSxcclxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCksXHJcbiAgICAgICAgICAgICAgICBsZW4sIG47XHJcblxyXG4gICAgICAgICAgICAvLyBpZiB0b3Agbm9kZSBpcyBkZWZpbmVkLCBhbmQgdGhpcyBub2RlIGlzIHRvcCBub2RlLFxyXG4gICAgICAgICAgICAvLyB0aGVyZSdzIG5vIG5lZWQgdG8gYnVpbGQgYSBmYW1pbHkgdHJlZS4gIGp1c3QgZXhlY3V0ZVxyXG4gICAgICAgICAgICAvLyBmdW5jIHdpdGggdGhpcyBiZWNhdXNlIGl0IHdpbGwgYmUgdGhlIG9ubHkgbm9kZVxyXG4gICAgICAgICAgICBpZiAodG9wICYmIHRvcC5faWQgPT09IHRoaXMuX2lkKSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZhbWlseS51bnNoaWZ0KHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUocGFyZW50ICYmICghdG9wIHx8IHBhcmVudC5faWQgIT09IHRvcC5faWQpKSB7XHJcbiAgICAgICAgICAgICAgICBmYW1pbHkudW5zaGlmdChwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGVuID0gZmFtaWx5Lmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcclxuICAgICAgICAgICAgICAgIGZ1bmMoZmFtaWx5W25dKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogcm90YXRlIG5vZGUgYnkgYW4gYW1vdW50IGluIGRlZ3JlZXMgcmVsYXRpdmUgdG8gaXRzIGN1cnJlbnQgcm90YXRpb25cclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHRoZXRhXHJcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcm90YXRlOiBmdW5jdGlvbih0aGV0YSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFJvdGF0aW9uKHRoaXMuZ2V0Um90YXRpb24oKSArIHRoZXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBtb3ZlIG5vZGUgdG8gdGhlIHRvcCBvZiBpdHMgc2libGluZ3NcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbW92ZVRvVG9wOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdOb2RlIGhhcyBubyBwYXJlbnQuIG1vdmVUb1RvcCBmdW5jdGlvbiBpcyBpZ25vcmVkLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnB1c2godGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50Ll9zZXRDaGlsZHJlbkluZGljZXMoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBtb3ZlIG5vZGUgdXBcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IGZsYWcgaXMgbW92ZWQgb3Igbm90XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbW92ZVVwOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdOb2RlIGhhcyBubyBwYXJlbnQuIG1vdmVVcCBmdW5jdGlvbiBpcyBpZ25vcmVkLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgsXHJcbiAgICAgICAgICAgICAgICBsZW4gPSB0aGlzLnBhcmVudC5nZXRDaGlsZHJlbigpLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYoaW5kZXggPCBsZW4gLSAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4ICsgMSwgMCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5fc2V0Q2hpbGRyZW5JbmRpY2VzKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBtb3ZlIG5vZGUgZG93blxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBtb3ZlRG93bjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwud2FybignTm9kZSBoYXMgbm8gcGFyZW50LiBtb3ZlRG93biBmdW5jdGlvbiBpcyBpZ25vcmVkLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XHJcbiAgICAgICAgICAgIGlmKGluZGV4ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCAtIDEsIDAsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuX3NldENoaWxkcmVuSW5kaWNlcygpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogbW92ZSBub2RlIHRvIHRoZSBib3R0b20gb2YgaXRzIHNpYmxpbmdzXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG1vdmVUb0JvdHRvbTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwud2FybignTm9kZSBoYXMgbm8gcGFyZW50LiBtb3ZlVG9Cb3R0b20gZnVuY3Rpb24gaXMgaWdub3JlZC4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xyXG4gICAgICAgICAgICBpZihpbmRleCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jaGlsZHJlbi51bnNoaWZ0KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuX3NldENoaWxkcmVuSW5kaWNlcygpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogc2V0IHpJbmRleCByZWxhdGl2ZSB0byBzaWJsaW5nc1xyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHpJbmRleFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldFpJbmRleDogZnVuY3Rpb24oekluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwud2FybignTm9kZSBoYXMgbm8gcGFyZW50LiB6SW5kZXggcGFyYW1ldGVyIGlzIGlnbm9yZWQuJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKHpJbmRleCwgMCwgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50Ll9zZXRDaGlsZHJlbkluZGljZXMoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBnZXQgYWJzb2x1dGUgb3BhY2l0eVxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEFic29sdXRlT3BhY2l0eTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZShBQlNPTFVURV9PUEFDSVRZLCB0aGlzLl9nZXRBYnNvbHV0ZU9wYWNpdHkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldEFic29sdXRlT3BhY2l0eTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBhYnNPcGFjaXR5ID0gdGhpcy5nZXRPcGFjaXR5KCk7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuZ2V0UGFyZW50KCkpIHtcclxuICAgICAgICAgICAgICAgIGFic09wYWNpdHkgKj0gdGhpcy5nZXRQYXJlbnQoKS5nZXRBYnNvbHV0ZU9wYWNpdHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYWJzT3BhY2l0eTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIG1vdmUgbm9kZSB0byBhbm90aGVyIGNvbnRhaW5lclxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge0NvbnRhaW5lcn0gbmV3Q29udGFpbmVyXHJcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAvLyBtb3ZlIG5vZGUgZnJvbSBjdXJyZW50IGxheWVyIGludG8gbGF5ZXIyXHJcbiAgICAgICAgICogbm9kZS5tb3ZlVG8obGF5ZXIyKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBtb3ZlVG86IGZ1bmN0aW9uKG5ld0NvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nIGlmIG5ldyBjb250YWluZXIgaXMgYWxyZWFkeSBwYXJlbnRcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0UGFyZW50KCkgIT09IG5ld0NvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIG5ld0NvbnRhaW5lci5hZGQodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBjb252ZXJ0IE5vZGUgaW50byBhbiBvYmplY3QgZm9yIHNlcmlhbGl6YXRpb24uICBSZXR1cm5zIGFuIG9iamVjdC5cclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBvYmogPSB7fSxcclxuICAgICAgICAgICAgICAgIGF0dHJzID0gdGhpcy5nZXRBdHRycygpLFxyXG4gICAgICAgICAgICAgICAga2V5LCB2YWwsIGdldHRlciwgZGVmYXVsdFZhbHVlO1xyXG5cclxuICAgICAgICAgICAgb2JqLmF0dHJzID0ge307XHJcblxyXG4gICAgICAgICAgICBmb3Ioa2V5IGluIGF0dHJzKSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgPSBhdHRyc1trZXldO1xyXG4gICAgICAgICAgICAgICAgLy8gc2VyaWFsaXplIG9ubHkgYXR0cmlidXRlcyB0aGF0IGFyZSBub3QgZnVuY3Rpb24sIGltYWdlLCBET00sIG9yIG9iamVjdHMgd2l0aCBtZXRob2RzXHJcbiAgICAgICAgICAgICAgICBpZiAoS29udmEuVXRpbC5faXNGdW5jdGlvbih2YWwpIHx8IEtvbnZhLlV0aWwuX2lzRWxlbWVudCh2YWwpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKEtvbnZhLlV0aWwuX2lzT2JqZWN0KHZhbCkgfHwgS29udmEuVXRpbC5faGFzTWV0aG9kcyh2YWwpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZ2V0dGVyID0gdGhpc1trZXldO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGF0dHIgdmFsdWUgc28gdGhhdCB3ZSBjYW4gZXh0cmFjdCB0aGUgZGVmYXVsdCB2YWx1ZSBmcm9tIHRoZSBnZXR0ZXJcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyc1trZXldO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwodGhpcykgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBhdHRyIHZhbHVlXHJcbiAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZSAhPT0gdmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqLmF0dHJzW2tleV0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG9iai5jbGFzc05hbWUgPSB0aGlzLmdldENsYXNzTmFtZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogY29udmVydCBOb2RlIGludG8gYSBKU09OIHN0cmluZy4gIFJldHVybnMgYSBKU09OIHN0cmluZy5cclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ319XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdG9KU09OOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9PYmplY3QoKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBnZXQgcGFyZW50IGNvbnRhaW5lclxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBnZXQgbGF5ZXIgYW5jZXN0b3JcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLkxheWVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldExheWVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQgPyBwYXJlbnQuZ2V0TGF5ZXIoKSA6IG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBnZXQgc3RhZ2UgYW5jZXN0b3JcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLlN0YWdlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFN0YWdlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKFNUQUdFLCB0aGlzLl9nZXRTdGFnZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0U3RhZ2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcclxuICAgICAgICAgICAgaWYocGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50LmdldFN0YWdlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBmaXJlIGV2ZW50XHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgZXZlbnQgdHlwZS4gIGNhbiBiZSBhIHJlZ3VsYXIgZXZlbnQsIGxpa2UgY2xpY2ssIG1vdXNlb3Zlciwgb3IgbW91c2VvdXQsIG9yIGl0IGNhbiBiZSBhIGN1c3RvbSBldmVudCwgbGlrZSBteUN1c3RvbUV2ZW50XHJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gW2V2dF0gZXZlbnQgb2JqZWN0XHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbYnViYmxlXSBzZXR0aW5nIHRoZSB2YWx1ZSB0byBmYWxzZSwgb3IgbGVhdmluZyBpdCB1bmRlZmluZWQsIHdpbGwgcmVzdWx0IGluIHRoZSBldmVudFxyXG4gICAgICAgICAqICBub3QgYnViYmxpbmcuICBTZXR0aW5nIHRoZSB2YWx1ZSB0byB0cnVlIHdpbGwgcmVzdWx0IGluIHRoZSBldmVudCBidWJibGluZy5cclxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqIC8vIG1hbnVhbGx5IGZpcmUgY2xpY2sgZXZlbnRcclxuICAgICAgICAgKiBub2RlLmZpcmUoJ2NsaWNrJyk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAvLyBmaXJlIGN1c3RvbSBldmVudFxyXG4gICAgICAgICAqIG5vZGUuZmlyZSgnZm9vJyk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAvLyBmaXJlIGN1c3RvbSBldmVudCB3aXRoIGN1c3RvbSBldmVudCBvYmplY3RcclxuICAgICAgICAgKiBub2RlLmZpcmUoJ2ZvbycsIHtcclxuICAgICAgICAgKiAgIGJhcjogMTBcclxuICAgICAgICAgKiB9KTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIC8vIGZpcmUgY2xpY2sgZXZlbnQgdGhhdCBidWJibGVzXHJcbiAgICAgICAgICogbm9kZS5maXJlKCdjbGljaycsIG51bGwsIHRydWUpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZpcmU6IGZ1bmN0aW9uKGV2ZW50VHlwZSwgZXZ0LCBidWJibGUpIHtcclxuICAgICAgICAgICAgLy8gYnViYmxlXHJcbiAgICAgICAgICAgIGlmIChidWJibGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmVBbmRCdWJibGUoZXZlbnRUeXBlLCBldnQgfHwge30pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG5vIGJ1YmJsZVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmUoZXZlbnRUeXBlLCBldnQgfHwge30pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogZ2V0IGFic29sdXRlIHRyYW5zZm9ybSBvZiB0aGUgbm9kZSB3aGljaCB0YWtlcyBpbnRvXHJcbiAgICAgICAgICogIGFjY291bnQgaXRzIGFuY2VzdG9yIHRyYW5zZm9ybXNcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRBYnNvbHV0ZVRyYW5zZm9ybTogZnVuY3Rpb24odG9wKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIHVzaW5nIGFuIGFyZ3VtZW50LCB3ZSBjYW4ndCBjYWNoZSB0aGUgcmVzdWx0LlxyXG4gICAgICAgICAgICBpZiAodG9wKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QWJzb2x1dGVUcmFuc2Zvcm0odG9wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiBubyBhcmd1bWVudCwgd2UgY2FuIGNhY2hlIHRoZSByZXN1bHRcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoQUJTT0xVVEVfVFJBTlNGT1JNLCB0aGlzLl9nZXRBYnNvbHV0ZVRyYW5zZm9ybSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRBYnNvbHV0ZVRyYW5zZm9ybTogZnVuY3Rpb24odG9wKSB7XHJcbiAgICAgICAgICAgIHZhciBhdCA9IG5ldyBLb252YS5UcmFuc2Zvcm0oKSxcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybXNFbmFibGVkLCB0cmFucztcclxuXHJcbiAgICAgICAgICAgIC8vIHN0YXJ0IHdpdGggc3RhZ2UgYW5kIHRyYXZlcnNlIGRvd253YXJkcyB0byBzZWxmXHJcbiAgICAgICAgICAgIHRoaXMuX2VhY2hBbmNlc3RvclJldmVyc2UoZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3Jtc0VuYWJsZWQgPSBub2RlLnRyYW5zZm9ybXNFbmFibGVkKCk7XHJcbiAgICAgICAgICAgICAgICB0cmFucyA9IG5vZGUuZ2V0VHJhbnNmb3JtKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybXNFbmFibGVkID09PSAnYWxsJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGF0Lm11bHRpcGx5KHRyYW5zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRyYW5zZm9ybXNFbmFibGVkID09PSAncG9zaXRpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXQudHJhbnNsYXRlKG5vZGUueCgpLCBub2RlLnkoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRvcCk7XHJcbiAgICAgICAgICAgIHJldHVybiBhdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGdldCB0cmFuc2Zvcm0gb2YgdGhlIG5vZGVcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRUcmFuc2Zvcm06IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoVFJBTlNGT1JNLCB0aGlzLl9nZXRUcmFuc2Zvcm0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldFRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBtID0gbmV3IEtvbnZhLlRyYW5zZm9ybSgpLFxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMuZ2V0WCgpLFxyXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuZ2V0WSgpLFxyXG4gICAgICAgICAgICAgICAgcm90YXRpb24gPSBLb252YS5nZXRBbmdsZSh0aGlzLmdldFJvdGF0aW9uKCkpLFxyXG4gICAgICAgICAgICAgICAgc2NhbGVYID0gdGhpcy5nZXRTY2FsZVgoKSxcclxuICAgICAgICAgICAgICAgIHNjYWxlWSA9IHRoaXMuZ2V0U2NhbGVZKCksXHJcbiAgICAgICAgICAgICAgICBza2V3WCA9IHRoaXMuZ2V0U2tld1goKSxcclxuICAgICAgICAgICAgICAgIHNrZXdZID0gdGhpcy5nZXRTa2V3WSgpLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0WCA9IHRoaXMuZ2V0T2Zmc2V0WCgpLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0WSA9IHRoaXMuZ2V0T2Zmc2V0WSgpO1xyXG5cclxuICAgICAgICAgICAgaWYoeCAhPT0gMCB8fCB5ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBtLnRyYW5zbGF0ZSh4LCB5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihyb3RhdGlvbiAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgbS5yb3RhdGUocm90YXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHNrZXdYICE9PSAwIHx8IHNrZXdZICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBtLnNrZXcoc2tld1gsIHNrZXdZKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBtLnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihvZmZzZXRYICE9PSAwIHx8IG9mZnNldFkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIG0udHJhbnNsYXRlKC0xICogb2Zmc2V0WCwgLTEgKiBvZmZzZXRZKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBjbG9uZSBub2RlLiAgUmV0dXJucyBhIG5ldyBOb2RlIGluc3RhbmNlIHdpdGggaWRlbnRpY2FsIGF0dHJpYnV0ZXMuICBZb3UgY2FuIGFsc28gb3ZlcnJpZGVcclxuICAgICAgICAgKiAgdGhlIG5vZGUgcHJvcGVydGllcyB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLCBlbmFibGluZyB5b3UgdG8gdXNlIGFuIGV4aXN0aW5nIG5vZGUgYXMgYSB0ZW1wbGF0ZVxyXG4gICAgICAgICAqICBmb3IgYW5vdGhlciBub2RlXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogb3ZlcnJpZGUgYXR0cnNcclxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqIC8vIHNpbXBsZSBjbG9uZVxyXG4gICAgICAgICAqIHZhciBjbG9uZSA9IG5vZGUuY2xvbmUoKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIC8vIGNsb25lIGEgbm9kZSBhbmQgb3ZlcnJpZGUgdGhlIHggcG9zaXRpb25cclxuICAgICAgICAgKiB2YXIgY2xvbmUgPSByZWN0LmNsb25lKHtcclxuICAgICAgICAgKiAgIHg6IDVcclxuICAgICAgICAgKiB9KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgICAgIC8vIGluc3RhbnRpYXRlIG5ldyBub2RlXHJcbiAgICAgICAgICAgIHZhciBhdHRycyA9IEtvbnZhLlV0aWwuY2xvbmVPYmplY3QodGhpcy5hdHRycyksXHJcbiAgICAgICAgICAgICAgICBrZXksIGFsbExpc3RlbmVycywgbGVuLCBuLCBsaXN0ZW5lcjtcclxuICAgICAgICAgICAgLy8gZmlsdGVyIGJsYWNrIGF0dHJzXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gQ0xPTkVfQkxBQ0tfTElTVCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrQXR0ciA9IENMT05FX0JMQUNLX0xJU1RbaV07XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgYXR0cnNbYmxvY2tBdHRyXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhcHBseSBhdHRyIG92ZXJyaWRlc1xyXG4gICAgICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcclxuICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSBvYmpba2V5XTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG5vZGUgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihhdHRycyk7XHJcbiAgICAgICAgICAgIC8vIGNvcHkgb3ZlciBsaXN0ZW5lcnNcclxuICAgICAgICAgICAgZm9yKGtleSBpbiB0aGlzLmV2ZW50TGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBhbGxMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzW2tleV07XHJcbiAgICAgICAgICAgICAgICBsZW4gPSBhbGxMaXN0ZW5lcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGFsbExpc3RlbmVyc1tuXTtcclxuICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIGRvbid0IGluY2x1ZGUga29udmEgbmFtZXNwYWNlZCBsaXN0ZW5lcnMgYmVjYXVzZVxyXG4gICAgICAgICAgICAgICAgICAgICAqICB0aGVzZSBhcmUgZ2VuZXJhdGVkIGJ5IHRoZSBjb25zdHJ1Y3RvcnNcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBpZihsaXN0ZW5lci5uYW1lLmluZGV4T2YoS09OVkEpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBsaXN0ZW5lcnMgYXJyYXkgZG9lc24ndCBleGlzdCwgdGhlbiBjcmVhdGUgaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW5vZGUuZXZlbnRMaXN0ZW5lcnNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ldmVudExpc3RlbmVyc1trZXldID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ldmVudExpc3RlbmVyc1trZXldLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBjb21wb3NpdGUgZGF0YSBVUkwuIElmIE1JTUUgdHlwZSBpcyBub3RcclxuICAgICAgICAgKiBzcGVjaWZpZWQsIHRoZW4gXCJpbWFnZS9wbmdcIiB3aWxsIHJlc3VsdC4gRm9yIFwiaW1hZ2UvanBlZ1wiLCBzcGVjaWZ5IGEgcXVhbGl0eVxyXG4gICAgICAgICAqIGxldmVsIGFzIHF1YWxpdHkgKHJhbmdlIDAuMCAtIDEuMClcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm1pbWVUeXBlXSBjYW4gYmUgXCJpbWFnZS9wbmdcIiBvciBcImltYWdlL2pwZWdcIi5cclxuICAgICAgICAgKiAgXCJpbWFnZS9wbmdcIiBpcyB0aGUgZGVmYXVsdFxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdIHggcG9zaXRpb24gb2YgY2FudmFzIHNlY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XSB5IHBvc2l0aW9uIG9mIGNhbnZhcyBzZWN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdIHdpZHRoIG9mIGNhbnZhcyBzZWN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XSBoZWlnaHQgb2YgY2FudmFzIHNlY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5xdWFsaXR5XSBqcGVnIHF1YWxpdHkuICBJZiB1c2luZyBhbiBcImltYWdlL2pwZWdcIiBtaW1lVHlwZSxcclxuICAgICAgICAgKiAgeW91IGNhbiBzcGVjaWZ5IHRoZSBxdWFsaXR5IGZyb20gMCB0byAxLCB3aGVyZSAwIGlzIHZlcnkgcG9vciBxdWFsaXR5IGFuZCAxXHJcbiAgICAgICAgICogIGlzIHZlcnkgaGlnaCBxdWFsaXR5XHJcbiAgICAgICAgICogQHBhcmVtdCB7TnVtYmVyfSBbY29uZmlnLnBpeGVsUmF0aW9dIHBpeGVsUmF0aW8gb2Ygb3VwdXQgaW1hZ2UgdXJsLiBEZWZhdWx0IGlzIDFcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRvRGF0YVVSTDogZnVuY3Rpb24oY29uZmlnKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuXHJcbiAgICAgICAgICAgIHZhciBtaW1lVHlwZSA9IGNvbmZpZy5taW1lVHlwZSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgICAgcXVhbGl0eSA9IGNvbmZpZy5xdWFsaXR5IHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKSxcclxuICAgICAgICAgICAgICAgIHggPSBjb25maWcueCB8fCAwLFxyXG4gICAgICAgICAgICAgICAgeSA9IGNvbmZpZy55IHx8IDAsXHJcbiAgICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gY29uZmlnLnBpeGVsUmF0aW8gfHwgMSxcclxuICAgICAgICAgICAgICAgIGNhbnZhcyA9IG5ldyBLb252YS5TY2VuZUNhbnZhcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbmZpZy53aWR0aCB8fCB0aGlzLmdldFdpZHRoKCkgfHwgKHN0YWdlID8gc3RhZ2UuZ2V0V2lkdGgoKSA6IDApLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogY29uZmlnLmhlaWdodCB8fCB0aGlzLmdldEhlaWdodCgpIHx8IChzdGFnZSA/IHN0YWdlLmdldEhlaWdodCgpIDogMCksXHJcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxSYXRpbzogcGl4ZWxSYXRpb1xyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYoeCB8fCB5KSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtMSAqIHgsIC0xICogeSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuZHJhd1NjZW5lKGNhbnZhcyk7XHJcbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwobWltZVR5cGUsIHF1YWxpdHkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogY29udmVydHMgbm9kZSBpbnRvIGFuIGltYWdlLiAgU2luY2UgdGhlIHRvSW1hZ2VcclxuICAgICAgICAgKiAgbWV0aG9kIGlzIGFzeW5jaHJvbm91cywgYSBjYWxsYmFjayBpcyByZXF1aXJlZC4gIHRvSW1hZ2UgaXMgbW9zdCBjb21tb25seSB1c2VkXHJcbiAgICAgICAgICogIHRvIGNhY2hlIGNvbXBsZXggZHJhd2luZ3MgYXMgYW4gaW1hZ2Ugc28gdGhhdCB0aGV5IGRvbid0IGhhdmUgdG8gY29uc3RhbnRseSBiZSByZWRyYXduXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25maWcuY2FsbGJhY2sgZnVuY3Rpb24gZXhlY3V0ZWQgd2hlbiB0aGUgY29tcG9zaXRlIGhhcyBjb21wbGV0ZWRcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5taW1lVHlwZV0gY2FuIGJlIFwiaW1hZ2UvcG5nXCIgb3IgXCJpbWFnZS9qcGVnXCIuXHJcbiAgICAgICAgICogIFwiaW1hZ2UvcG5nXCIgaXMgdGhlIGRlZmF1bHRcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XSB4IHBvc2l0aW9uIG9mIGNhbnZhcyBzZWN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV0geSBwb3NpdGlvbiBvZiBjYW52YXMgc2VjdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXSB3aWR0aCBvZiBjYW52YXMgc2VjdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF0gaGVpZ2h0IG9mIGNhbnZhcyBzZWN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucXVhbGl0eV0ganBlZyBxdWFsaXR5LiAgSWYgdXNpbmcgYW4gXCJpbWFnZS9qcGVnXCIgbWltZVR5cGUsXHJcbiAgICAgICAgICogIHlvdSBjYW4gc3BlY2lmeSB0aGUgcXVhbGl0eSBmcm9tIDAgdG8gMSwgd2hlcmUgMCBpcyB2ZXJ5IHBvb3IgcXVhbGl0eSBhbmQgMVxyXG4gICAgICAgICAqICBpcyB2ZXJ5IGhpZ2ggcXVhbGl0eVxyXG4gICAgICAgICAqIEBwYXJlbXQge051bWJlcn0gW2NvbmZpZy5waXhlbFJhdGlvXSBwaXhlbFJhdGlvIG9mIG91cHV0IGltYWdlLiAgRGVmYXVsdCBpcyAxLlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogdmFyIGltYWdlID0gbm9kZS50b0ltYWdlKHtcclxuICAgICAgICAgKiAgIGNhbGxiYWNrOiBmdW5jdGlvbihpbWcpIHtcclxuICAgICAgICAgKiAgICAgLy8gZG8gc3R1ZmYgd2l0aCBpbWdcclxuICAgICAgICAgKiAgIH1cclxuICAgICAgICAgKiB9KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICB0b0ltYWdlOiBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICAgICAgaWYgKCFjb25maWcgfHwgIWNvbmZpZy5jYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2NhbGxiYWNrIHJlcXVpcmVkIGZvciB0b0ltYWdlIG1ldGhvZCBjb25maWcgYXJndW1lbnQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEtvbnZhLlV0aWwuX2dldEltYWdlKHRoaXMudG9EYXRhVVJMKGNvbmZpZyksIGZ1bmN0aW9uKGltZykge1xyXG4gICAgICAgICAgICAgICAgY29uZmlnLmNhbGxiYWNrKGltZyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0U2l6ZTogZnVuY3Rpb24oc2l6ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFdpZHRoKHNpemUud2lkdGgpO1xyXG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChzaXplLmhlaWdodCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0U2l6ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5nZXRXaWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmdldEhlaWdodCgpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJzLndpZHRoIHx8IDA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRycy5oZWlnaHQgfHwgMDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGdldCBjbGFzcyBuYW1lLCB3aGljaCBtYXkgcmV0dXJuIFN0YWdlLCBMYXllciwgR3JvdXAsIG9yIHNoYXBlIGNsYXNzIG5hbWVzIGxpa2UgUmVjdCwgQ2lyY2xlLCBUZXh0LCBldGMuXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0Q2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3NOYW1lIHx8IHRoaXMubm9kZVR5cGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBnZXQgdGhlIG5vZGUgdHlwZSwgd2hpY2ggbWF5IHJldHVybiBTdGFnZSwgTGF5ZXIsIEdyb3VwLCBvciBOb2RlXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0VHlwZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVUeXBlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0RHJhZ0Rpc3RhbmNlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIHVuZGVmaW5lZCBiZWNhdXNlIHdlIG5lZWQgdG8gdHJhY2sgMCB2YWx1ZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5hdHRycy5kcmFnRGlzdGFuY2UgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cnMuZHJhZ0Rpc3RhbmNlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0RHJhZ0Rpc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gS29udmEuZHJhZ0Rpc3RhbmNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0OiBmdW5jdGlvbihzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGFzc05hbWUgPT09IHNlbGVjdG9yIHx8IHRoaXMubm9kZVR5cGUgPT09IHNlbGVjdG9yID8gW3RoaXNdIDogW107XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfb2ZmOiBmdW5jdGlvbih0eXBlLCBuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBldnRMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzW3R5cGVdLFxyXG4gICAgICAgICAgICAgICAgaSwgZXZ0TmFtZTtcclxuXHJcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IGV2dExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZXZ0TmFtZSA9IGV2dExpc3RlbmVyc1tpXS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGZvbGxvd2luZyB0d28gY29uZGl0aW9ucyBtdXN0IGJlIHRydWUgaW4gb3JkZXIgdG8gcmVtb3ZlIGEgaGFuZGxlcjpcclxuICAgICAgICAgICAgICAgIC8vIDEpIHRoZSBjdXJyZW50IGV2ZW50IG5hbWUgY2Fubm90IGJlIGtvbnZhIHVubGVzcyB0aGUgZXZlbnQgbmFtZSBpcyBrb252YVxyXG4gICAgICAgICAgICAgICAgLy8gICAgdGhpcyBlbmFibGVzIGRldmVsb3BlcnMgdG8gZm9yY2UgcmVtb3ZlIGEga29udmEgc3BlY2lmaWMgbGlzdGVuZXIgZm9yIHdoYXRldmVyIHJlYXNvblxyXG4gICAgICAgICAgICAgICAgLy8gMikgYW4gZXZlbnQgbmFtZSBpcyBub3Qgc3BlY2lmaWVkLCBvciBpZiBvbmUgaXMgc3BlY2lmaWVkLCBpdCBtYXRjaGVzIHRoZSBjdXJyZW50IGV2ZW50IG5hbWVcclxuICAgICAgICAgICAgICAgIGlmKChldnROYW1lICE9PSAna29udmEnIHx8IG5hbWUgPT09ICdrb252YScpICYmICghbmFtZSB8fCBldnROYW1lID09PSBuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2dExpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZXZ0TGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5ldmVudExpc3RlbmVyc1t0eXBlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2ZpcmVDaGFuZ2VFdmVudDogZnVuY3Rpb24oYXR0ciwgb2xkVmFsLCBuZXdWYWwpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmlyZShhdHRyICsgQ0hBTkdFLCB7XHJcbiAgICAgICAgICAgICAgICBvbGRWYWw6IG9sZFZhbCxcclxuICAgICAgICAgICAgICAgIG5ld1ZhbDogbmV3VmFsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0SWQ6IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAgICAgICAgIHZhciBvbGRJZCA9IHRoaXMuZ2V0SWQoKTtcclxuXHJcbiAgICAgICAgICAgIEtvbnZhLl9yZW1vdmVJZChvbGRJZCk7XHJcbiAgICAgICAgICAgIEtvbnZhLl9hZGRJZCh0aGlzLCBpZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldEF0dHIoSUQsIGlkKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXROYW1lOiBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBvbGROYW1lcyA9ICh0aGlzLmdldE5hbWUoKSB8fCAnJykuc3BsaXQoL1xccy9nKTtcclxuICAgICAgICAgICAgdmFyIG5ld05hbWVzID0gKG5hbWUgfHwgJycpLnNwbGl0KC9cXHMvZyk7XHJcbiAgICAgICAgICAgIHZhciBzdWJuYW1lLCBpO1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgYWxsIHN1Ym5hbWVzXHJcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IG9sZE5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzdWJuYW1lID0gb2xkTmFtZXNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoKG5ld05hbWVzLmluZGV4T2Yoc3VibmFtZSkpID09PSAtMSAmJiBzdWJuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgS29udmEuX3JlbW92ZU5hbWUoc3VibmFtZSwgdGhpcy5faWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBhZGQgbmV3IG5hbWVzXHJcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IG5ld05hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzdWJuYW1lID0gbmV3TmFtZXNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoKG9sZE5hbWVzLmluZGV4T2Yoc3VibmFtZSkgPT09IC0xKSAmJiBzdWJuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgS29udmEuX2FkZE5hbWUodGhpcywgc3VibmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3NldEF0dHIoTkFNRSwgbmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gbmFtaW5nIG1ldGhvZHNcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBhZGQgbmFtZSB0byBub2RlXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiBub2RlLm5hbWUoJ3JlZCcpO1xyXG4gICAgICAgICAqIG5vZGUuYWRkTmFtZSgnc2VsZWN0ZWQnKTtcclxuICAgICAgICAgKiBub2RlLm5hbWUoKTsgLy8gcmV0dXJuICdyZWQgc2VsZWN0ZWQnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWRkTmFtZTogZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzTmFtZShuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9sZE5hbWUgPSB0aGlzLm5hbWUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdOYW1lID0gb2xkTmFtZSA/IChvbGROYW1lICsgJyAnICsgbmFtZSkgOiBuYW1lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXROYW1lKG5ld05hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogY2hlY2sgaXMgbm9kZSBoYXMgbmFtZVxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogbm9kZS5uYW1lKCdyZWQnKTtcclxuICAgICAgICAgKiBub2RlLmhhc05hbWUoJ3JlZCcpOyAgIC8vIHJldHVybiB0cnVlXHJcbiAgICAgICAgICogbm9kZS5oYXNOYW1lKCdzZWxlY3RlZCcpOyAvLyByZXR1cm4gZmFsc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBoYXNOYW1lOiBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBuYW1lcyA9ICh0aGlzLm5hbWUoKSB8fCAnJykuc3BsaXQoL1xccy9nKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5hbWVzLmluZGV4T2YobmFtZSkgIT09IC0xO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogcmVtb3ZlIG5hbWUgZnJvbSBub2RlXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiBub2RlLm5hbWUoJ3JlZCBzZWxlY3RlZCcpO1xyXG4gICAgICAgICAqIG5vZGUucmVtb3ZlTmFtZSgnc2VsZWN0ZWQnKTtcclxuICAgICAgICAgKiBub2RlLmhhc05hbWUoJ3NlbGVjdGVkJyk7IC8vIHJldHVybiBmYWxzZVxyXG4gICAgICAgICAqIG5vZGUubmFtZSgpOyAvLyByZXR1cm4gJ3JlZCdcclxuICAgICAgICAgKi9cclxuICAgICAgICByZW1vdmVOYW1lOiBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBuYW1lcyA9ICh0aGlzLm5hbWUoKSB8fCAnJykuc3BsaXQoL1xccy9nKTtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gbmFtZXMuaW5kZXhPZihuYW1lKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgbmFtZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TmFtZShuYW1lcy5qb2luKCcgJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBzZXQgYXR0clxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0clxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsXHJcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiBub2RlLnNldEF0dHIoJ3gnLCA1KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRBdHRyOiBmdW5jdGlvbihhdHRyLCB2YWwpIHtcclxuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IFNFVCArIEtvbnZhLlV0aWwuX2NhcGl0YWxpemUoYXR0ciksXHJcbiAgICAgICAgICAgICAgICBmdW5jID0gdGhpc1ttZXRob2RdO1xyXG5cclxuICAgICAgICAgICAgaWYoS29udmEuVXRpbC5faXNGdW5jdGlvbihmdW5jKSkge1xyXG4gICAgICAgICAgICAgICAgZnVuYy5jYWxsKHRoaXMsIHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHNldCBkaXJlY3RseVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldEF0dHIoYXR0ciwgdmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9zZXRBdHRyOiBmdW5jdGlvbihrZXksIHZhbCkge1xyXG4gICAgICAgICAgICB2YXIgb2xkVmFsO1xyXG4gICAgICAgICAgICBpZih2YWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgb2xkVmFsID0gdGhpcy5hdHRyc1trZXldO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyc1trZXldID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyZUNoYW5nZUV2ZW50KGtleSwgb2xkVmFsLCB2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfc2V0Q29tcG9uZW50QXR0cjogZnVuY3Rpb24oa2V5LCBjb21wb25lbnQsIHZhbCkge1xyXG4gICAgICAgICAgICB2YXIgb2xkVmFsO1xyXG4gICAgICAgICAgICBpZih2YWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgb2xkVmFsID0gdGhpcy5hdHRyc1trZXldO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghb2xkVmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHZhbHVlIHRvIGRlZmF1bHQgdmFsdWUgdXNpbmcgZ2V0QXR0clxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnNba2V5XSA9IHRoaXMuZ2V0QXR0cihrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuYXR0cnNba2V5XVtjb21wb25lbnRdID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyZUNoYW5nZUV2ZW50KGtleSwgb2xkVmFsLCB2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZmlyZUFuZEJ1YmJsZTogZnVuY3Rpb24oZXZlbnRUeXBlLCBldnQsIGNvbXBhcmVTaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgb2theVRvUnVuID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmKGV2dCAmJiB0aGlzLm5vZGVUeXBlID09PSBTSEFQRSkge1xyXG4gICAgICAgICAgICAgICAgZXZ0LnRhcmdldCA9IHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGV2ZW50VHlwZSA9PT0gTU9VU0VFTlRFUiAmJiBjb21wYXJlU2hhcGUgJiYgKHRoaXMuX2lkID09PSBjb21wYXJlU2hhcGUuX2lkIHx8ICh0aGlzLmlzQW5jZXN0b3JPZiAmJiB0aGlzLmlzQW5jZXN0b3JPZihjb21wYXJlU2hhcGUpKSkpIHtcclxuICAgICAgICAgICAgICAgIG9rYXlUb1J1biA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZXZlbnRUeXBlID09PSBNT1VTRUxFQVZFICYmIGNvbXBhcmVTaGFwZSAmJiAodGhpcy5faWQgPT09IGNvbXBhcmVTaGFwZS5faWQgfHwgKHRoaXMuaXNBbmNlc3Rvck9mICYmIHRoaXMuaXNBbmNlc3Rvck9mKGNvbXBhcmVTaGFwZSkpKSkge1xyXG4gICAgICAgICAgICAgICAgb2theVRvUnVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYob2theVRvUnVuKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlKGV2ZW50VHlwZSwgZXZ0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzaW11bGF0ZSBldmVudCBidWJibGluZ1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0b3BCdWJibGUgPSAoZXZlbnRUeXBlID09PSBNT1VTRUVOVEVSIHx8IGV2ZW50VHlwZSA9PT0gTU9VU0VMRUFWRSkgJiYgKChjb21wYXJlU2hhcGUgJiYgY29tcGFyZVNoYXBlLmlzQW5jZXN0b3JPZiAmJiBjb21wYXJlU2hhcGUuaXNBbmNlc3Rvck9mKHRoaXMpKSB8fCAhIShjb21wYXJlU2hhcGUgJiYgY29tcGFyZVNoYXBlLmlzQW5jZXN0b3JPZikpO1xyXG4gICAgICAgICAgICAgICAgaWYoZXZ0ICYmICFldnQuY2FuY2VsQnViYmxlICYmIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmlzTGlzdGVuaW5nKCkgJiYgKCFzdG9wQnViYmxlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNvbXBhcmVTaGFwZSAmJiBjb21wYXJlU2hhcGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmVBbmRCdWJibGUuY2FsbCh0aGlzLnBhcmVudCwgZXZlbnRUeXBlLCBldnQsIGNvbXBhcmVTaGFwZS5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlyZUFuZEJ1YmJsZS5jYWxsKHRoaXMucGFyZW50LCBldmVudFR5cGUsIGV2dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZmlyZTogZnVuY3Rpb24oZXZlbnRUeXBlLCBldnQpIHtcclxuICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRMaXN0ZW5lcnNbZXZlbnRUeXBlXSxcclxuICAgICAgICAgICAgICAgIGk7XHJcblxyXG4gICAgICAgICAgICBldnQudHlwZSA9IGV2ZW50VHlwZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChldmVudHMpIHtcclxuICAgICAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50c1tpXS5oYW5kbGVyLmNhbGwodGhpcywgZXZ0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogZHJhdyBib3RoIHNjZW5lIGFuZCBoaXQgZ3JhcGhzLiAgSWYgdGhlIG5vZGUgYmVpbmcgZHJhd24gaXMgdGhlIHN0YWdlLCBhbGwgb2YgdGhlIGxheWVycyB3aWxsIGJlIGNsZWFyZWQgYW5kIHJlZHJhd25cclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZHJhdzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd1NjZW5lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd0hpdCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGNyZWF0ZSBub2RlIHdpdGggSlNPTiBzdHJpbmcgb3IgYW4gT2JqZWN0LiAgRGUtc2VyaWFsaXp0aW9uIGRvZXMgbm90IGdlbmVyYXRlIGN1c3RvbVxyXG4gICAgICogIHNoYXBlIGRyYXdpbmcgZnVuY3Rpb25zLCBpbWFnZXMsIG9yIGV2ZW50IGhhbmRsZXJzICh0aGlzIHdvdWxkIG1ha2UgdGhlXHJcbiAgICAgKiAgc2VyaWFsaXplZCBvYmplY3QgaHVnZSkuICBJZiB5b3VyIGFwcCB1c2VzIGN1c3RvbSBzaGFwZXMsIGltYWdlcywgYW5kXHJcbiAgICAgKiAgZXZlbnQgaGFuZGxlcnMgKGl0IHByb2JhYmx5IGRvZXMpLCB0aGVuIHlvdSBuZWVkIHRvIHNlbGVjdCB0aGUgYXBwcm9wcmlhdGVcclxuICAgICAqICBzaGFwZXMgYWZ0ZXIgbG9hZGluZyB0aGUgc3RhZ2UgYW5kIHNldCB0aGVzZSBwcm9wZXJ0aWVzIHZpYSBvbigpLCBzZXREcmF3RnVuYygpLFxyXG4gICAgICogIGFuZCBzZXRJbWFnZSgpIG1ldGhvZHNcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGpzb24gc3RyaW5nIG9yIG9iamVjdFxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBbY29udGFpbmVyXSBvcHRpb25hbCBjb250YWluZXIgZG9tIGVsZW1lbnQgdXNlZCBvbmx5IGlmIHlvdSdyZVxyXG4gICAgICogIGNyZWF0aW5nIGEgc3RhZ2Ugbm9kZVxyXG4gICAgICovXHJcbiAgICBLb252YS5Ob2RlLmNyZWF0ZSA9IGZ1bmN0aW9uKGRhdGEsIGNvbnRhaW5lcikge1xyXG4gICAgICAgIGlmIChLb252YS5VdGlsLl9pc1N0cmluZyhkYXRhKSkge1xyXG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZU5vZGUoZGF0YSwgY29udGFpbmVyKTtcclxuICAgIH07XHJcbiAgICBLb252YS5Ob2RlLl9jcmVhdGVOb2RlID0gZnVuY3Rpb24ob2JqLCBjb250YWluZXIpIHtcclxuICAgICAgICB2YXIgY2xhc3NOYW1lID0gS29udmEuTm9kZS5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lLmNhbGwob2JqKSxcclxuICAgICAgICAgICAgY2hpbGRyZW4gPSBvYmouY2hpbGRyZW4sXHJcbiAgICAgICAgICAgIG5vLCBsZW4sIG47XHJcblxyXG4gICAgICAgIC8vIGlmIGNvbnRhaW5lciB3YXMgcGFzc2VkIGluLCBhZGQgaXQgdG8gYXR0cnNcclxuICAgICAgICBpZihjb250YWluZXIpIHtcclxuICAgICAgICAgICAgb2JqLmF0dHJzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG5vID0gbmV3IEtvbnZhW2NsYXNzTmFtZV0ob2JqLmF0dHJzKTtcclxuICAgICAgICBpZihjaGlsZHJlbikge1xyXG4gICAgICAgICAgICBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvcihuID0gMDsgbiA8IGxlbjsgbisrKSB7XHJcbiAgICAgICAgICAgICAgICBuby5hZGQodGhpcy5fY3JlYXRlTm9kZShjaGlsZHJlbltuXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbm87XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT0gYWRkIGdldHRlcnMgc2V0dGVycyA9PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3Bvc2l0aW9uJyk7XHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgbm9kZSBwb3NpdGlvbiByZWxhdGl2ZSB0byBwYXJlbnRcclxuICAgICAqIEBuYW1lIHBvc2l0aW9uXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb3NcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy55XHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBwb3NpdGlvblxyXG4gICAgICogdmFyIHBvc2l0aW9uID0gbm9kZS5wb3NpdGlvbigpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBwb3NpdGlvblxyXG4gICAgICogbm9kZS5wb3NpdGlvbih7XHJcbiAgICAgKiAgIHg6IDVcclxuICAgICAqICAgeTogMTBcclxuICAgICAqIH0pO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3gnLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgeCBwb3NpdGlvblxyXG4gICAgICogQG5hbWUgeFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgeFxyXG4gICAgICogdmFyIHggPSBub2RlLngoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgeFxyXG4gICAgICogbm9kZS54KDUpO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3knLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgeSBwb3NpdGlvblxyXG4gICAgICogQG5hbWUgeVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxyXG4gICAgICogQHJldHVybnMge0ludGVnZXJ9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IHlcclxuICAgICAqIHZhciB5ID0gbm9kZS55KCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IHlcclxuICAgICAqIG5vZGUueSg1KTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdvcGFjaXR5JywgMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IG9wYWNpdHkuICBPcGFjaXR5IHZhbHVlcyByYW5nZSBmcm9tIDAgdG8gMS5cclxuICAgICAqICBBIG5vZGUgd2l0aCBhbiBvcGFjaXR5IG9mIDAgaXMgZnVsbHkgdHJhbnNwYXJlbnQsIGFuZCBhIG5vZGVcclxuICAgICAqICB3aXRoIGFuIG9wYWNpdHkgb2YgMSBpcyBmdWxseSBvcGFxdWVcclxuICAgICAqIEBuYW1lIG9wYWNpdHlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wYWNpdHlcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IG9wYWNpdHlcclxuICAgICAqIHZhciBvcGFjaXR5ID0gbm9kZS5vcGFjaXR5KCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IG9wYWNpdHlcclxuICAgICAqIG5vZGUub3BhY2l0eSgwLjUpO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXIoS29udmEuTm9kZSwgJ25hbWUnKTtcclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnbmFtZScpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBuYW1lXHJcbiAgICAgKiBAbmFtZSBuYW1lXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBuYW1lXHJcbiAgICAgKiB2YXIgbmFtZSA9IG5vZGUubmFtZSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBuYW1lXHJcbiAgICAgKiBub2RlLm5hbWUoJ2ZvbycpO1xyXG4gICAgICpcclxuICAgICAqIC8vIGFsc28gbm9kZSBtYXkgaGF2ZSBtdWx0aXBsZSBuYW1lcyAoYXMgY3NzIGNsYXNzZXMpXHJcbiAgICAgKiBub2RlLm5hbWUoJ2ZvbyBiYXInKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyKEtvbnZhLk5vZGUsICdpZCcpO1xyXG4gICAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdpZCcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBpZC4gSWQgaXMgZ2xvYmFsIGZvciB3aG9sZSBwYWdlLlxyXG4gICAgICogQG5hbWUgaWRcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBpZFxyXG4gICAgICogdmFyIG5hbWUgPSBub2RlLmlkKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IGlkXHJcbiAgICAgKiBub2RlLmlkKCdmb28nKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdyb3RhdGlvbicsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCByb3RhdGlvbiBpbiBkZWdyZWVzXHJcbiAgICAgKiBAbmFtZSByb3RhdGlvblxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcm90YXRpb25cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IHJvdGF0aW9uIGluIGRlZ3JlZXNcclxuICAgICAqIHZhciByb3RhdGlvbiA9IG5vZGUucm90YXRpb24oKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgcm90YXRpb24gaW4gZGVncmVlc1xyXG4gICAgICogbm9kZS5yb3RhdGlvbig0NSk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3NjYWxlJywgWyd4JywgJ3knXSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IHNjYWxlXHJcbiAgICAgKiBAbmFtZSBzY2FsZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjYWxlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUueFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlLnlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgc2NhbGVcclxuICAgICAqIHZhciBzY2FsZSA9IG5vZGUuc2NhbGUoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgc2NhbGVcclxuICAgICAqIHNoYXBlLnNjYWxlKHtcclxuICAgICAqICAgeDogMlxyXG4gICAgICogICB5OiAzXHJcbiAgICAgKiB9KTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdzY2FsZVgnLCAxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgc2NhbGUgeFxyXG4gICAgICogQG5hbWUgc2NhbGVYXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBzY2FsZSB4XHJcbiAgICAgKiB2YXIgc2NhbGVYID0gbm9kZS5zY2FsZVgoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgc2NhbGUgeFxyXG4gICAgICogbm9kZS5zY2FsZVgoMik7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnc2NhbGVZJywgMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IHNjYWxlIHlcclxuICAgICAqIEBuYW1lIHNjYWxlWVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgc2NhbGUgeVxyXG4gICAgICogdmFyIHNjYWxlWSA9IG5vZGUuc2NhbGVZKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IHNjYWxlIHlcclxuICAgICAqIG5vZGUuc2NhbGVZKDIpO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdza2V3JywgWyd4JywgJ3knXSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IHNrZXdcclxuICAgICAqIEBuYW1lIHNrZXdcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBza2V3XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2tldy54XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2tldy55XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IHNrZXdcclxuICAgICAqIHZhciBza2V3ID0gbm9kZS5za2V3KCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IHNrZXdcclxuICAgICAqIG5vZGUuc2tldyh7XHJcbiAgICAgKiAgIHg6IDIwXHJcbiAgICAgKiAgIHk6IDEwXHJcbiAgICAgKiB9KTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdza2V3WCcsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBza2V3IHhcclxuICAgICAqIEBuYW1lIHNrZXdYXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBza2V3IHhcclxuICAgICAqIHZhciBza2V3WCA9IG5vZGUuc2tld1goKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgc2tldyB4XHJcbiAgICAgKiBub2RlLnNrZXdYKDMpO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3NrZXdZJywgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IHNrZXcgeVxyXG4gICAgICogQG5hbWUgc2tld1lcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IHNrZXcgeVxyXG4gICAgICogdmFyIHNrZXdZID0gbm9kZS5za2V3WSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBza2V3IHlcclxuICAgICAqIG5vZGUuc2tld1koMyk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ29mZnNldCcsIFsneCcsICd5J10pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBvZmZzZXQuICBPZmZzZXRzIHRoZSBkZWZhdWx0IHBvc2l0aW9uIGFuZCByb3RhdGlvbiBwb2ludFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0LnhcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQueVxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgb2Zmc2V0XHJcbiAgICAgKiB2YXIgb2Zmc2V0ID0gbm9kZS5vZmZzZXQoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgb2Zmc2V0XHJcbiAgICAgKiBub2RlLm9mZnNldCh7XHJcbiAgICAgKiAgIHg6IDIwXHJcbiAgICAgKiAgIHk6IDEwXHJcbiAgICAgKiB9KTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdvZmZzZXRYJywgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IG9mZnNldCB4XHJcbiAgICAgKiBAbmFtZSBvZmZzZXRYXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBvZmZzZXQgeFxyXG4gICAgICogdmFyIG9mZnNldFggPSBub2RlLm9mZnNldFgoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgb2Zmc2V0IHhcclxuICAgICAqIG5vZGUub2Zmc2V0WCgzKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdvZmZzZXRZJywgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IG9mZnNldCB5XHJcbiAgICAgKiBAbmFtZSBvZmZzZXRZXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBvZmZzZXQgeVxyXG4gICAgICogdmFyIG9mZnNldFkgPSBub2RlLm9mZnNldFkoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgb2Zmc2V0IHlcclxuICAgICAqIG5vZGUub2Zmc2V0WSgzKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkU2V0dGVyKEtvbnZhLk5vZGUsICdkcmFnRGlzdGFuY2UnKTtcclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZHJhZ0Rpc3RhbmNlJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IGRyYWcgZGlzdGFuY2VcclxuICAgICAqIEBuYW1lIGRyYWdEaXN0YW5jZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGlzdGFuY2VcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGRyYWcgZGlzdGFuY2VcclxuICAgICAqIHZhciBkcmFnRGlzdGFuY2UgPSBub2RlLmRyYWdEaXN0YW5jZSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBkaXN0YW5jZVxyXG4gICAgICogLy8gbm9kZSBzdGFydHMgZHJhZ2dpbmcgb25seSBpZiBwb2ludGVyIG1vdmVkIG1vcmUgdGhlbiAzIHBpeGVsc1xyXG4gICAgICogbm9kZS5kcmFnRGlzdGFuY2UoMyk7XHJcbiAgICAgKiAvLyBvciBzZXQgZ2xvYmFsbHlcclxuICAgICAqIEtvbnZhLmRyYWdEaXN0YW5jZSA9IDM7XHJcbiAgICAgKi9cclxuXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRTZXR0ZXIoS29udmEuTm9kZSwgJ3dpZHRoJywgMCk7XHJcbiAgICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3dpZHRoJyk7XHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgd2lkdGhcclxuICAgICAqIEBuYW1lIHdpZHRoXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgd2lkdGhcclxuICAgICAqIHZhciB3aWR0aCA9IG5vZGUud2lkdGgoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgd2lkdGhcclxuICAgICAqIG5vZGUud2lkdGgoMTAwKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkU2V0dGVyKEtvbnZhLk5vZGUsICdoZWlnaHQnLCAwKTtcclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnaGVpZ2h0Jyk7XHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgaGVpZ2h0XHJcbiAgICAgKiBAbmFtZSBoZWlnaHRcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgaGVpZ2h0XHJcbiAgICAgKiB2YXIgaGVpZ2h0ID0gbm9kZS5oZWlnaHQoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgaGVpZ2h0XHJcbiAgICAgKiBub2RlLmhlaWdodCgxMDApO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2xpc3RlbmluZycsICdpbmhlcml0Jyk7XHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgbGlzdGVuaWcgYXR0ci4gIElmIHlvdSBuZWVkIHRvIGRldGVybWluZSBpZiBhIG5vZGUgaXMgbGlzdGVuaW5nIG9yIG5vdFxyXG4gICAgICogICBieSB0YWtpbmcgaW50byBhY2NvdW50IGl0cyBwYXJlbnRzLCB1c2UgdGhlIGlzTGlzdGVuaW5nKCkgbWV0aG9kXHJcbiAgICAgKiBAbmFtZSBsaXN0ZW5pbmdcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gbGlzdGVuaW5nIENhbiBiZSBcImluaGVyaXRcIiwgdHJ1ZSwgb3IgZmFsc2UuICBUaGUgZGVmYXVsdCBpcyBcImluaGVyaXRcIi5cclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufFN0cmluZ31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgbGlzdGVuaW5nIGF0dHJcclxuICAgICAqIHZhciBsaXN0ZW5pbmcgPSBub2RlLmxpc3RlbmluZygpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHN0b3AgbGlzdGVuaW5nIGZvciBldmVudHNcclxuICAgICAqIG5vZGUubGlzdGVuaW5nKGZhbHNlKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBsaXN0ZW4gZm9yIGV2ZW50c1xyXG4gICAgICogbm9kZS5saXN0ZW5pbmcodHJ1ZSk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gbGlzdGVuIHRvIGV2ZW50cyBhY2NvcmRpbmcgdG8gdGhlIHBhcmVudFxyXG4gICAgICogbm9kZS5saXN0ZW5pbmcoJ2luaGVyaXQnKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdmaWx0ZXJzJywgdW5kZWZpbmVkLCBmdW5jdGlvbih2YWwpIHt0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IGZhbHNlOyByZXR1cm4gdmFsOyB9KTtcclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBmaWx0ZXJzLiAgRmlsdGVycyBhcmUgYXBwbGllZCB0byBjYWNoZWQgY2FudmFzZXNcclxuICAgICAqIEBuYW1lIGZpbHRlcnNcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZmlsdGVycyBhcnJheSBvZiBmaWx0ZXJzXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGZpbHRlcnNcclxuICAgICAqIHZhciBmaWx0ZXJzID0gbm9kZS5maWx0ZXJzKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IGEgc2luZ2xlIGZpbHRlclxyXG4gICAgICogbm9kZS5jYWNoZSgpO1xyXG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkJsdXJdKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgbXVsdGlwbGUgZmlsdGVyc1xyXG4gICAgICogbm9kZS5jYWNoZSgpO1xyXG4gICAgICogbm9kZS5maWx0ZXJzKFtcclxuICAgICAqICAgS29udmEuRmlsdGVycy5CbHVyLFxyXG4gICAgICogICBLb252YS5GaWx0ZXJzLlNlcGlhLFxyXG4gICAgICogICBLb252YS5GaWx0ZXJzLkludmVydFxyXG4gICAgICogXSk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAndmlzaWJsZScsICdpbmhlcml0Jyk7XHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgdmlzaWJsZSBhdHRyLiAgQ2FuIGJlIFwiaW5oZXJpdFwiLCB0cnVlLCBvciBmYWxzZS4gIFRoZSBkZWZhdWx0IGlzIFwiaW5oZXJpdFwiLlxyXG4gICAgICogICBJZiB5b3UgbmVlZCB0byBkZXRlcm1pbmUgaWYgYSBub2RlIGlzIHZpc2libGUgb3Igbm90XHJcbiAgICAgKiAgIGJ5IHRha2luZyBpbnRvIGFjY291bnQgaXRzIHBhcmVudHMsIHVzZSB0aGUgaXNWaXNpYmxlKCkgbWV0aG9kXHJcbiAgICAgKiBAbmFtZSB2aXNpYmxlXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IHZpc2libGVcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufFN0cmluZ31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgdmlzaWJsZSBhdHRyXHJcbiAgICAgKiB2YXIgdmlzaWJsZSA9IG5vZGUudmlzaWJsZSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIG1ha2UgaW52aXNpYmxlXHJcbiAgICAgKiBub2RlLnZpc2libGUoZmFsc2UpO1xyXG4gICAgICpcclxuICAgICAqIC8vIG1ha2UgdmlzaWJsZVxyXG4gICAgICogbm9kZS52aXNpYmxlKHRydWUpO1xyXG4gICAgICpcclxuICAgICAqIC8vIG1ha2UgdmlzaWJsZSBhY2NvcmRpbmcgdG8gdGhlIHBhcmVudFxyXG4gICAgICogbm9kZS52aXNpYmxlKCdpbmhlcml0Jyk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAndHJhbnNmb3Jtc0VuYWJsZWQnLCAnYWxsJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IHRyYW5zZm9ybXMgdGhhdCBhcmUgZW5hYmxlZC4gIENhbiBiZSBcImFsbFwiLCBcIm5vbmVcIiwgb3IgXCJwb3NpdGlvblwiLiAgVGhlIGRlZmF1bHRcclxuICAgICAqICBpcyBcImFsbFwiXHJcbiAgICAgKiBAbmFtZSB0cmFuc2Zvcm1zRW5hYmxlZFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZW5hYmxlZFxyXG4gICAgICogQHJldHVybnMge1N0cmluZ31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBlbmFibGUgcG9zaXRpb24gdHJhbnNmb3JtIG9ubHkgdG8gaW1wcm92ZSBkcmF3IHBlcmZvcm1hbmNlXHJcbiAgICAgKiBub2RlLnRyYW5zZm9ybXNFbmFibGVkKCdwb3NpdGlvbicpO1xyXG4gICAgICpcclxuICAgICAqIC8vIGVuYWJsZSBhbGwgdHJhbnNmb3Jtc1xyXG4gICAgICogbm9kZS50cmFuc2Zvcm1zRW5hYmxlZCgnYWxsJyk7XHJcbiAgICAgKi9cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBub2RlIHNpemVcclxuICAgICAqIEBuYW1lIHNpemVcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNpemVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplLndpZHRoXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZS5oZWlnaHRcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IG5vZGUgc2l6ZVxyXG4gICAgICogdmFyIHNpemUgPSBub2RlLnNpemUoKTtcclxuICAgICAqIHZhciB4ID0gc2l6ZS54O1xyXG4gICAgICogdmFyIHkgPSBzaXplLnk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IHNpemVcclxuICAgICAqIG5vZGUuc2l6ZSh7XHJcbiAgICAgKiAgIHdpZHRoOiAxMDAsXHJcbiAgICAgKiAgIGhlaWdodDogMjAwXHJcbiAgICAgKiB9KTtcclxuICAgICAqL1xyXG4gICAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdzaXplJyk7XHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5iYWNrQ29tcGF0KEtvbnZhLk5vZGUsIHtcclxuICAgICAgICByb3RhdGVEZWc6ICdyb3RhdGUnLFxyXG4gICAgICAgIHNldFJvdGF0aW9uRGVnOiAnc2V0Um90YXRpb24nLFxyXG4gICAgICAgIGdldFJvdGF0aW9uRGVnOiAnZ2V0Um90YXRpb24nXHJcbiAgICB9KTtcclxuXHJcbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuTm9kZSk7XHJcbn0pKEtvbnZhKTtcclxuXG4oZnVuY3Rpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICAvKipcclxuICAgICogR3JheXNjYWxlIEZpbHRlclxyXG4gICAgKiBAZnVuY3Rpb25cclxuICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcclxuICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxyXG4gICAgKiBAZXhhbXBsZVxyXG4gICAgKiBub2RlLmNhY2hlKCk7XHJcbiAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5HcmF5c2NhbGVdKTtcclxuICAgICovXHJcbiAgICBLb252YS5GaWx0ZXJzLkdyYXlzY2FsZSA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xyXG4gICAgICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXHJcbiAgICAgICAgICAgIGxlbiA9IGRhdGEubGVuZ3RoLFxyXG4gICAgICAgICAgICBpLCBicmlnaHRuZXNzO1xyXG5cclxuICAgICAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xyXG4gICAgICAgICAgICBicmlnaHRuZXNzID0gMC4zNCAqIGRhdGFbaV0gKyAwLjUgKiBkYXRhW2kgKyAxXSArIDAuMTYgKiBkYXRhW2kgKyAyXTtcclxuICAgICAgICAgICAgLy8gcmVkXHJcbiAgICAgICAgICAgIGRhdGFbaV0gPSBicmlnaHRuZXNzO1xyXG4gICAgICAgICAgICAvLyBncmVlblxyXG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IGJyaWdodG5lc3M7XHJcbiAgICAgICAgICAgIC8vIGJsdWVcclxuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBicmlnaHRuZXNzO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0pKCk7XHJcblxuKGZ1bmN0aW9uKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCcmlnaHRlbiBGaWx0ZXIuXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogbm9kZS5jYWNoZSgpO1xyXG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkJyaWdodGVuXSk7XHJcbiAgICAgKiBub2RlLmJyaWdodG5lc3MoMC44KTtcclxuICAgICAqL1xyXG4gICAgS29udmEuRmlsdGVycy5CcmlnaHRlbiA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xyXG4gICAgICAgIHZhciBicmlnaHRuZXNzID0gdGhpcy5icmlnaHRuZXNzKCkgKiAyNTUsXHJcbiAgICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcclxuICAgICAgICAgICAgbGVuID0gZGF0YS5sZW5ndGgsXHJcbiAgICAgICAgICAgIGk7XHJcblxyXG4gICAgICAgIGZvcihpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgIC8vIHJlZFxyXG4gICAgICAgICAgICBkYXRhW2ldICs9IGJyaWdodG5lc3M7XHJcbiAgICAgICAgICAgIC8vIGdyZWVuXHJcbiAgICAgICAgICAgIGRhdGFbaSArIDFdICs9IGJyaWdodG5lc3M7XHJcbiAgICAgICAgICAgIC8vIGJsdWVcclxuICAgICAgICAgICAgZGF0YVtpICsgMl0gKz0gYnJpZ2h0bmVzcztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdicmlnaHRuZXNzJywgMCwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XHJcbiAgICAvKipcclxuICAgICogZ2V0L3NldCBmaWx0ZXIgYnJpZ2h0bmVzcy4gIFRoZSBicmlnaHRuZXNzIGlzIGEgbnVtYmVyIGJldHdlZW4gLTEgYW5kIDEuJm5ic3A7IFBvc2l0aXZlIHZhbHVlc1xyXG4gICAgKiAgYnJpZ2h0ZW4gdGhlIHBpeGVscyBhbmQgbmVnYXRpdmUgdmFsdWVzIGRhcmtlbiB0aGVtLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5CcmlnaHRlbn0gZmlsdGVyLlxyXG4gICAgKiBAbmFtZSBicmlnaHRuZXNzXHJcbiAgICAqIEBtZXRob2RcclxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBicmlnaHRuZXNzIHZhbHVlIGJldHdlZW4gLTEgYW5kIDFcclxuICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICovXHJcblxyXG59KSgpO1xyXG5cbihmdW5jdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8qKlxyXG4gICAgKiBJbnZlcnQgRmlsdGVyXHJcbiAgICAqIEBmdW5jdGlvblxyXG4gICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXHJcbiAgICAqIEBleGFtcGxlXHJcbiAgICAqIG5vZGUuY2FjaGUoKTtcclxuICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkludmVydF0pO1xyXG4gICAgKi9cclxuICAgIEtvbnZhLkZpbHRlcnMuSW52ZXJ0ID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcclxuICAgICAgICAgICAgbGVuID0gZGF0YS5sZW5ndGgsXHJcbiAgICAgICAgICAgIGk7XHJcblxyXG4gICAgICAgIGZvcihpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgIC8vIHJlZFxyXG4gICAgICAgICAgICBkYXRhW2ldID0gMjU1IC0gZGF0YVtpXTtcclxuICAgICAgICAgICAgLy8gZ3JlZW5cclxuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSAyNTUgLSBkYXRhW2kgKyAxXTtcclxuICAgICAgICAgICAgLy8gYmx1ZVxyXG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IDI1NSAtIGRhdGFbaSArIDJdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0pKCk7XHJcblxuLypcclxuIHRoZSBHYXVzcyBmaWx0ZXJcclxuIG1hc3RlciByZXBvOiBodHRwczovL2dpdGh1Yi5jb20vcGF2ZWxwb3dlci9raW5ldGljanNHYXVzc0ZpbHRlclxyXG4qL1xyXG4oZnVuY3Rpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICAvKlxyXG5cclxuICAgICBTdGFja0JsdXIgLSBhIGZhc3QgYWxtb3N0IEdhdXNzaWFuIEJsdXIgRm9yIENhbnZhc1xyXG5cclxuICAgICBWZXJzaW9uOiAgIDAuNVxyXG4gICAgIEF1dGhvcjogICAgTWFyaW8gS2xpbmdlbWFublxyXG4gICAgIENvbnRhY3Q6ICAgbWFyaW9AcXVhc2ltb25kby5jb21cclxuICAgICBXZWJzaXRlOiAgIGh0dHA6Ly93d3cucXVhc2ltb25kby5jb20vU3RhY2tCbHVyRm9yQ2FudmFzXHJcbiAgICAgVHdpdHRlcjogICBAcXVhc2ltb25kb1xyXG5cclxuICAgICBJbiBjYXNlIHlvdSBmaW5kIHRoaXMgY2xhc3MgdXNlZnVsIC0gZXNwZWNpYWxseSBpbiBjb21tZXJjaWFsIHByb2plY3RzIC1cclxuICAgICBJIGFtIG5vdCB0b3RhbGx5IHVuaGFwcHkgZm9yIGEgc21hbGwgZG9uYXRpb24gdG8gbXkgUGF5UGFsIGFjY291bnRcclxuICAgICBtYXJpb0BxdWFzaW1vbmRvLmRlXHJcblxyXG4gICAgIE9yIHN1cHBvcnQgbWUgb24gZmxhdHRyOlxyXG4gICAgIGh0dHBzOi8vZmxhdHRyLmNvbS90aGluZy83Mjc5MS9TdGFja0JsdXItYS1mYXN0LWFsbW9zdC1HYXVzc2lhbi1CbHVyLUVmZmVjdC1mb3ItQ2FudmFzSmF2YXNjcmlwdFxyXG5cclxuICAgICBDb3B5cmlnaHQgKGMpIDIwMTAgTWFyaW8gS2xpbmdlbWFublxyXG5cclxuICAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxyXG4gICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXHJcbiAgICAgZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XHJcbiAgICAgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXHJcbiAgICAgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuICAgICBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcclxuICAgICBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xyXG4gICAgIGNvbmRpdGlvbnM6XHJcblxyXG4gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbiAgICAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG4gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAgICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXHJcbiAgICAgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcclxuICAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxyXG4gICAgIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxyXG4gICAgIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xyXG4gICAgIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcclxuICAgICBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbiAgICAgKi9cclxuXHJcbiAgICBmdW5jdGlvbiBCbHVyU3RhY2soKSB7XHJcbiAgICAgICAgdGhpcy5yID0gMDtcclxuICAgICAgICB0aGlzLmcgPSAwO1xyXG4gICAgICAgIHRoaXMuYiA9IDA7XHJcbiAgICAgICAgdGhpcy5hID0gMDtcclxuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBtdWxfdGFibGUgPSBbXHJcbiAgICAgICAgNTEyLCA1MTIsIDQ1NiwgNTEyLCAzMjgsIDQ1NiwgMzM1LCA1MTIsIDQwNSwgMzI4LCAyNzEsIDQ1NiwgMzg4LCAzMzUsIDI5MiwgNTEyLFxyXG4gICAgICAgIDQ1NCwgNDA1LCAzNjQsIDMyOCwgMjk4LCAyNzEsIDQ5NiwgNDU2LCA0MjAsIDM4OCwgMzYwLCAzMzUsIDMxMiwgMjkyLCAyNzMsIDUxMixcclxuICAgICAgICA0ODIsIDQ1NCwgNDI4LCA0MDUsIDM4MywgMzY0LCAzNDUsIDMyOCwgMzEyLCAyOTgsIDI4NCwgMjcxLCAyNTksIDQ5NiwgNDc1LCA0NTYsXHJcbiAgICAgICAgNDM3LCA0MjAsIDQwNCwgMzg4LCAzNzQsIDM2MCwgMzQ3LCAzMzUsIDMyMywgMzEyLCAzMDIsIDI5MiwgMjgyLCAyNzMsIDI2NSwgNTEyLFxyXG4gICAgICAgIDQ5NywgNDgyLCA0NjgsIDQ1NCwgNDQxLCA0MjgsIDQxNywgNDA1LCAzOTQsIDM4MywgMzczLCAzNjQsIDM1NCwgMzQ1LCAzMzcsIDMyOCxcclxuICAgICAgICAzMjAsIDMxMiwgMzA1LCAyOTgsIDI5MSwgMjg0LCAyNzgsIDI3MSwgMjY1LCAyNTksIDUwNywgNDk2LCA0ODUsIDQ3NSwgNDY1LCA0NTYsXHJcbiAgICAgICAgNDQ2LCA0MzcsIDQyOCwgNDIwLCA0MTIsIDQwNCwgMzk2LCAzODgsIDM4MSwgMzc0LCAzNjcsIDM2MCwgMzU0LCAzNDcsIDM0MSwgMzM1LFxyXG4gICAgICAgIDMyOSwgMzIzLCAzMTgsIDMxMiwgMzA3LCAzMDIsIDI5NywgMjkyLCAyODcsIDI4MiwgMjc4LCAyNzMsIDI2OSwgMjY1LCAyNjEsIDUxMixcclxuICAgICAgICA1MDUsIDQ5NywgNDg5LCA0ODIsIDQ3NSwgNDY4LCA0NjEsIDQ1NCwgNDQ3LCA0NDEsIDQzNSwgNDI4LCA0MjIsIDQxNywgNDExLCA0MDUsXHJcbiAgICAgICAgMzk5LCAzOTQsIDM4OSwgMzgzLCAzNzgsIDM3MywgMzY4LCAzNjQsIDM1OSwgMzU0LCAzNTAsIDM0NSwgMzQxLCAzMzcsIDMzMiwgMzI4LFxyXG4gICAgICAgIDMyNCwgMzIwLCAzMTYsIDMxMiwgMzA5LCAzMDUsIDMwMSwgMjk4LCAyOTQsIDI5MSwgMjg3LCAyODQsIDI4MSwgMjc4LCAyNzQsIDI3MSxcclxuICAgICAgICAyNjgsIDI2NSwgMjYyLCAyNTksIDI1NywgNTA3LCA1MDEsIDQ5NiwgNDkxLCA0ODUsIDQ4MCwgNDc1LCA0NzAsIDQ2NSwgNDYwLCA0NTYsXHJcbiAgICAgICAgNDUxLCA0NDYsIDQ0MiwgNDM3LCA0MzMsIDQyOCwgNDI0LCA0MjAsIDQxNiwgNDEyLCA0MDgsIDQwNCwgNDAwLCAzOTYsIDM5MiwgMzg4LFxyXG4gICAgICAgIDM4NSwgMzgxLCAzNzcsIDM3NCwgMzcwLCAzNjcsIDM2MywgMzYwLCAzNTcsIDM1NCwgMzUwLCAzNDcsIDM0NCwgMzQxLCAzMzgsIDMzNSxcclxuICAgICAgICAzMzIsIDMyOSwgMzI2LCAzMjMsIDMyMCwgMzE4LCAzMTUsIDMxMiwgMzEwLCAzMDcsIDMwNCwgMzAyLCAyOTksIDI5NywgMjk0LCAyOTIsXHJcbiAgICAgICAgMjg5LCAyODcsIDI4NSwgMjgyLCAyODAsIDI3OCwgMjc1LCAyNzMsIDI3MSwgMjY5LCAyNjcsIDI2NSwgMjYzLCAyNjEsIDI1OVxyXG4gICAgXTtcclxuXHJcbiAgICB2YXIgc2hnX3RhYmxlID0gW1xyXG4gICAgICAgIDksIDExLCAxMiwgMTMsIDEzLCAxNCwgMTQsIDE1LCAxNSwgMTUsIDE1LCAxNiwgMTYsIDE2LCAxNiwgMTcsXHJcbiAgICAgICAgMTcsIDE3LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTksXHJcbiAgICAgICAgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDIwLCAyMCwgMjAsXHJcbiAgICAgICAgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjEsXHJcbiAgICAgICAgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsXHJcbiAgICAgICAgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsXHJcbiAgICAgICAgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsXHJcbiAgICAgICAgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjMsXHJcbiAgICAgICAgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsXHJcbiAgICAgICAgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsXHJcbiAgICAgICAgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsXHJcbiAgICAgICAgMjMsIDIzLCAyMywgMjMsIDIzLCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsXHJcbiAgICAgICAgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsXHJcbiAgICAgICAgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsXHJcbiAgICAgICAgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsXHJcbiAgICAgICAgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNFxyXG4gICAgXTtcclxuXHJcbiAgICBmdW5jdGlvbiBmaWx0ZXJHYXVzc0JsdXJSR0JBKCBpbWFnZURhdGEsIHJhZGl1cykge1xyXG5cclxuICAgICAgICB2YXIgcGl4ZWxzID0gaW1hZ2VEYXRhLmRhdGEsXHJcbiAgICAgICAgICAgIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0O1xyXG5cclxuICAgICAgICB2YXIgeCwgeSwgaSwgcCwgeXAsIHlpLCB5dywgcl9zdW0sIGdfc3VtLCBiX3N1bSwgYV9zdW0sXHJcbiAgICAgICAgICAgIHJfb3V0X3N1bSwgZ19vdXRfc3VtLCBiX291dF9zdW0sIGFfb3V0X3N1bSxcclxuICAgICAgICAgICAgcl9pbl9zdW0sIGdfaW5fc3VtLCBiX2luX3N1bSwgYV9pbl9zdW0sXHJcbiAgICAgICAgICAgIHByLCBwZywgcGIsIHBhLCByYnM7XHJcblxyXG4gICAgICAgIHZhciBkaXYgPSByYWRpdXMgKyByYWRpdXMgKyAxLFxyXG4gICAgICAgICAgICB3aWR0aE1pbnVzMSA9IHdpZHRoIC0gMSxcclxuICAgICAgICAgICAgaGVpZ2h0TWludXMxID0gaGVpZ2h0IC0gMSxcclxuICAgICAgICAgICAgcmFkaXVzUGx1czEgPSByYWRpdXMgKyAxLFxyXG4gICAgICAgICAgICBzdW1GYWN0b3IgPSByYWRpdXNQbHVzMSAqICggcmFkaXVzUGx1czEgKyAxICkgLyAyLFxyXG4gICAgICAgICAgICBzdGFja1N0YXJ0ID0gbmV3IEJsdXJTdGFjaygpLFxyXG4gICAgICAgICAgICBzdGFja0VuZCA9IG51bGwsXHJcbiAgICAgICAgICAgIHN0YWNrID0gc3RhY2tTdGFydCxcclxuICAgICAgICAgICAgc3RhY2tJbiA9IG51bGwsXHJcbiAgICAgICAgICAgIHN0YWNrT3V0ID0gbnVsbCxcclxuICAgICAgICAgICAgbXVsX3N1bSA9IG11bF90YWJsZVtyYWRpdXNdLFxyXG4gICAgICAgICAgICBzaGdfc3VtID0gc2hnX3RhYmxlW3JhZGl1c107XHJcblxyXG4gICAgICAgIGZvciAoIGkgPSAxOyBpIDwgZGl2OyBpKysgKSB7XHJcbiAgICAgICAgICAgIHN0YWNrID0gc3RhY2submV4dCA9IG5ldyBCbHVyU3RhY2soKTtcclxuICAgICAgICAgICAgaWYgKCBpID09PSByYWRpdXNQbHVzMSApe1xyXG4gICAgICAgICAgICAgICAgc3RhY2tFbmQgPSBzdGFjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhY2submV4dCA9IHN0YWNrU3RhcnQ7XHJcblxyXG4gICAgICAgIHl3ID0geWkgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrIClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJfaW5fc3VtID0gZ19pbl9zdW0gPSBiX2luX3N1bSA9IGFfaW5fc3VtID0gcl9zdW0gPSBnX3N1bSA9IGJfc3VtID0gYV9zdW0gPSAwO1xyXG5cclxuICAgICAgICAgICAgcl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHByID0gcGl4ZWxzW3lpXSApO1xyXG4gICAgICAgICAgICBnX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGcgPSBwaXhlbHNbeWkgKyAxXSApO1xyXG4gICAgICAgICAgICBiX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGIgPSBwaXhlbHNbeWkgKyAyXSApO1xyXG4gICAgICAgICAgICBhX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGEgPSBwaXhlbHNbeWkgKyAzXSApO1xyXG5cclxuICAgICAgICAgICAgcl9zdW0gKz0gc3VtRmFjdG9yICogcHI7XHJcbiAgICAgICAgICAgIGdfc3VtICs9IHN1bUZhY3RvciAqIHBnO1xyXG4gICAgICAgICAgICBiX3N1bSArPSBzdW1GYWN0b3IgKiBwYjtcclxuICAgICAgICAgICAgYV9zdW0gKz0gc3VtRmFjdG9yICogcGE7XHJcblxyXG4gICAgICAgICAgICBzdGFjayA9IHN0YWNrU3RhcnQ7XHJcblxyXG4gICAgICAgICAgICBmb3IoIGkgPSAwOyBpIDwgcmFkaXVzUGx1czE7IGkrKyApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN0YWNrLnIgPSBwcjtcclxuICAgICAgICAgICAgICAgIHN0YWNrLmcgPSBwZztcclxuICAgICAgICAgICAgICAgIHN0YWNrLmIgPSBwYjtcclxuICAgICAgICAgICAgICAgIHN0YWNrLmEgPSBwYTtcclxuICAgICAgICAgICAgICAgIHN0YWNrID0gc3RhY2submV4dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yKCBpID0gMTsgaSA8IHJhZGl1c1BsdXMxOyBpKysgKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwID0geWkgKyAoKCB3aWR0aE1pbnVzMSA8IGkgPyB3aWR0aE1pbnVzMSA6IGkgKSA8PCAyICk7XHJcbiAgICAgICAgICAgICAgICByX3N1bSArPSAoIHN0YWNrLnIgPSAoIHByID0gcGl4ZWxzW3BdKSkgKiAoIHJicyA9IHJhZGl1c1BsdXMxIC0gaSApO1xyXG4gICAgICAgICAgICAgICAgZ19zdW0gKz0gKCBzdGFjay5nID0gKCBwZyA9IHBpeGVsc1twICsgMV0pKSAqIHJicztcclxuICAgICAgICAgICAgICAgIGJfc3VtICs9ICggc3RhY2suYiA9ICggcGIgPSBwaXhlbHNbcCArIDJdKSkgKiByYnM7XHJcbiAgICAgICAgICAgICAgICBhX3N1bSArPSAoIHN0YWNrLmEgPSAoIHBhID0gcGl4ZWxzW3AgKyAzXSkpICogcmJzO1xyXG5cclxuICAgICAgICAgICAgICAgIHJfaW5fc3VtICs9IHByO1xyXG4gICAgICAgICAgICAgICAgZ19pbl9zdW0gKz0gcGc7XHJcbiAgICAgICAgICAgICAgICBiX2luX3N1bSArPSBwYjtcclxuICAgICAgICAgICAgICAgIGFfaW5fc3VtICs9IHBhO1xyXG5cclxuICAgICAgICAgICAgICAgIHN0YWNrID0gc3RhY2submV4dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIHN0YWNrSW4gPSBzdGFja1N0YXJ0O1xyXG4gICAgICAgICAgICBzdGFja091dCA9IHN0YWNrRW5kO1xyXG4gICAgICAgICAgICBmb3IgKCB4ID0gMDsgeCA8IHdpZHRoOyB4KysgKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwaXhlbHNbeWkgKyAzXSA9IHBhID0gKGFfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bTtcclxuICAgICAgICAgICAgICAgIGlmICggcGEgIT09IDAgKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhID0gMjU1IC8gcGE7XHJcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW3lpXSA9ICgocl9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtKSAqIHBhO1xyXG4gICAgICAgICAgICAgICAgICAgIHBpeGVsc1t5aSArIDFdID0gKChnX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0pICogcGE7XHJcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW3lpICsgMl0gPSAoKGJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSkgKiBwYTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW3lpXSA9IHBpeGVsc1t5aSArIDFdID0gcGl4ZWxzW3lpICsgMl0gPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJfc3VtIC09IHJfb3V0X3N1bTtcclxuICAgICAgICAgICAgICAgIGdfc3VtIC09IGdfb3V0X3N1bTtcclxuICAgICAgICAgICAgICAgIGJfc3VtIC09IGJfb3V0X3N1bTtcclxuICAgICAgICAgICAgICAgIGFfc3VtIC09IGFfb3V0X3N1bTtcclxuXHJcbiAgICAgICAgICAgICAgICByX291dF9zdW0gLT0gc3RhY2tJbi5yO1xyXG4gICAgICAgICAgICAgICAgZ19vdXRfc3VtIC09IHN0YWNrSW4uZztcclxuICAgICAgICAgICAgICAgIGJfb3V0X3N1bSAtPSBzdGFja0luLmI7XHJcbiAgICAgICAgICAgICAgICBhX291dF9zdW0gLT0gc3RhY2tJbi5hO1xyXG5cclxuICAgICAgICAgICAgICAgIHAgPSAoeXcgKyAoICggcCA9IHggKyByYWRpdXMgKyAxICkgPCB3aWR0aE1pbnVzMSA/IHAgOiB3aWR0aE1pbnVzMSApICkgPDwgMjtcclxuXHJcbiAgICAgICAgICAgICAgICByX2luX3N1bSArPSAoIHN0YWNrSW4uciA9IHBpeGVsc1twXSk7XHJcbiAgICAgICAgICAgICAgICBnX2luX3N1bSArPSAoIHN0YWNrSW4uZyA9IHBpeGVsc1twICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgYl9pbl9zdW0gKz0gKCBzdGFja0luLmIgPSBwaXhlbHNbcCArIDJdKTtcclxuICAgICAgICAgICAgICAgIGFfaW5fc3VtICs9ICggc3RhY2tJbi5hID0gcGl4ZWxzW3AgKyAzXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcl9zdW0gKz0gcl9pbl9zdW07XHJcbiAgICAgICAgICAgICAgICBnX3N1bSArPSBnX2luX3N1bTtcclxuICAgICAgICAgICAgICAgIGJfc3VtICs9IGJfaW5fc3VtO1xyXG4gICAgICAgICAgICAgICAgYV9zdW0gKz0gYV9pbl9zdW07XHJcblxyXG4gICAgICAgICAgICAgICAgc3RhY2tJbiA9IHN0YWNrSW4ubmV4dDtcclxuXHJcbiAgICAgICAgICAgICAgICByX291dF9zdW0gKz0gKCBwciA9IHN0YWNrT3V0LnIgKTtcclxuICAgICAgICAgICAgICAgIGdfb3V0X3N1bSArPSAoIHBnID0gc3RhY2tPdXQuZyApO1xyXG4gICAgICAgICAgICAgICAgYl9vdXRfc3VtICs9ICggcGIgPSBzdGFja091dC5iICk7XHJcbiAgICAgICAgICAgICAgICBhX291dF9zdW0gKz0gKCBwYSA9IHN0YWNrT3V0LmEgKTtcclxuXHJcbiAgICAgICAgICAgICAgICByX2luX3N1bSAtPSBwcjtcclxuICAgICAgICAgICAgICAgIGdfaW5fc3VtIC09IHBnO1xyXG4gICAgICAgICAgICAgICAgYl9pbl9zdW0gLT0gcGI7XHJcbiAgICAgICAgICAgICAgICBhX2luX3N1bSAtPSBwYTtcclxuXHJcbiAgICAgICAgICAgICAgICBzdGFja091dCA9IHN0YWNrT3V0Lm5leHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgeWkgKz0gNDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5dyArPSB3aWR0aDtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBmb3IgKCB4ID0gMDsgeCA8IHdpZHRoOyB4KysgKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ19pbl9zdW0gPSBiX2luX3N1bSA9IGFfaW5fc3VtID0gcl9pbl9zdW0gPSBnX3N1bSA9IGJfc3VtID0gYV9zdW0gPSByX3N1bSA9IDA7XHJcblxyXG4gICAgICAgICAgICB5aSA9IHggPDwgMjtcclxuICAgICAgICAgICAgcl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHByID0gcGl4ZWxzW3lpXSk7XHJcbiAgICAgICAgICAgIGdfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwZyA9IHBpeGVsc1t5aSArIDFdKTtcclxuICAgICAgICAgICAgYl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHBiID0gcGl4ZWxzW3lpICsgMl0pO1xyXG4gICAgICAgICAgICBhX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGEgPSBwaXhlbHNbeWkgKyAzXSk7XHJcblxyXG4gICAgICAgICAgICByX3N1bSArPSBzdW1GYWN0b3IgKiBwcjtcclxuICAgICAgICAgICAgZ19zdW0gKz0gc3VtRmFjdG9yICogcGc7XHJcbiAgICAgICAgICAgIGJfc3VtICs9IHN1bUZhY3RvciAqIHBiO1xyXG4gICAgICAgICAgICBhX3N1bSArPSBzdW1GYWN0b3IgKiBwYTtcclxuXHJcbiAgICAgICAgICAgIHN0YWNrID0gc3RhY2tTdGFydDtcclxuXHJcbiAgICAgICAgICAgIGZvciggaSA9IDA7IGkgPCByYWRpdXNQbHVzMTsgaSsrIClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3RhY2suciA9IHByO1xyXG4gICAgICAgICAgICAgICAgc3RhY2suZyA9IHBnO1xyXG4gICAgICAgICAgICAgICAgc3RhY2suYiA9IHBiO1xyXG4gICAgICAgICAgICAgICAgc3RhY2suYSA9IHBhO1xyXG4gICAgICAgICAgICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB5cCA9IHdpZHRoO1xyXG5cclxuICAgICAgICAgICAgZm9yKCBpID0gMTsgaSA8PSByYWRpdXM7IGkrKyApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHlpID0gKCB5cCArIHggKSA8PCAyO1xyXG5cclxuICAgICAgICAgICAgICAgIHJfc3VtICs9ICggc3RhY2suciA9ICggcHIgPSBwaXhlbHNbeWldKSkgKiAoIHJicyA9IHJhZGl1c1BsdXMxIC0gaSApO1xyXG4gICAgICAgICAgICAgICAgZ19zdW0gKz0gKCBzdGFjay5nID0gKCBwZyA9IHBpeGVsc1t5aSArIDFdKSkgKiByYnM7XHJcbiAgICAgICAgICAgICAgICBiX3N1bSArPSAoIHN0YWNrLmIgPSAoIHBiID0gcGl4ZWxzW3lpICsgMl0pKSAqIHJicztcclxuICAgICAgICAgICAgICAgIGFfc3VtICs9ICggc3RhY2suYSA9ICggcGEgPSBwaXhlbHNbeWkgKyAzXSkpICogcmJzO1xyXG5cclxuICAgICAgICAgICAgICAgIHJfaW5fc3VtICs9IHByO1xyXG4gICAgICAgICAgICAgICAgZ19pbl9zdW0gKz0gcGc7XHJcbiAgICAgICAgICAgICAgICBiX2luX3N1bSArPSBwYjtcclxuICAgICAgICAgICAgICAgIGFfaW5fc3VtICs9IHBhO1xyXG5cclxuICAgICAgICAgICAgICAgIHN0YWNrID0gc3RhY2submV4dDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiggaSA8IGhlaWdodE1pbnVzMSApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgeXAgKz0gd2lkdGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHlpID0geDtcclxuICAgICAgICAgICAgc3RhY2tJbiA9IHN0YWNrU3RhcnQ7XHJcbiAgICAgICAgICAgIHN0YWNrT3V0ID0gc3RhY2tFbmQ7XHJcbiAgICAgICAgICAgIGZvciAoIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KysgKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwID0geWkgPDwgMjtcclxuICAgICAgICAgICAgICAgIHBpeGVsc1twICsgM10gPSBwYSA9IChhX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW07XHJcbiAgICAgICAgICAgICAgICBpZiAoIHBhID4gMCApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGEgPSAyNTUgLyBwYTtcclxuICAgICAgICAgICAgICAgICAgICBwaXhlbHNbcF0gPSAoKHJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSApICogcGE7XHJcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW3AgKyAxXSA9ICgoZ19zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtICkgKiBwYTtcclxuICAgICAgICAgICAgICAgICAgICBwaXhlbHNbcCArIDJdID0gKChiX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0gKSAqIHBhO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwaXhlbHNbcF0gPSBwaXhlbHNbcCArIDFdID0gcGl4ZWxzW3AgKyAyXSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcl9zdW0gLT0gcl9vdXRfc3VtO1xyXG4gICAgICAgICAgICAgICAgZ19zdW0gLT0gZ19vdXRfc3VtO1xyXG4gICAgICAgICAgICAgICAgYl9zdW0gLT0gYl9vdXRfc3VtO1xyXG4gICAgICAgICAgICAgICAgYV9zdW0gLT0gYV9vdXRfc3VtO1xyXG5cclxuICAgICAgICAgICAgICAgIHJfb3V0X3N1bSAtPSBzdGFja0luLnI7XHJcbiAgICAgICAgICAgICAgICBnX291dF9zdW0gLT0gc3RhY2tJbi5nO1xyXG4gICAgICAgICAgICAgICAgYl9vdXRfc3VtIC09IHN0YWNrSW4uYjtcclxuICAgICAgICAgICAgICAgIGFfb3V0X3N1bSAtPSBzdGFja0luLmE7XHJcblxyXG4gICAgICAgICAgICAgICAgcCA9ICggeCArICgoICggcCA9IHkgKyByYWRpdXNQbHVzMSkgPCBoZWlnaHRNaW51czEgPyBwIDogaGVpZ2h0TWludXMxICkgKiB3aWR0aCApKSA8PCAyO1xyXG5cclxuICAgICAgICAgICAgICAgIHJfc3VtICs9ICggcl9pbl9zdW0gKz0gKCBzdGFja0luLnIgPSBwaXhlbHNbcF0pKTtcclxuICAgICAgICAgICAgICAgIGdfc3VtICs9ICggZ19pbl9zdW0gKz0gKCBzdGFja0luLmcgPSBwaXhlbHNbcCArIDFdKSk7XHJcbiAgICAgICAgICAgICAgICBiX3N1bSArPSAoIGJfaW5fc3VtICs9ICggc3RhY2tJbi5iID0gcGl4ZWxzW3AgKyAyXSkpO1xyXG4gICAgICAgICAgICAgICAgYV9zdW0gKz0gKCBhX2luX3N1bSArPSAoIHN0YWNrSW4uYSA9IHBpeGVsc1twICsgM10pKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzdGFja0luID0gc3RhY2tJbi5uZXh0O1xyXG5cclxuICAgICAgICAgICAgICAgIHJfb3V0X3N1bSArPSAoIHByID0gc3RhY2tPdXQuciApO1xyXG4gICAgICAgICAgICAgICAgZ19vdXRfc3VtICs9ICggcGcgPSBzdGFja091dC5nICk7XHJcbiAgICAgICAgICAgICAgICBiX291dF9zdW0gKz0gKCBwYiA9IHN0YWNrT3V0LmIgKTtcclxuICAgICAgICAgICAgICAgIGFfb3V0X3N1bSArPSAoIHBhID0gc3RhY2tPdXQuYSApO1xyXG5cclxuICAgICAgICAgICAgICAgIHJfaW5fc3VtIC09IHByO1xyXG4gICAgICAgICAgICAgICAgZ19pbl9zdW0gLT0gcGc7XHJcbiAgICAgICAgICAgICAgICBiX2luX3N1bSAtPSBwYjtcclxuICAgICAgICAgICAgICAgIGFfaW5fc3VtIC09IHBhO1xyXG5cclxuICAgICAgICAgICAgICAgIHN0YWNrT3V0ID0gc3RhY2tPdXQubmV4dDtcclxuXHJcbiAgICAgICAgICAgICAgICB5aSArPSB3aWR0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJsdXIgRmlsdGVyXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBuYW1lIEJsdXJcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogbm9kZS5jYWNoZSgpO1xyXG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkJsdXJdKTtcclxuICAgICAqIG5vZGUuYmx1clJhZGl1cygxMCk7XHJcbiAgICAgKi9cclxuICAgIEtvbnZhLkZpbHRlcnMuQmx1ciA9IGZ1bmN0aW9uIEJsdXIoaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgdmFyIHJhZGl1cyA9IE1hdGgucm91bmQodGhpcy5ibHVyUmFkaXVzKCkpO1xyXG5cclxuICAgICAgICBpZiAocmFkaXVzID4gMCkge1xyXG4gICAgICAgICAgICBmaWx0ZXJHYXVzc0JsdXJSR0JBKGltYWdlRGF0YSwgcmFkaXVzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdibHVyUmFkaXVzJywgMCwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIGdldC9zZXQgYmx1ciByYWRpdXMuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkJsdXJ9IGZpbHRlclxyXG4gICAgKiBAbmFtZSBibHVyUmFkaXVzXHJcbiAgICAqIEBtZXRob2RcclxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAqIEBwYXJhbSB7SW50ZWdlcn0gcmFkaXVzXHJcbiAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxyXG4gICAgKi9cclxufSkoKTtcclxuXG4vKmVzbGludC1kaXNhYmxlICBtYXgtZGVwdGggKi9cclxuKGZ1bmN0aW9uKCkge1xyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRmdW5jdGlvbiBwaXhlbEF0KGlkYXRhLCB4LCB5KSB7XHJcblx0XHR2YXIgaWR4ID0gKHkgKiBpZGF0YS53aWR0aCArIHgpICogNDtcclxuXHRcdHZhciBkID0gW107XHJcblx0XHRkLnB1c2goaWRhdGEuZGF0YVtpZHgrK10sIGlkYXRhLmRhdGFbaWR4KytdLCBpZGF0YS5kYXRhW2lkeCsrXSwgaWRhdGEuZGF0YVtpZHgrK10pO1xyXG5cdFx0cmV0dXJuIGQ7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZ2JEaXN0YW5jZShwMSwgcDIpIHtcclxuXHRcdHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocDFbMF0gLSBwMlswXSwgMikgKyBNYXRoLnBvdyhwMVsxXSAtIHAyWzFdLCAyKSArIE1hdGgucG93KHAxWzJdIC0gcDJbMl0sIDIpKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJnYk1lYW4ocFRhYikge1xyXG5cdFx0dmFyIG0gPSBbMCwgMCwgMF07XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwVGFiLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdG1bMF0gKz0gcFRhYltpXVswXTtcclxuXHRcdFx0bVsxXSArPSBwVGFiW2ldWzFdO1xyXG5cdFx0XHRtWzJdICs9IHBUYWJbaV1bMl07XHJcblx0XHR9XHJcblxyXG5cdFx0bVswXSAvPSBwVGFiLmxlbmd0aDtcclxuXHRcdG1bMV0gLz0gcFRhYi5sZW5ndGg7XHJcblx0XHRtWzJdIC89IHBUYWIubGVuZ3RoO1xyXG5cclxuXHRcdHJldHVybiBtO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gYmFja2dyb3VuZE1hc2soaWRhdGEsIHRocmVzaG9sZCkge1xyXG5cdFx0dmFyIHJnYnZfbm8gPSBwaXhlbEF0KGlkYXRhLCAwLCAwKTtcclxuXHRcdHZhciByZ2J2X25lID0gcGl4ZWxBdChpZGF0YSwgaWRhdGEud2lkdGggLSAxLCAwKTtcclxuXHRcdHZhciByZ2J2X3NvID0gcGl4ZWxBdChpZGF0YSwgMCwgaWRhdGEuaGVpZ2h0IC0gMSk7XHJcblx0XHR2YXIgcmdidl9zZSA9IHBpeGVsQXQoaWRhdGEsIGlkYXRhLndpZHRoIC0gMSwgaWRhdGEuaGVpZ2h0IC0gMSk7XHJcblxyXG5cclxuXHRcdHZhciB0aHJlcyA9IHRocmVzaG9sZCB8fCAxMDtcclxuXHRcdGlmIChyZ2JEaXN0YW5jZShyZ2J2X25vLCByZ2J2X25lKSA8IHRocmVzICYmIHJnYkRpc3RhbmNlKHJnYnZfbmUsIHJnYnZfc2UpIDwgdGhyZXMgJiYgcmdiRGlzdGFuY2Uocmdidl9zZSwgcmdidl9zbykgPCB0aHJlcyAmJiByZ2JEaXN0YW5jZShyZ2J2X3NvLCByZ2J2X25vKSA8IHRocmVzKSB7XHJcblxyXG5cdFx0XHQvLyBNZWFuIGNvbG9yXHJcblx0XHRcdHZhciBtZWFuID0gcmdiTWVhbihbcmdidl9uZSwgcmdidl9ubywgcmdidl9zZSwgcmdidl9zb10pO1xyXG5cclxuXHRcdFx0Ly8gTWFzayBiYXNlZCBvbiBjb2xvciBkaXN0YW5jZVxyXG5cdFx0XHR2YXIgbWFzayA9IFtdO1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGlkYXRhLndpZHRoICogaWRhdGEuaGVpZ2h0OyBpKyspIHtcclxuXHRcdFx0XHR2YXIgZCA9IHJnYkRpc3RhbmNlKG1lYW4sIFtpZGF0YS5kYXRhW2kgKiA0XSwgaWRhdGEuZGF0YVtpICogNCArIDFdLCBpZGF0YS5kYXRhW2kgKiA0ICsgMl1dKTtcclxuXHRcdFx0XHRtYXNrW2ldID0gKGQgPCB0aHJlcykgPyAwIDogMjU1O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbWFzaztcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGFwcGx5TWFzayhpZGF0YSwgbWFzaykge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpZGF0YS53aWR0aCAqIGlkYXRhLmhlaWdodDsgaSsrKSB7XHJcblx0XHRcdGlkYXRhLmRhdGFbNCAqIGkgKyAzXSA9IG1hc2tbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBlcm9kZU1hc2sobWFzaywgc3csIHNoKSB7XHJcblxyXG5cdFx0dmFyIHdlaWdodHMgPSBbMSwgMSwgMSwgMSwgMCwgMSwgMSwgMSwgMV07XHJcblx0XHR2YXIgc2lkZSA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KHdlaWdodHMubGVuZ3RoKSk7XHJcblx0XHR2YXIgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUgLyAyKTtcclxuXHJcblx0XHR2YXIgbWFza1Jlc3VsdCA9IFtdO1xyXG5cdFx0Zm9yICh2YXIgeSA9IDA7IHkgPCBzaDsgeSsrKSB7XHJcblx0XHRcdGZvciAodmFyIHggPSAwOyB4IDwgc3c7IHgrKykge1xyXG5cclxuXHRcdFx0XHR2YXIgc28gPSB5ICogc3cgKyB4O1xyXG5cdFx0XHRcdHZhciBhID0gMDtcclxuXHRcdFx0XHRmb3IgKHZhciBjeSA9IDA7IGN5IDwgc2lkZTsgY3krKykge1xyXG5cdFx0XHRcdFx0Zm9yICh2YXIgY3ggPSAwOyBjeCA8IHNpZGU7IGN4KyspIHtcclxuXHRcdFx0XHRcdFx0dmFyIHNjeSA9IHkgKyBjeSAtIGhhbGZTaWRlO1xyXG5cdFx0XHRcdFx0XHR2YXIgc2N4ID0geCArIGN4IC0gaGFsZlNpZGU7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoc2N5ID49IDAgJiYgc2N5IDwgc2ggJiYgc2N4ID49IDAgJiYgc2N4IDwgc3cpIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIHNyY09mZiA9IHNjeSAqIHN3ICsgc2N4O1xyXG5cdFx0XHRcdFx0XHRcdHZhciB3dCA9IHdlaWdodHNbY3kgKiBzaWRlICsgY3hdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRhICs9IG1hc2tbc3JjT2ZmXSAqIHd0O1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRtYXNrUmVzdWx0W3NvXSA9IChhID09PSAyNTUgKiA4KSA/IDI1NSA6IDA7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbWFza1Jlc3VsdDtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGRpbGF0ZU1hc2sobWFzaywgc3csIHNoKSB7XHJcblxyXG5cdFx0dmFyIHdlaWdodHMgPSBbMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMV07XHJcblx0XHR2YXIgc2lkZSA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KHdlaWdodHMubGVuZ3RoKSk7XHJcblx0XHR2YXIgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUgLyAyKTtcclxuXHJcblx0XHR2YXIgbWFza1Jlc3VsdCA9IFtdO1xyXG5cdFx0Zm9yICh2YXIgeSA9IDA7IHkgPCBzaDsgeSsrKSB7XHJcblx0XHRcdGZvciAodmFyIHggPSAwOyB4IDwgc3c7IHgrKykge1xyXG5cclxuXHRcdFx0XHR2YXIgc28gPSB5ICogc3cgKyB4O1xyXG5cdFx0XHRcdHZhciBhID0gMDtcclxuXHRcdFx0XHRmb3IgKHZhciBjeSA9IDA7IGN5IDwgc2lkZTsgY3krKykge1xyXG5cdFx0XHRcdFx0Zm9yICh2YXIgY3ggPSAwOyBjeCA8IHNpZGU7IGN4KyspIHtcclxuXHRcdFx0XHRcdFx0dmFyIHNjeSA9IHkgKyBjeSAtIGhhbGZTaWRlO1xyXG5cdFx0XHRcdFx0XHR2YXIgc2N4ID0geCArIGN4IC0gaGFsZlNpZGU7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoc2N5ID49IDAgJiYgc2N5IDwgc2ggJiYgc2N4ID49IDAgJiYgc2N4IDwgc3cpIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIHNyY09mZiA9IHNjeSAqIHN3ICsgc2N4O1xyXG5cdFx0XHRcdFx0XHRcdHZhciB3dCA9IHdlaWdodHNbY3kgKiBzaWRlICsgY3hdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRhICs9IG1hc2tbc3JjT2ZmXSAqIHd0O1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRtYXNrUmVzdWx0W3NvXSA9IChhID49IDI1NSAqIDQpID8gMjU1IDogMDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtYXNrUmVzdWx0O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc21vb3RoRWRnZU1hc2sobWFzaywgc3csIHNoKSB7XHJcblxyXG5cdFx0dmFyIHdlaWdodHMgPSBbMSAvIDksIDEgLyA5LCAxIC8gOSwgMSAvIDksIDEgLyA5LCAxIC8gOSwgMSAvIDksIDEgLyA5LCAxIC8gOV07XHJcblx0XHR2YXIgc2lkZSA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KHdlaWdodHMubGVuZ3RoKSk7XHJcblx0XHR2YXIgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUgLyAyKTtcclxuXHJcblx0XHR2YXIgbWFza1Jlc3VsdCA9IFtdO1xyXG5cdFx0Zm9yICh2YXIgeSA9IDA7IHkgPCBzaDsgeSsrKSB7XHJcblx0XHRcdGZvciAodmFyIHggPSAwOyB4IDwgc3c7IHgrKykge1xyXG5cclxuXHRcdFx0XHR2YXIgc28gPSB5ICogc3cgKyB4O1xyXG5cdFx0XHRcdHZhciBhID0gMDtcclxuXHRcdFx0XHRmb3IgKHZhciBjeSA9IDA7IGN5IDwgc2lkZTsgY3krKykge1xyXG5cdFx0XHRcdFx0Zm9yICh2YXIgY3ggPSAwOyBjeCA8IHNpZGU7IGN4KyspIHtcclxuXHRcdFx0XHRcdFx0dmFyIHNjeSA9IHkgKyBjeSAtIGhhbGZTaWRlO1xyXG5cdFx0XHRcdFx0XHR2YXIgc2N4ID0geCArIGN4IC0gaGFsZlNpZGU7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoc2N5ID49IDAgJiYgc2N5IDwgc2ggJiYgc2N4ID49IDAgJiYgc2N4IDwgc3cpIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIHNyY09mZiA9IHNjeSAqIHN3ICsgc2N4O1xyXG5cdFx0XHRcdFx0XHRcdHZhciB3dCA9IHdlaWdodHNbY3kgKiBzaWRlICsgY3hdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRhICs9IG1hc2tbc3JjT2ZmXSAqIHd0O1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRtYXNrUmVzdWx0W3NvXSA9IGE7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbWFza1Jlc3VsdDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIE1hc2sgRmlsdGVyXHJcblx0ICogQGZ1bmN0aW9uXHJcblx0ICogQG5hbWUgTWFza1xyXG5cdCAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxyXG5cdCAqIEBleGFtcGxlXHJcbiAgICAgKiBub2RlLmNhY2hlKCk7XHJcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuTWFza10pO1xyXG4gICAgICogbm9kZS50aHJlc2hvbGQoMjAwKTtcclxuXHQgKi9cclxuXHRLb252YS5GaWx0ZXJzLk1hc2sgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcclxuXHRcdC8vIERldGVjdCBwaXhlbHMgY2xvc2UgdG8gdGhlIGJhY2tncm91bmQgY29sb3JcclxuXHRcdHZhciB0aHJlc2hvbGQgPSB0aGlzLnRocmVzaG9sZCgpLFxyXG4gICAgICAgIG1hc2sgPSBiYWNrZ3JvdW5kTWFzayhpbWFnZURhdGEsIHRocmVzaG9sZCk7XHJcblx0XHRpZiAobWFzaykge1xyXG5cdFx0XHQvLyBFcm9kZVxyXG5cdFx0XHRtYXNrID0gZXJvZGVNYXNrKG1hc2ssIGltYWdlRGF0YS53aWR0aCwgaW1hZ2VEYXRhLmhlaWdodCk7XHJcblxyXG5cdFx0XHQvLyBEaWxhdGVcclxuXHRcdFx0bWFzayA9IGRpbGF0ZU1hc2sobWFzaywgaW1hZ2VEYXRhLndpZHRoLCBpbWFnZURhdGEuaGVpZ2h0KTtcclxuXHJcblx0XHRcdC8vIEdyYWRpZW50XHJcblx0XHRcdG1hc2sgPSBzbW9vdGhFZGdlTWFzayhtYXNrLCBpbWFnZURhdGEud2lkdGgsIGltYWdlRGF0YS5oZWlnaHQpO1xyXG5cclxuXHRcdFx0Ly8gQXBwbHkgbWFza1xyXG5cdFx0XHRhcHBseU1hc2soaW1hZ2VEYXRhLCBtYXNrKTtcclxuXHJcblx0XHRcdC8vIHRvZG8gOiBVcGRhdGUgaGl0IHJlZ2lvbiBmdW5jdGlvbiBhY2NvcmRpbmcgdG8gbWFza1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbWFnZURhdGE7XHJcblx0fTtcclxuXHJcblx0S29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3RocmVzaG9sZCcsIDAsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xyXG59KSgpO1xyXG5cbihmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICAvKipcclxuICAgICAqIFJHQiBGaWx0ZXJcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQG5hbWUgUkdCXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxyXG4gICAgICogQGF1dGhvciBpcHBvNjE1XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogbm9kZS5jYWNoZSgpO1xyXG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLlJHQl0pO1xyXG4gICAgICogbm9kZS5ibHVlKDEyMCk7XHJcbiAgICAgKiBub2RlLmdyZWVuKDIwMCk7XHJcbiAgICAgKi9cclxuICAgIEtvbnZhLkZpbHRlcnMuUkdCID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xyXG4gICAgICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXHJcbiAgICAgICAgICAgIG5QaXhlbHMgPSBkYXRhLmxlbmd0aCxcclxuICAgICAgICAgICAgcmVkID0gdGhpcy5yZWQoKSxcclxuICAgICAgICAgICAgZ3JlZW4gPSB0aGlzLmdyZWVuKCksXHJcbiAgICAgICAgICAgIGJsdWUgPSB0aGlzLmJsdWUoKSxcclxuICAgICAgICAgICAgaSwgYnJpZ2h0bmVzcztcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5QaXhlbHM7IGkgKz0gNCkge1xyXG4gICAgICAgICAgICBicmlnaHRuZXNzID0gKDAuMzQgKiBkYXRhW2ldICsgMC41ICogZGF0YVtpICsgMV0gKyAwLjE2ICogZGF0YVtpICsgMl0pIC8gMjU1O1xyXG4gICAgICAgICAgICBkYXRhW2ldID0gYnJpZ2h0bmVzcyAqIHJlZDsgLy8gclxyXG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IGJyaWdodG5lc3MgKiBncmVlbjsgLy8gZ1xyXG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IGJyaWdodG5lc3MgKiBibHVlOyAvLyBiXHJcbiAgICAgICAgICAgIGRhdGFbaSArIDNdID0gZGF0YVtpICsgM107IC8vIGFscGhhXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAncmVkJywgMCwgZnVuY3Rpb24odmFsKSB7XHJcbiAgICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcclxuICAgICAgICBpZiAodmFsID4gMjU1KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAyNTU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbCA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWwpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAqIGdldC9zZXQgZmlsdGVyIHJlZCB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUkdCfSBmaWx0ZXIuXHJcbiAgICAqIEBuYW1lIHJlZFxyXG4gICAgKiBAbWV0aG9kXHJcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgKiBAcGFyYW0ge0ludGVnZXJ9IHJlZCB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NVxyXG4gICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cclxuICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2dyZWVuJywgMCwgZnVuY3Rpb24odmFsKSB7XHJcbiAgICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcclxuICAgICAgICBpZiAodmFsID4gMjU1KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAyNTU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbCA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWwpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAqIGdldC9zZXQgZmlsdGVyIGdyZWVuIHZhbHVlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5SR0J9IGZpbHRlci5cclxuICAgICogQG5hbWUgZ3JlZW5cclxuICAgICogQG1ldGhvZFxyXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICogQHBhcmFtIHtJbnRlZ2VyfSBncmVlbiB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NVxyXG4gICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cclxuICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2JsdWUnLCAwLCBLb252YS5WYWxpZGF0b3JzLlJHQkNvbXBvbmVudCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XHJcbiAgICAvKipcclxuICAgICogZ2V0L3NldCBmaWx0ZXIgYmx1ZSB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUkdCfSBmaWx0ZXIuXHJcbiAgICAqIEBuYW1lIGJsdWVcclxuICAgICogQG1ldGhvZFxyXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICogQHBhcmFtIHtJbnRlZ2VyfSBibHVlIHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1XHJcbiAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxyXG4gICAgKi9cclxufSkoKTtcclxuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBSR0JBIEZpbHRlclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIFJHQkFcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAgKiBAYXV0aG9yIGNvZGVmb1xuICAgICAqIEBleGFtcGxlXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5SR0JBXSk7XG4gICAgICogbm9kZS5ibHVlKDEyMCk7XG4gICAgICogbm9kZS5ncmVlbigyMDApO1xuICAgICAqIG5vZGUuYWxwaGEoMC4zKTtcbiAgICAgKi9cbiAgICBLb252YS5GaWx0ZXJzLlJHQkEgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG4gICAgICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgICBuUGl4ZWxzID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICByZWQgPSB0aGlzLnJlZCgpLFxuICAgICAgICAgICAgZ3JlZW4gPSB0aGlzLmdyZWVuKCksXG4gICAgICAgICAgICBibHVlID0gdGhpcy5ibHVlKCksXG4gICAgICAgICAgICBhbHBoYSA9IHRoaXMuYWxwaGEoKSxcbiAgICAgICAgICAgIGksIGlhO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuUGl4ZWxzOyBpICs9IDQpIHtcbiAgICAgICAgICAgIGlhID0gMSAtIGFscGhhO1xuXG4gICAgICAgICAgICBkYXRhW2ldID0gcmVkICogYWxwaGEgKyBkYXRhW2ldICogaWE7IC8vIHJcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZ3JlZW4gKiBhbHBoYSArIGRhdGFbaSArIDFdICogaWE7IC8vIGdcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gYmx1ZSAqIGFscGhhICsgZGF0YVtpICsgMl0gKiBpYTsgLy8gYlxuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdyZWQnLCAwLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhbCA+IDI1NSkge1xuICAgICAgICAgICAgcmV0dXJuIDI1NTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAqIGdldC9zZXQgZmlsdGVyIHJlZCB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUkdCQX0gZmlsdGVyLlxuICAgICogQG5hbWUgcmVkXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7SW50ZWdlcn0gcmVkIHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1XG4gICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2dyZWVuJywgMCwgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlclVwVG9EYXRlID0gZmFsc2U7XG4gICAgICAgIGlmICh2YWwgPiAyNTUpIHtcbiAgICAgICAgICAgIHJldHVybiAyNTU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWwpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGZpbHRlciBncmVlbiB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUkdCQX0gZmlsdGVyLlxuICAgICogQG5hbWUgZ3JlZW5cbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtJbnRlZ2VyfSBncmVlbiB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NVxuICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdibHVlJywgMCwgS29udmEuVmFsaWRhdG9ycy5SR0JDb21wb25lbnQsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuICAgIC8qKlxuICAgICogZ2V0L3NldCBmaWx0ZXIgYmx1ZSB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUkdCQX0gZmlsdGVyLlxuICAgICogQG5hbWUgYmx1ZVxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge0ludGVnZXJ9IGJsdWUgdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTVcbiAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnYWxwaGEnLCAxLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhbCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsdGVyIGFscGhhIHZhbHVlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5SR0JBfSBmaWx0ZXIuXG4gICAgICogQG5hbWUgYWxwaGFcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtGbG9hdH0gYWxwaGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHJldHVybnMge0Zsb2F0fVxuICAgICAqL1xufSkoKTtcblxuKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8qKlxyXG4gICAgKiBIU1YgRmlsdGVyLiBBZGp1c3RzIHRoZSBodWUsIHNhdHVyYXRpb24gYW5kIHZhbHVlXHJcbiAgICAqIEBmdW5jdGlvblxyXG4gICAgKiBAbmFtZSBIU1ZcclxuICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcclxuICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxyXG4gICAgKiBAYXV0aG9yIGlwcG82MTVcclxuICAgICogQGV4YW1wbGVcclxuICAgICogaW1hZ2UuZmlsdGVycyhbS29udmEuRmlsdGVycy5IU1ZdKTtcclxuICAgICogaW1hZ2UudmFsdWUoMjAwKTtcclxuICAgICovXHJcblxyXG4gICAgS29udmEuRmlsdGVycy5IU1YgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcclxuICAgICAgICAgICAgblBpeGVscyA9IGRhdGEubGVuZ3RoLFxyXG4gICAgICAgICAgICB2ID0gTWF0aC5wb3coMiwgdGhpcy52YWx1ZSgpKSxcclxuICAgICAgICAgICAgcyA9IE1hdGgucG93KDIsIHRoaXMuc2F0dXJhdGlvbigpKSxcclxuICAgICAgICAgICAgaCA9IE1hdGguYWJzKCh0aGlzLmh1ZSgpKSArIDM2MCkgJSAzNjAsXHJcbiAgICAgICAgICAgIGk7XHJcblxyXG4gICAgICAgIC8vIEJhc2lzIGZvciB0aGUgdGVjaG5pcXVlIHVzZWQ6XHJcbiAgICAgICAgLy8gaHR0cDovL2JlZXNidXp6LmJpei9jb2RlL2hzdl9jb2xvcl90cmFuc2Zvcm1zLnBocFxyXG4gICAgICAgIC8vIFYgaXMgdGhlIHZhbHVlIG11bHRpcGxpZXIgKDEgZm9yIG5vbmUsIDIgZm9yIGRvdWJsZSwgMC41IGZvciBoYWxmKVxyXG4gICAgICAgIC8vIFMgaXMgdGhlIHNhdHVyYXRpb24gbXVsdGlwbGllciAoMSBmb3Igbm9uZSwgMiBmb3IgZG91YmxlLCAwLjUgZm9yIGhhbGYpXHJcbiAgICAgICAgLy8gSCBpcyB0aGUgaHVlIHNoaWZ0IGluIGRlZ3JlZXMgKDAgdG8gMzYwKVxyXG4gICAgICAgIC8vIHZzdSA9IFYqUypjb3MoSCpQSS8xODApO1xyXG4gICAgICAgIC8vIHZzdyA9IFYqUypzaW4oSCpQSS8xODApO1xyXG4gICAgICAgIC8vWyAuMjk5VisuNzAxdnN1Ky4xNjh2c3cgICAgLjU4N1YtLjU4N3ZzdSsuMzMwdnN3ICAgIC4xMTRWLS4xMTR2c3UtLjQ5N3ZzdyBdIFtSXVxyXG4gICAgICAgIC8vWyAuMjk5Vi0uMjk5dnN1LS4zMjh2c3cgICAgLjU4N1YrLjQxM3ZzdSsuMDM1dnN3ICAgIC4xMTRWLS4xMTR2c3UrLjI5MnZzdyBdKltHXVxyXG4gICAgICAgIC8vWyAuMjk5Vi0uMzAwdnN1KzEuMjV2c3cgICAgLjU4N1YtLjU4OHZzdS0xLjA1dnN3ICAgIC4xMTRWKy44ODZ2c3UtLjIwM3ZzdyBdIFtCXVxyXG5cclxuICAgICAgICAvLyBQcmVjb21wdXRlIHRoZSB2YWx1ZXMgaW4gdGhlIG1hdHJpeDpcclxuICAgICAgICB2YXIgdnN1ID0gdiAqIHMgKiBNYXRoLmNvcyhoICogTWF0aC5QSSAvIDE4MCksXHJcbiAgICAgICAgICAgIHZzdyA9IHYgKiBzICogTWF0aC5zaW4oaCAqIE1hdGguUEkgLyAxODApO1xyXG4gICAgICAgIC8vIChyZXN1bHQgc3BvdCkoc291cmNlIHNwb3QpXHJcbiAgICAgICAgdmFyIHJyID0gMC4yOTkgKiB2ICsgMC43MDEgKiB2c3UgKyAwLjE2NyAqIHZzdyxcclxuICAgICAgICAgICAgcmcgPSAwLjU4NyAqIHYgLSAwLjU4NyAqIHZzdSArIDAuMzMwICogdnN3LFxyXG4gICAgICAgICAgICByYiA9IDAuMTE0ICogdiAtIDAuMTE0ICogdnN1IC0gMC40OTcgKiB2c3c7XHJcbiAgICAgICAgdmFyIGdyID0gMC4yOTkgKiB2IC0gMC4yOTkgKiB2c3UgLSAwLjMyOCAqIHZzdyxcclxuICAgICAgICAgICAgZ2cgPSAwLjU4NyAqIHYgKyAwLjQxMyAqIHZzdSArIDAuMDM1ICogdnN3LFxyXG4gICAgICAgICAgICBnYiA9IDAuMTE0ICogdiAtIDAuMTE0ICogdnN1ICsgMC4yOTMgKiB2c3c7XHJcbiAgICAgICAgdmFyIGJyID0gMC4yOTkgKiB2IC0gMC4zMDAgKiB2c3UgKyAxLjI1MCAqIHZzdyxcclxuICAgICAgICAgICAgYmcgPSAwLjU4NyAqIHYgLSAwLjU4NiAqIHZzdSAtIDEuMDUwICogdnN3LFxyXG4gICAgICAgICAgICBiYiA9IDAuMTE0ICogdiArIDAuODg2ICogdnN1IC0gMC4yMDAgKiB2c3c7XHJcblxyXG4gICAgICAgIHZhciByLCBnLCBiLCBhO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgblBpeGVsczsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgIHIgPSBkYXRhW2kgKyAwXTtcclxuICAgICAgICAgICAgZyA9IGRhdGFbaSArIDFdO1xyXG4gICAgICAgICAgICBiID0gZGF0YVtpICsgMl07XHJcbiAgICAgICAgICAgIGEgPSBkYXRhW2kgKyAzXTtcclxuXHJcbiAgICAgICAgICAgIGRhdGFbaSArIDBdID0gcnIgKiByICsgcmcgKiBnICsgcmIgKiBiO1xyXG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IGdyICogciArIGdnICogZyArIGdiICogYjtcclxuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBiciAqIHIgKyBiZyAqIGcgKyBiYiAqIGI7XHJcbiAgICAgICAgICAgIGRhdGFbaSArIDNdID0gYTsgLy8gYWxwaGFcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnaHVlJywgMCwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XHJcbiAgICAvKipcclxuICAgICogZ2V0L3NldCBoc3YgaHVlIGluIGRlZ3JlZXMuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkhTVn0gb3Ige0BsaW5rIEtvbnZhLkZpbHRlcnMuSFNMfSBmaWx0ZXIuXHJcbiAgICAqIEBuYW1lIGh1ZVxyXG4gICAgKiBAbWV0aG9kXHJcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgKiBAcGFyYW0ge051bWJlcn0gaHVlIHZhbHVlIGJldHdlZW4gMCBhbmQgMzU5XHJcbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdzYXR1cmF0aW9uJywgMCwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XHJcbiAgICAvKipcclxuICAgICogZ2V0L3NldCBoc3Ygc2F0dXJhdGlvbi4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuSFNWfSBvciB7QGxpbmsgS29udmEuRmlsdGVycy5IU0x9IGZpbHRlci5cclxuICAgICogQG5hbWUgc2F0dXJhdGlvblxyXG4gICAgKiBAbWV0aG9kXHJcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgKiBAcGFyYW0ge051bWJlcn0gc2F0dXJhdGlvbiAwIGlzIG5vIGNoYW5nZSwgLTEuMCBoYWx2ZXMgdGhlIHNhdHVyYXRpb24sIDEuMCBkb3VibGVzLCBldGMuLlxyXG4gICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAndmFsdWUnLCAwLCBudWxsLCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcclxuICAgIC8qKlxyXG4gICAgKiBnZXQvc2V0IGhzdiB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuSFNWfSBmaWx0ZXIuXHJcbiAgICAqIEBuYW1lIHZhbHVlXHJcbiAgICAqIEBtZXRob2RcclxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAwIGlzIG5vIGNoYW5nZSwgLTEuMCBoYWx2ZXMgdGhlIHZhbHVlLCAxLjAgZG91YmxlcywgZXRjLi5cclxuICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICovXHJcblxyXG59KSgpO1xyXG5cbihmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2h1ZScsIDAsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xyXG4gICAgLyoqXHJcbiAgICAqIGdldC9zZXQgaHN2IGh1ZSBpbiBkZWdyZWVzLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5IU1Z9IG9yIHtAbGluayBLb252YS5GaWx0ZXJzLkhTTH0gZmlsdGVyLlxyXG4gICAgKiBAbmFtZSBodWVcclxuICAgICogQG1ldGhvZFxyXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICogQHBhcmFtIHtOdW1iZXJ9IGh1ZSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDM1OVxyXG4gICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnc2F0dXJhdGlvbicsIDAsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xyXG4gICAgLyoqXHJcbiAgICAqIGdldC9zZXQgaHN2IHNhdHVyYXRpb24uIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkhTVn0gb3Ige0BsaW5rIEtvbnZhLkZpbHRlcnMuSFNMfSBmaWx0ZXIuXHJcbiAgICAqIEBuYW1lIHNhdHVyYXRpb25cclxuICAgICogQG1ldGhvZFxyXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHNhdHVyYXRpb24gMCBpcyBubyBjaGFuZ2UsIC0xLjAgaGFsdmVzIHRoZSBzYXR1cmF0aW9uLCAxLjAgZG91YmxlcywgZXRjLi5cclxuICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2x1bWluYW5jZScsIDAsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xyXG4gICAgLyoqXHJcbiAgICAqIGdldC9zZXQgaHNsIGx1bWluYW5jZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuSFNMfSBmaWx0ZXIuXHJcbiAgICAqIEBuYW1lIHZhbHVlXHJcbiAgICAqIEBtZXRob2RcclxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAwIGlzIG5vIGNoYW5nZSwgLTEuMCBoYWx2ZXMgdGhlIHZhbHVlLCAxLjAgZG91YmxlcywgZXRjLi5cclxuICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEhTTCBGaWx0ZXIuIEFkanVzdHMgdGhlIGh1ZSwgc2F0dXJhdGlvbiBhbmQgbHVtaW5hbmNlIChvciBsaWdodG5lc3MpXHJcbiAgICAqIEBmdW5jdGlvblxyXG4gICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXHJcbiAgICAqIEBhdXRob3IgaXBwbzYxNVxyXG4gICAgKiBAZXhhbXBsZVxyXG4gICAgKiBpbWFnZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkhTTF0pO1xyXG4gICAgKiBpbWFnZS5sdW1pbmFuY2UoMjAwKTtcclxuICAgICovXHJcblxyXG4gICAgS29udmEuRmlsdGVycy5IU0wgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcclxuICAgICAgICAgICAgblBpeGVscyA9IGRhdGEubGVuZ3RoLFxyXG4gICAgICAgICAgICB2ID0gMSxcclxuICAgICAgICAgICAgcyA9IE1hdGgucG93KDIsIHRoaXMuc2F0dXJhdGlvbigpKSxcclxuICAgICAgICAgICAgaCA9IE1hdGguYWJzKCh0aGlzLmh1ZSgpKSArIDM2MCkgJSAzNjAsXHJcbiAgICAgICAgICAgIGwgPSB0aGlzLmx1bWluYW5jZSgpICogMTI3LFxyXG4gICAgICAgICAgICBpO1xyXG5cclxuICAgICAgICAvLyBCYXNpcyBmb3IgdGhlIHRlY2huaXF1ZSB1c2VkOlxyXG4gICAgICAgIC8vIGh0dHA6Ly9iZWVzYnV6ei5iaXovY29kZS9oc3ZfY29sb3JfdHJhbnNmb3Jtcy5waHBcclxuICAgICAgICAvLyBWIGlzIHRoZSB2YWx1ZSBtdWx0aXBsaWVyICgxIGZvciBub25lLCAyIGZvciBkb3VibGUsIDAuNSBmb3IgaGFsZilcclxuICAgICAgICAvLyBTIGlzIHRoZSBzYXR1cmF0aW9uIG11bHRpcGxpZXIgKDEgZm9yIG5vbmUsIDIgZm9yIGRvdWJsZSwgMC41IGZvciBoYWxmKVxyXG4gICAgICAgIC8vIEggaXMgdGhlIGh1ZSBzaGlmdCBpbiBkZWdyZWVzICgwIHRvIDM2MClcclxuICAgICAgICAvLyB2c3UgPSBWKlMqY29zKEgqUEkvMTgwKTtcclxuICAgICAgICAvLyB2c3cgPSBWKlMqc2luKEgqUEkvMTgwKTtcclxuICAgICAgICAvL1sgLjI5OVYrLjcwMXZzdSsuMTY4dnN3ICAgIC41ODdWLS41ODd2c3UrLjMzMHZzdyAgICAuMTE0Vi0uMTE0dnN1LS40OTd2c3cgXSBbUl1cclxuICAgICAgICAvL1sgLjI5OVYtLjI5OXZzdS0uMzI4dnN3ICAgIC41ODdWKy40MTN2c3UrLjAzNXZzdyAgICAuMTE0Vi0uMTE0dnN1Ky4yOTJ2c3cgXSpbR11cclxuICAgICAgICAvL1sgLjI5OVYtLjMwMHZzdSsxLjI1dnN3ICAgIC41ODdWLS41ODh2c3UtMS4wNXZzdyAgICAuMTE0VisuODg2dnN1LS4yMDN2c3cgXSBbQl1cclxuXHJcbiAgICAgICAgLy8gUHJlY29tcHV0ZSB0aGUgdmFsdWVzIGluIHRoZSBtYXRyaXg6XHJcbiAgICAgICAgdmFyIHZzdSA9IHYgKiBzICogTWF0aC5jb3MoaCAqIE1hdGguUEkgLyAxODApLFxyXG4gICAgICAgICAgICB2c3cgPSB2ICogcyAqIE1hdGguc2luKGggKiBNYXRoLlBJIC8gMTgwKTtcclxuICAgICAgICAvLyAocmVzdWx0IHNwb3QpKHNvdXJjZSBzcG90KVxyXG4gICAgICAgIHZhciByciA9IDAuMjk5ICogdiArIDAuNzAxICogdnN1ICsgMC4xNjcgKiB2c3csXHJcbiAgICAgICAgICAgIHJnID0gMC41ODcgKiB2IC0gMC41ODcgKiB2c3UgKyAwLjMzMCAqIHZzdyxcclxuICAgICAgICAgICAgcmIgPSAwLjExNCAqIHYgLSAwLjExNCAqIHZzdSAtIDAuNDk3ICogdnN3O1xyXG4gICAgICAgIHZhciBnciA9IDAuMjk5ICogdiAtIDAuMjk5ICogdnN1IC0gMC4zMjggKiB2c3csXHJcbiAgICAgICAgICAgIGdnID0gMC41ODcgKiB2ICsgMC40MTMgKiB2c3UgKyAwLjAzNSAqIHZzdyxcclxuICAgICAgICAgICAgZ2IgPSAwLjExNCAqIHYgLSAwLjExNCAqIHZzdSArIDAuMjkzICogdnN3O1xyXG4gICAgICAgIHZhciBiciA9IDAuMjk5ICogdiAtIDAuMzAwICogdnN1ICsgMS4yNTAgKiB2c3csXHJcbiAgICAgICAgICAgIGJnID0gMC41ODcgKiB2IC0gMC41ODYgKiB2c3UgLSAxLjA1MCAqIHZzdyxcclxuICAgICAgICAgICAgYmIgPSAwLjExNCAqIHYgKyAwLjg4NiAqIHZzdSAtIDAuMjAwICogdnN3O1xyXG5cclxuICAgICAgICB2YXIgciwgZywgYiwgYTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5QaXhlbHM7IGkgKz0gNCkge1xyXG4gICAgICAgICAgICByID0gZGF0YVtpICsgMF07XHJcbiAgICAgICAgICAgIGcgPSBkYXRhW2kgKyAxXTtcclxuICAgICAgICAgICAgYiA9IGRhdGFbaSArIDJdO1xyXG4gICAgICAgICAgICBhID0gZGF0YVtpICsgM107XHJcblxyXG4gICAgICAgICAgICBkYXRhW2kgKyAwXSA9IHJyICogciArIHJnICogZyArIHJiICogYiArIGw7XHJcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZ3IgKiByICsgZ2cgKiBnICsgZ2IgKiBiICsgbDtcclxuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBiciAqIHIgKyBiZyAqIGcgKyBiYiAqIGIgKyBsO1xyXG4gICAgICAgICAgICBkYXRhW2kgKyAzXSA9IGE7IC8vIGFscGhhXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufSkoKTtcclxuXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbWJvc3MgRmlsdGVyLlxyXG4gICAgICogUGl4YXN0aWMgTGliIC0gRW1ib3NzIGZpbHRlciAtIHYwLjEuMFxyXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDA4IEphY29iIFNlaWRlbGluLCBqc2VpZGVsaW5AbmloaWxvZ2ljLmRrLCBodHRwOi8vYmxvZy5uaWhpbG9naWMuZGsvXHJcbiAgICAgKiBMaWNlbnNlOiBbaHR0cDovL3d3dy5waXhhc3RpYy5jb20vbGliL2xpY2Vuc2UudHh0XVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIG5vZGUuY2FjaGUoKTtcclxuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5FbWJvc3NdKTtcclxuICAgICAqIG5vZGUuZW1ib3NzU3RyZW5ndGgoMC44KTtcclxuICAgICAqIG5vZGUuZW1ib3NzV2hpdGVMZXZlbCgwLjMpO1xyXG4gICAgICogbm9kZS5lbWJvc3NEaXJlY3Rpb24oJ3JpZ2h0Jyk7XHJcbiAgICAgKiBub2RlLmVtYm9zc0JsZW5kKHRydWUpO1xyXG4gICAgICovXHJcbiAgICBLb252YS5GaWx0ZXJzLkVtYm9zcyA9IGZ1bmN0aW9uIChpbWFnZURhdGEpIHtcclxuXHJcbiAgICAgICAgLy8gcGl4YXN0aWMgc3RyZW5ndGggaXMgYmV0d2VlbiAwIGFuZCAxMC4gIEkgd2FudCBpdCBiZXR3ZWVuIDAgYW5kIDFcclxuICAgICAgICAvLyBwaXhhc3RpYyBncmV5TGV2ZWwgaXMgYmV0d2VlbiAwIGFuZCAyNTUuICBJIHdhbnQgaXQgYmV0d2VlbiAwIGFuZCAxLiAgQWxzbyxcclxuICAgICAgICAvLyBhIG1heCB2YWx1ZSBvZiBncmV5TGV2ZWwgeWllbGRzIGEgd2hpdGUgZW1ib3NzLCBhbmQgdGhlIG1pbiB2YWx1ZSB5aWVsZHMgYSBibGFja1xyXG4gICAgICAgIC8vIGVtYm9zcy4gIFRoZXJlZm9yZSwgSSBjaGFuZ2VkIGdyZXlMZXZlbCB0byB3aGl0ZUxldmVsXHJcbiAgICAgICAgdmFyIHN0cmVuZ3RoID0gdGhpcy5lbWJvc3NTdHJlbmd0aCgpICogMTAsXHJcbiAgICAgICAgICAgIGdyZXlMZXZlbCA9IHRoaXMuZW1ib3NzV2hpdGVMZXZlbCgpICogMjU1LFxyXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSB0aGlzLmVtYm9zc0RpcmVjdGlvbigpLFxyXG4gICAgICAgICAgICBibGVuZCA9IHRoaXMuZW1ib3NzQmxlbmQoKSxcclxuICAgICAgICAgICAgZGlyWSA9IDAsXHJcbiAgICAgICAgICAgIGRpclggPSAwLFxyXG4gICAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXHJcbiAgICAgICAgICAgIHcgPSBpbWFnZURhdGEud2lkdGgsXHJcbiAgICAgICAgICAgIGggPSBpbWFnZURhdGEuaGVpZ2h0LFxyXG4gICAgICAgICAgICB3NCA9IHcgKiA0LFxyXG4gICAgICAgICAgICB5ID0gaDtcclxuXHJcbiAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgY2FzZSAndG9wLWxlZnQnOlxyXG4gICAgICAgICAgICAgICAgZGlyWSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgZGlyWCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgICAgICAgICBkaXJZID0gLTE7XHJcbiAgICAgICAgICAgICAgICBkaXJYID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd0b3AtcmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgZGlyWSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgZGlyWCA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgZGlyWSA9IDA7XHJcbiAgICAgICAgICAgICAgICBkaXJYID0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdib3R0b20tcmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgZGlyWSA9IDE7XHJcbiAgICAgICAgICAgICAgICBkaXJYID0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgICAgICAgICAgZGlyWSA9IDE7XHJcbiAgICAgICAgICAgICAgICBkaXJYID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdib3R0b20tbGVmdCc6XHJcbiAgICAgICAgICAgICAgICBkaXJZID0gMTtcclxuICAgICAgICAgICAgICAgIGRpclggPSAtMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgICAgICAgIGRpclkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZGlyWCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXRZID0gKHkgLSAxKSAqIHc0O1xyXG5cclxuICAgICAgICAgICAgdmFyIG90aGVyWSA9IGRpclk7XHJcbiAgICAgICAgICAgIGlmICh5ICsgb3RoZXJZIDwgMSl7XHJcbiAgICAgICAgICAgICAgICBvdGhlclkgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh5ICsgb3RoZXJZID4gaCkge1xyXG4gICAgICAgICAgICAgICAgb3RoZXJZID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG9mZnNldFlPdGhlciA9ICh5IC0gMSArIG90aGVyWSkgKiB3ICogNDtcclxuXHJcbiAgICAgICAgICAgIHZhciB4ID0gdztcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldFkgKyAoeCAtIDEpICogNDtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJYID0gZGlyWDtcclxuICAgICAgICAgICAgICAgIGlmICh4ICsgb3RoZXJYIDwgMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJYID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh4ICsgb3RoZXJYID4gdykge1xyXG4gICAgICAgICAgICAgICAgICAgIG90aGVyWCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldE90aGVyID0gb2Zmc2V0WU90aGVyICsgKHggLSAxICsgb3RoZXJYKSAqIDQ7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGRSID0gZGF0YVtvZmZzZXRdIC0gZGF0YVtvZmZzZXRPdGhlcl07XHJcbiAgICAgICAgICAgICAgICB2YXIgZEcgPSBkYXRhW29mZnNldCArIDFdIC0gZGF0YVtvZmZzZXRPdGhlciArIDFdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRCID0gZGF0YVtvZmZzZXQgKyAyXSAtIGRhdGFbb2Zmc2V0T3RoZXIgKyAyXTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZGlmID0gZFI7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWJzRGlmID0gZGlmID4gMCA/IGRpZiA6IC1kaWY7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGFic0cgPSBkRyA+IDAgPyBkRyA6IC1kRztcclxuICAgICAgICAgICAgICAgIHZhciBhYnNCID0gZEIgPiAwID8gZEIgOiAtZEI7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGFic0cgPiBhYnNEaWYpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaWYgPSBkRztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhYnNCID4gYWJzRGlmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlmID0gZEI7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZGlmICo9IHN0cmVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChibGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gZGF0YVtvZmZzZXRdICsgZGlmO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnID0gZGF0YVtvZmZzZXQgKyAxXSArIGRpZjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGRhdGFbb2Zmc2V0ICsgMl0gKyBkaWY7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IChyID4gMjU1KSA/IDI1NSA6IChyIDwgMCA/IDAgOiByKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIDFdID0gKGcgPiAyNTUpID8gMjU1IDogKGcgPCAwID8gMCA6IGcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgMl0gPSAoYiA+IDI1NSkgPyAyNTUgOiAoYiA8IDAgPyAwIDogYik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBncmV5ID0gZ3JleUxldmVsIC0gZGlmO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChncmV5IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBncmV5ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGdyZXkgPiAyNTUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JleSA9IDI1NTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IGRhdGFbb2Zmc2V0ICsgMV0gPSBkYXRhW29mZnNldCArIDJdID0gZ3JleTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gd2hpbGUgKC0teCk7XHJcbiAgICAgICAgfSB3aGlsZSAoLS15KTtcclxuICAgIH07XHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2VtYm9zc1N0cmVuZ3RoJywgMC41LCBudWxsLCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcclxuICAgIC8qKlxyXG4gICAgKiBnZXQvc2V0IGVtYm9zcyBzdHJlbmd0aC4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuRW1ib3NzfSBmaWx0ZXIuXHJcbiAgICAqIEBuYW1lIGVtYm9zc1N0cmVuZ3RoXHJcbiAgICAqIEBtZXRob2RcclxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBiZXR3ZWVuIDAgYW5kIDEuICBEZWZhdWx0IGlzIDAuNVxyXG4gICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZW1ib3NzV2hpdGVMZXZlbCcsIDAuNSwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XHJcbiAgICAvKipcclxuICAgICogZ2V0L3NldCBlbWJvc3Mgd2hpdGUgbGV2ZWwuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkVtYm9zc30gZmlsdGVyLlxyXG4gICAgKiBAbmFtZSBlbWJvc3NXaGl0ZUxldmVsXHJcbiAgICAqIEBtZXRob2RcclxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbWJvc3NXaGl0ZUxldmVsIGJldHdlZW4gMCBhbmQgMS4gIERlZmF1bHQgaXMgMC41XHJcbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdlbWJvc3NEaXJlY3Rpb24nLCAndG9wLWxlZnQnLCBudWxsLCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcclxuICAgIC8qKlxyXG4gICAgKiBnZXQvc2V0IGVtYm9zcyBkaXJlY3Rpb24uIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkVtYm9zc30gZmlsdGVyLlxyXG4gICAgKiBAbmFtZSBlbWJvc3NEaXJlY3Rpb25cclxuICAgICogQG1ldGhvZFxyXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICogQHBhcmFtIHtTdHJpbmd9IGVtYm9zc0RpcmVjdGlvbiBjYW4gYmUgdG9wLWxlZnQsIHRvcCwgdG9wLXJpZ2h0LCByaWdodCwgYm90dG9tLXJpZ2h0LCBib3R0b20sIGJvdHRvbS1sZWZ0IG9yIGxlZnRcclxuICAgICogICBUaGUgZGVmYXVsdCBpcyB0b3AtbGVmdFxyXG4gICAgKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZW1ib3NzQmxlbmQnLCBmYWxzZSwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XHJcbiAgICAvKipcclxuICAgICogZ2V0L3NldCBlbWJvc3MgYmxlbmQuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkVtYm9zc30gZmlsdGVyLlxyXG4gICAgKiBAbmFtZSBlbWJvc3NCbGVuZFxyXG4gICAgKiBAbWV0aG9kXHJcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVtYm9zc0JsZW5kXHJcbiAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgKi9cclxufSkoKTtcclxuXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgZnVuY3Rpb24gcmVtYXAoZnJvbVZhbHVlLCBmcm9tTWluLCBmcm9tTWF4LCB0b01pbiwgdG9NYXgpIHtcclxuICAgICAgICAvLyBDb21wdXRlIHRoZSByYW5nZSBvZiB0aGUgZGF0YVxyXG4gICAgICAgIHZhciBmcm9tUmFuZ2UgPSBmcm9tTWF4IC0gZnJvbU1pbixcclxuICAgICAgICAgIHRvUmFuZ2UgPSB0b01heCAtIHRvTWluLFxyXG4gICAgICAgICAgdG9WYWx1ZTtcclxuXHJcbiAgICAgICAgLy8gSWYgZWl0aGVyIHJhbmdlIGlzIDAsIHRoZW4gdGhlIHZhbHVlIGNhbiBvbmx5IGJlIG1hcHBlZCB0byAxIHZhbHVlXHJcbiAgICAgICAgaWYgKGZyb21SYW5nZSA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdG9NaW4gKyB0b1JhbmdlIC8gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRvUmFuZ2UgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRvTWluO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gKDEpIHVudHJhbnNsYXRlLCAoMikgdW5zY2FsZSwgKDMpIHJlc2NhbGUsICg0KSByZXRyYW5zbGF0ZVxyXG4gICAgICAgIHRvVmFsdWUgPSAoZnJvbVZhbHVlIC0gZnJvbU1pbikgLyBmcm9tUmFuZ2U7XHJcbiAgICAgICAgdG9WYWx1ZSA9ICh0b1JhbmdlICogdG9WYWx1ZSkgKyB0b01pbjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRvVmFsdWU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBFbmhhbmNlIEZpbHRlci4gQWRqdXN0cyB0aGUgY29sb3JzIHNvIHRoYXQgdGhleSBzcGFuIHRoZSB3aWRlc3RcclxuICAgICogIHBvc3NpYmxlIHJhbmdlIChpZSAwLTI1NSkuIFBlcmZvcm1zIHcqaCBwaXhlbCByZWFkcyBhbmQgdypoIHBpeGVsXHJcbiAgICAqICB3cml0ZXMuXHJcbiAgICAqIEBmdW5jdGlvblxyXG4gICAgKiBAbmFtZSBFbmhhbmNlXHJcbiAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXHJcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcclxuICAgICogQGF1dGhvciBpcHBvNjE1XHJcbiAgICAqIEBleGFtcGxlXHJcbiAgICAqIG5vZGUuY2FjaGUoKTtcclxuICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkVuaGFuY2VdKTtcclxuICAgICogbm9kZS5lbmhhbmNlKDAuNCk7XHJcbiAgICAqL1xyXG4gICAgS29udmEuRmlsdGVycy5FbmhhbmNlID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xyXG4gICAgICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXHJcbiAgICAgICAgICAgIG5TdWJQaXhlbHMgPSBkYXRhLmxlbmd0aCxcclxuICAgICAgICAgICAgck1pbiA9IGRhdGFbMF0sIHJNYXggPSByTWluLCByLFxyXG4gICAgICAgICAgICBnTWluID0gZGF0YVsxXSwgZ01heCA9IGdNaW4sIGcsXHJcbiAgICAgICAgICAgIGJNaW4gPSBkYXRhWzJdLCBiTWF4ID0gYk1pbiwgYixcclxuICAgICAgICAgICAgaTtcclxuXHJcbiAgICAgICAgLy8gSWYgd2UgYXJlIG5vdCBlbmhhbmNpbmcgYW55dGhpbmcgLSBkb24ndCBkbyBhbnkgY29tcHV0YXRpb25cclxuICAgICAgICB2YXIgZW5oYW5jZUFtb3VudCA9IHRoaXMuZW5oYW5jZSgpO1xyXG4gICAgICAgIGlmKCBlbmhhbmNlQW1vdW50ID09PSAwICl7IHJldHVybjsgfVxyXG5cclxuICAgICAgICAvLyAxc3QgUGFzcyAtIGZpbmQgdGhlIG1pbiBhbmQgbWF4IGZvciBlYWNoIGNoYW5uZWw6XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5TdWJQaXhlbHM7IGkgKz0gNCkge1xyXG4gICAgICAgICAgICByID0gZGF0YVtpICsgMF07XHJcbiAgICAgICAgICAgIGlmIChyIDwgck1pbikgeyByTWluID0gcjsgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChyID4gck1heCkgeyByTWF4ID0gcjsgfVxyXG4gICAgICAgICAgICBnID0gZGF0YVtpICsgMV07XHJcbiAgICAgICAgICAgIGlmIChnIDwgZ01pbikgeyBnTWluID0gZzsgfSBlbHNlXHJcbiAgICAgICAgICAgIGlmIChnID4gZ01heCkgeyBnTWF4ID0gZzsgfVxyXG4gICAgICAgICAgICBiID0gZGF0YVtpICsgMl07XHJcbiAgICAgICAgICAgIGlmIChiIDwgYk1pbikgeyBiTWluID0gYjsgfSBlbHNlXHJcbiAgICAgICAgICAgIGlmIChiID4gYk1heCkgeyBiTWF4ID0gYjsgfVxyXG4gICAgICAgICAgICAvL2EgPSBkYXRhW2kgKyAzXTtcclxuICAgICAgICAgICAgLy9pZiAoYSA8IGFNaW4pIHsgYU1pbiA9IGE7IH0gZWxzZVxyXG4gICAgICAgICAgICAvL2lmIChhID4gYU1heCkgeyBhTWF4ID0gYTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgb25seSAxIGxldmVsIC0gZG9uJ3QgcmVtYXBcclxuICAgICAgICBpZiggck1heCA9PT0gck1pbiApeyByTWF4ID0gMjU1OyByTWluID0gMDsgfVxyXG4gICAgICAgIGlmKCBnTWF4ID09PSBnTWluICl7IGdNYXggPSAyNTU7IGdNaW4gPSAwOyB9XHJcbiAgICAgICAgaWYoIGJNYXggPT09IGJNaW4gKXsgYk1heCA9IDI1NTsgYk1pbiA9IDA7IH1cclxuXHJcbiAgICAgICAgdmFyIHJNaWQsIHJHb2FsTWF4LCByR29hbE1pbixcclxuICAgICAgICAgICAgZ01pZCwgZ0dvYWxNYXgsIGdHb2FsTWluLFxyXG4gICAgICAgICAgICBiTWlkLCBiR29hbE1heCwgYkdvYWxNaW47XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBlbmhhbmNlbWVudCBpcyBwb3NpdGl2ZSAtIHN0cmV0Y2ggdGhlIGhpc3RvZ3JhbVxyXG4gICAgICAgIGlmICggZW5oYW5jZUFtb3VudCA+IDAgKXtcclxuICAgICAgICAgICAgckdvYWxNYXggPSByTWF4ICsgZW5oYW5jZUFtb3VudCAqICgyNTUgLSByTWF4KTtcclxuICAgICAgICAgICAgckdvYWxNaW4gPSByTWluIC0gZW5oYW5jZUFtb3VudCAqIChyTWluIC0gMCk7XHJcbiAgICAgICAgICAgIGdHb2FsTWF4ID0gZ01heCArIGVuaGFuY2VBbW91bnQgKiAoMjU1IC0gZ01heCk7XHJcbiAgICAgICAgICAgIGdHb2FsTWluID0gZ01pbiAtIGVuaGFuY2VBbW91bnQgKiAoZ01pbiAtIDApO1xyXG4gICAgICAgICAgICBiR29hbE1heCA9IGJNYXggKyBlbmhhbmNlQW1vdW50ICogKDI1NSAtIGJNYXgpO1xyXG4gICAgICAgICAgICBiR29hbE1pbiA9IGJNaW4gLSBlbmhhbmNlQW1vdW50ICogKGJNaW4gLSAwKTtcclxuICAgICAgICAvLyBJZiB0aGUgZW5oYW5jZW1lbnQgaXMgbmVnYXRpdmUgLSAgIGNvbXByZXNzIHRoZSBoaXN0b2dyYW1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByTWlkID0gKHJNYXggKyByTWluKSAqIDAuNTtcclxuICAgICAgICAgICAgckdvYWxNYXggPSByTWF4ICsgZW5oYW5jZUFtb3VudCAqIChyTWF4IC0gck1pZCk7XHJcbiAgICAgICAgICAgIHJHb2FsTWluID0gck1pbiArIGVuaGFuY2VBbW91bnQgKiAock1pbiAtIHJNaWQpO1xyXG4gICAgICAgICAgICBnTWlkID0gKGdNYXggKyBnTWluKSAqIDAuNTtcclxuICAgICAgICAgICAgZ0dvYWxNYXggPSBnTWF4ICsgZW5oYW5jZUFtb3VudCAqIChnTWF4IC0gZ01pZCk7XHJcbiAgICAgICAgICAgIGdHb2FsTWluID0gZ01pbiArIGVuaGFuY2VBbW91bnQgKiAoZ01pbiAtIGdNaWQpO1xyXG4gICAgICAgICAgICBiTWlkID0gKGJNYXggKyBiTWluKSAqIDAuNTtcclxuICAgICAgICAgICAgYkdvYWxNYXggPSBiTWF4ICsgZW5oYW5jZUFtb3VudCAqIChiTWF4IC0gYk1pZCk7XHJcbiAgICAgICAgICAgIGJHb2FsTWluID0gYk1pbiArIGVuaGFuY2VBbW91bnQgKiAoYk1pbiAtIGJNaWQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUGFzcyAyIC0gcmVtYXAgZXZlcnl0aGluZywgZXhjZXB0IHRoZSBhbHBoYVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuU3ViUGl4ZWxzOyBpICs9IDQpIHtcclxuICAgICAgICAgICAgZGF0YVtpICsgMF0gPSByZW1hcChkYXRhW2kgKyAwXSwgck1pbiwgck1heCwgckdvYWxNaW4sIHJHb2FsTWF4KTtcclxuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSByZW1hcChkYXRhW2kgKyAxXSwgZ01pbiwgZ01heCwgZ0dvYWxNaW4sIGdHb2FsTWF4KTtcclxuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSByZW1hcChkYXRhW2kgKyAyXSwgYk1pbiwgYk1heCwgYkdvYWxNaW4sIGJHb2FsTWF4KTtcclxuICAgICAgICAgICAgLy9kYXRhW2kgKyAzXSA9IHJlbWFwKGRhdGFbaSArIDNdLCBhTWluLCBhTWF4LCBhR29hbE1pbiwgYUdvYWxNYXgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2VuaGFuY2UnLCAwLCBudWxsLCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcclxuXHJcbiAgICAvKipcclxuICAgICogZ2V0L3NldCBlbmhhbmNlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5FbmhhbmNlfSBmaWx0ZXIuXHJcbiAgICAqIEBuYW1lIGVuaGFuY2VcclxuICAgICogQG1ldGhvZFxyXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICogQHBhcmFtIHtGbG9hdH0gYW1vdW50XHJcbiAgICAqIEByZXR1cm5zIHtGbG9hdH1cclxuICAgICovXHJcbn0pKCk7XHJcblxuKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8qKlxyXG4gICAgICogUG9zdGVyaXplIEZpbHRlci4gQWRqdXN0cyB0aGUgY2hhbm5lbHMgc28gdGhhdCB0aGVyZSBhcmUgbm8gbW9yZVxyXG4gICAgICogIHRoYW4gbiBkaWZmZXJlbnQgdmFsdWVzIGZvciB0aGF0IGNoYW5uZWwuIFRoaXMgaXMgYWxzbyBhcHBsaWVkXHJcbiAgICAgKiAgdG8gdGhlIGFscGhhIGNoYW5uZWwuXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBuYW1lIFBvc3Rlcml6ZVxyXG4gICAgICogQGF1dGhvciBpcHBvNjE1XHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIG5vZGUuY2FjaGUoKTtcclxuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5Qb3N0ZXJpemVdKTtcclxuICAgICAqIG5vZGUubGV2ZWxzKDAuOCk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GaWx0ZXJzLlBvc3Rlcml6ZSA9IGZ1bmN0aW9uIChpbWFnZURhdGEpIHtcclxuICAgICAgICAvLyBsZXZlbCBtdXN0IGJlIGJldHdlZW4gMSBhbmQgMjU1XHJcbiAgICAgICAgdmFyIGxldmVscyA9IE1hdGgucm91bmQodGhpcy5sZXZlbHMoKSAqIDI1NCkgKyAxLFxyXG4gICAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXHJcbiAgICAgICAgICAgIGxlbiA9IGRhdGEubGVuZ3RoLFxyXG4gICAgICAgICAgICBzY2FsZSA9ICgyNTUgLyBsZXZlbHMpLFxyXG4gICAgICAgICAgICBpO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgZGF0YVtpXSA9IE1hdGguZmxvb3IoZGF0YVtpXSAvIHNjYWxlKSAqIHNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2xldmVscycsIDAuNSwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIGdldC9zZXQgbGV2ZWxzLiAgTXVzdCBiZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuICBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5Qb3N0ZXJpemV9IGZpbHRlci5cclxuICAgICogQG5hbWUgbGV2ZWxzXHJcbiAgICAqIEBtZXRob2RcclxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBiZXR3ZWVuIDAgYW5kIDFcclxuICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICovXHJcbn0pKCk7XHJcblxuKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vaXNlIEZpbHRlci4gUmFuZG9tbHkgYWRkcyBvciBzdWJzdHJhY3RzIHRvIHRoZSBjb2xvciBjaGFubmVsc1xyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAbmFtZSBOb2lzZVxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcclxuICAgICAqIEBhdXRob3IgaXBwbzYxNVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIG5vZGUuY2FjaGUoKTtcclxuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5Ob2lzZV0pO1xyXG4gICAgICogbm9kZS5ub2lzZSgwLjgpO1xyXG4gICAgICovXHJcbiAgICBLb252YS5GaWx0ZXJzLk5vaXNlID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xyXG4gICAgICAgIHZhciBhbW91bnQgPSB0aGlzLm5vaXNlKCkgKiAyNTUsXHJcbiAgICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcclxuICAgICAgICAgICAgblBpeGVscyA9IGRhdGEubGVuZ3RoLFxyXG4gICAgICAgICAgICBoYWxmID0gYW1vdW50IC8gMixcclxuICAgICAgICAgICAgaTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5QaXhlbHM7IGkgKz0gNCkge1xyXG4gICAgICAgICAgICBkYXRhW2kgKyAwXSArPSBoYWxmIC0gMiAqIGhhbGYgKiBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgICAgICBkYXRhW2kgKyAxXSArPSBoYWxmIC0gMiAqIGhhbGYgKiBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgICAgICBkYXRhW2kgKyAyXSArPSBoYWxmIC0gMiAqIGhhbGYgKiBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ25vaXNlJywgMC4yLCBudWxsLCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcclxuXHJcbiAgICAvKipcclxuICAgICogZ2V0L3NldCBub2lzZSBhbW91bnQuICBNdXN0IGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5Ob2lzZX0gZmlsdGVyLlxyXG4gICAgKiBAbmFtZSBub2lzZVxyXG4gICAgKiBAbWV0aG9kXHJcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgKiBAcGFyYW0ge051bWJlcn0gbm9pc2VcclxuICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICovXHJcbn0pKCk7XHJcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtZGVwdGggKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8qKlxyXG4gICAgICogUGl4ZWxhdGUgRmlsdGVyLiBBdmVyYWdlcyBncm91cHMgb2YgcGl4ZWxzIGFuZCByZWRyYXdzXHJcbiAgICAgKiAgdGhlbSBhcyBsYXJnZXIgcGl4ZWxzXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBuYW1lIFBpeGVsYXRlXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxyXG4gICAgICogQGF1dGhvciBpcHBvNjE1XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogbm9kZS5jYWNoZSgpO1xyXG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLlBpeGVsYXRlXSk7XHJcbiAgICAgKiBub2RlLnBpeGVsU2l6ZSgxMCk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GaWx0ZXJzLlBpeGVsYXRlID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xyXG5cclxuICAgICAgICB2YXIgcGl4ZWxTaXplID0gTWF0aC5jZWlsKHRoaXMucGl4ZWxTaXplKCkpLFxyXG4gICAgICAgICAgICB3aWR0aCA9IGltYWdlRGF0YS53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodCxcclxuICAgICAgICAgICAgeCwgeSwgaSxcclxuICAgICAgICAgICAgLy9waXhlbHNQZXJCaW4gPSBwaXhlbFNpemUgKiBwaXhlbFNpemUsXHJcbiAgICAgICAgICAgIHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhLFxyXG4gICAgICAgICAgICBuQmluc1ggPSBNYXRoLmNlaWwod2lkdGggLyBwaXhlbFNpemUpLFxyXG4gICAgICAgICAgICBuQmluc1kgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gcGl4ZWxTaXplKSxcclxuICAgICAgICAgICAgeEJpblN0YXJ0LCB4QmluRW5kLCB5QmluU3RhcnQsIHlCaW5FbmQsXHJcbiAgICAgICAgICAgIHhCaW4sIHlCaW4sIHBpeGVsc0luQmluO1xyXG4gICAgICAgIGltYWdlRGF0YSA9IGltYWdlRGF0YS5kYXRhO1xyXG5cclxuICAgICAgICBmb3IgKHhCaW4gPSAwOyB4QmluIDwgbkJpbnNYOyB4QmluICs9IDEpIHtcclxuICAgICAgICAgICAgZm9yICh5QmluID0gMDsgeUJpbiA8IG5CaW5zWTsgeUJpbiArPSAxKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgY29sb3IgYWNjdW1sYXRvcnMgdG8gMFxyXG4gICAgICAgICAgICAgICAgcmVkID0gMDtcclxuICAgICAgICAgICAgICAgIGdyZWVuID0gMDtcclxuICAgICAgICAgICAgICAgIGJsdWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgYWxwaGEgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSB3aGljaCBwaXhlbHMgYXJlIGluY2x1ZGVkIGluIHRoaXMgYmluXHJcbiAgICAgICAgICAgICAgICB4QmluU3RhcnQgPSB4QmluICogcGl4ZWxTaXplO1xyXG4gICAgICAgICAgICAgICAgeEJpbkVuZCA9IHhCaW5TdGFydCArIHBpeGVsU2l6ZTtcclxuICAgICAgICAgICAgICAgIHlCaW5TdGFydCA9IHlCaW4gKiBwaXhlbFNpemU7XHJcbiAgICAgICAgICAgICAgICB5QmluRW5kID0geUJpblN0YXJ0ICsgcGl4ZWxTaXplO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCBhbGwgb2YgdGhlIHBpeGVscyB0byB0aGlzIGJpbiFcclxuICAgICAgICAgICAgICAgIHBpeGVsc0luQmluID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoeCA9IHhCaW5TdGFydDsgeCA8IHhCaW5FbmQ7IHggKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCB4ID49IHdpZHRoICl7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh5ID0geUJpblN0YXJ0OyB5IDwgeUJpbkVuZDsgeSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCB5ID49IGhlaWdodCApeyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gKHdpZHRoICogeSArIHgpICogNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVkICs9IGltYWdlRGF0YVtpICsgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyZWVuICs9IGltYWdlRGF0YVtpICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsdWUgKz0gaW1hZ2VEYXRhW2kgKyAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEgKz0gaW1hZ2VEYXRhW2kgKyAzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxzSW5CaW4gKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBjaGFubmVscyBhcmUgYmV0d2VlbiAwLTI1NVxyXG4gICAgICAgICAgICAgICAgcmVkID0gcmVkIC8gcGl4ZWxzSW5CaW47XHJcbiAgICAgICAgICAgICAgICBncmVlbiA9IGdyZWVuIC8gcGl4ZWxzSW5CaW47XHJcbiAgICAgICAgICAgICAgICBibHVlID0gYmx1ZSAvIHBpeGVsc0luQmluO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERyYXcgdGhpcyBiaW5cclxuICAgICAgICAgICAgICAgIGZvciAoeCA9IHhCaW5TdGFydDsgeCA8IHhCaW5FbmQ7IHggKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCB4ID49IHdpZHRoICl7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh5ID0geUJpblN0YXJ0OyB5IDwgeUJpbkVuZDsgeSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCB5ID49IGhlaWdodCApeyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gKHdpZHRoICogeSArIHgpICogNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhW2kgKyAwXSA9IHJlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhW2kgKyAxXSA9IGdyZWVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGFbaSArIDJdID0gYmx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhW2kgKyAzXSA9IGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdwaXhlbFNpemUnLCA4LCBudWxsLCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcclxuXHJcbiAgICAvKipcclxuICAgICogZ2V0L3NldCBwaXhlbCBzaXplLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5QaXhlbGF0ZX0gZmlsdGVyLlxyXG4gICAgKiBAbmFtZSBwaXhlbFNpemVcclxuICAgICogQG1ldGhvZFxyXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICogQHBhcmFtIHtJbnRlZ2VyfSBwaXhlbFNpemVcclxuICAgICogQHJldHVybnMge0ludGVnZXJ9XHJcbiAgICAqL1xyXG59KSgpO1xyXG5cbihmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICAvKipcclxuICAgICAqIFRocmVzaG9sZCBGaWx0ZXIuIFB1c2hlcyBhbnkgdmFsdWUgYWJvdmUgdGhlIG1pZCBwb2ludCB0b1xyXG4gICAgICogIHRoZSBtYXggYW5kIGFueSB2YWx1ZSBiZWxvdyB0aGUgbWlkIHBvaW50IHRvIHRoZSBtaW4uXHJcbiAgICAgKiAgVGhpcyBhZmZlY3RzIHRoZSBhbHBoYSBjaGFubmVsLlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAbmFtZSBUaHJlc2hvbGRcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXHJcbiAgICAgKiBAYXV0aG9yIGlwcG82MTVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBub2RlLmNhY2hlKCk7XHJcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuVGhyZXNob2xkXSk7XHJcbiAgICAgKiBub2RlLnRocmVzaG9sZCgwLjEpO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmlsdGVycy5UaHJlc2hvbGQgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy50aHJlc2hvbGQoKSAqIDI1NSxcclxuICAgICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxyXG4gICAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aCxcclxuICAgICAgICAgICAgaTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGRhdGFbaV0gPSBkYXRhW2ldIDwgbGV2ZWwgPyAwIDogMjU1O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3RocmVzaG9sZCcsIDAuNSwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIGdldC9zZXQgdGhyZXNob2xkLiAgTXVzdCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuVGhyZXNob2xkfSBvciB7QGxpbmsgS29udmEuRmlsdGVycy5NYXNrfSBmaWx0ZXIuXHJcbiAgICAqIEBuYW1lIHRocmVzaG9sZFxyXG4gICAgKiBAbWV0aG9kXHJcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgKiBAcGFyYW0ge051bWJlcn0gdGhyZXNob2xkXHJcbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAqL1xyXG59KSgpO1xyXG5cbihmdW5jdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8qKlxyXG4gICAgICogU2VwaWEgRmlsdGVyXHJcbiAgICAgKiBCYXNlZCBvbjogUGl4YXN0aWMgTGliIC0gU2VwaWEgZmlsdGVyIC0gdjAuMS4wXHJcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMDggSmFjb2IgU2VpZGVsaW4sIGpzZWlkZWxpbkBuaWhpbG9naWMuZGssIGh0dHA6Ly9ibG9nLm5paGlsb2dpYy5kay9cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQG5hbWUgU2VwaWFcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXHJcbiAgICAgKiBAYXV0aG9yIEphY29iIFNlaWRlbGluIDxqc2VpZGVsaW5AbmloaWxvZ2ljLmRrPlxyXG4gICAgICogQGxpY2Vuc2UgTVBMIHYxLjEgW2h0dHA6Ly93d3cucGl4YXN0aWMuY29tL2xpYi9saWNlbnNlLnR4dF1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBub2RlLmNhY2hlKCk7XHJcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuU2VwaWFdKTtcclxuICAgICAqL1xyXG4gICAgS29udmEuRmlsdGVycy5TZXBpYSA9IGZ1bmN0aW9uIChpbWFnZURhdGEpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxyXG4gICAgICAgICAgICB3ID0gaW1hZ2VEYXRhLndpZHRoLFxyXG4gICAgICAgICAgICB5ID0gaW1hZ2VEYXRhLmhlaWdodCxcclxuICAgICAgICAgICAgdzQgPSB3ICogNCxcclxuICAgICAgICAgICAgb2Zmc2V0WSwgeCwgb2Zmc2V0LCBvciwgb2csIG9iLCByLCBnLCBiO1xyXG5cclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIG9mZnNldFkgPSAoeSAtIDEpICogdzQ7XHJcbiAgICAgICAgICAgIHggPSB3O1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBvZmZzZXRZICsgKHggLSAxKSAqIDQ7XHJcblxyXG4gICAgICAgICAgICAgICAgb3IgPSBkYXRhW29mZnNldF07XHJcbiAgICAgICAgICAgICAgICBvZyA9IGRhdGFbb2Zmc2V0ICsgMV07XHJcbiAgICAgICAgICAgICAgICBvYiA9IGRhdGFbb2Zmc2V0ICsgMl07XHJcblxyXG4gICAgICAgICAgICAgICAgciA9IG9yICogMC4zOTMgKyBvZyAqIDAuNzY5ICsgb2IgKiAwLjE4OTtcclxuICAgICAgICAgICAgICAgIGcgPSBvciAqIDAuMzQ5ICsgb2cgKiAwLjY4NiArIG9iICogMC4xNjg7XHJcbiAgICAgICAgICAgICAgICBiID0gb3IgKiAwLjI3MiArIG9nICogMC41MzQgKyBvYiAqIDAuMTMxO1xyXG5cclxuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IHIgPiAyNTUgPyAyNTUgOiByO1xyXG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAxXSA9IGcgPiAyNTUgPyAyNTUgOiBnO1xyXG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAyXSA9IGIgPiAyNTUgPyAyNTUgOiBiO1xyXG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAzXSA9IGRhdGFbb2Zmc2V0ICsgM107XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKC0teCk7XHJcbiAgICAgICAgfSB3aGlsZSAoLS15KTtcclxuICAgIH07XHJcbn0pKCk7XHJcblxuKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8qKlxyXG4gICAgICogU29sYXJpemUgRmlsdGVyXHJcbiAgICAgKiBQaXhhc3RpYyBMaWIgLSBTb2xhcml6ZSBmaWx0ZXIgLSB2MC4xLjBcclxuICAgICAqIENvcHlyaWdodCAoYykgMjAwOCBKYWNvYiBTZWlkZWxpbiwganNlaWRlbGluQG5paGlsb2dpYy5kaywgaHR0cDovL2Jsb2cubmloaWxvZ2ljLmRrL1xyXG4gICAgICogTGljZW5zZTogW2h0dHA6Ly93d3cucGl4YXN0aWMuY29tL2xpYi9saWNlbnNlLnR4dF1cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQG5hbWUgU29sYXJpemVcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogbm9kZS5jYWNoZSgpO1xyXG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLlNvbGFyaXplXSk7XHJcbiAgICAgKi9cclxuICAgIEtvbnZhLkZpbHRlcnMuU29sYXJpemUgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcclxuICAgICAgICAgICAgdyA9IGltYWdlRGF0YS53aWR0aCxcclxuICAgICAgICAgICAgaCA9IGltYWdlRGF0YS5oZWlnaHQsXHJcbiAgICAgICAgICAgIHc0ID0gdyAqIDQsXHJcbiAgICAgICAgICAgIHkgPSBoO1xyXG5cclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXRZID0gKHkgLSAxKSAqIHc0O1xyXG4gICAgICAgICAgICB2YXIgeCA9IHc7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBvZmZzZXRZICsgKHggLSAxKSAqIDQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgciA9IGRhdGFbb2Zmc2V0XTtcclxuICAgICAgICAgICAgICAgIHZhciBnID0gZGF0YVtvZmZzZXQgKyAxXTtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gZGF0YVtvZmZzZXQgKyAyXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAociA+IDEyNykge1xyXG4gICAgICAgICAgICAgICAgICAgIHIgPSAyNTUgLSByO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGcgPiAxMjcpIHtcclxuICAgICAgICAgICAgICAgICAgICBnID0gMjU1IC0gZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChiID4gMTI3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IDI1NSAtIGI7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gcjtcclxuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgMV0gPSBnO1xyXG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAyXSA9IGI7XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKC0teCk7XHJcbiAgICAgICAgfSB3aGlsZSAoLS15KTtcclxuICAgIH07XHJcbn0pKCk7XHJcblxyXG5cclxuXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAvKlxyXG4gICAqIFRvUG9sYXIgRmlsdGVyLiBDb252ZXJ0cyBpbWFnZSBkYXRhIHRvIHBvbGFyIGNvb3JkaW5hdGVzLiBQZXJmb3Jtc1xyXG4gICAqICB3KmgqNCBwaXhlbCByZWFkcyBhbmQgdypoIHBpeGVsIHdyaXRlcy4gVGhlIHIgYXhpcyBpcyBwbGFjZWQgYWxvbmdcclxuICAgKiAgd2hhdCB3b3VsZCBiZSB0aGUgeSBheGlzIGFuZCB0aGUgdGhldGEgYXhpcyBhbG9uZyB0aGUgeCBheGlzLlxyXG4gICAqIEBmdW5jdGlvblxyXG4gICAqIEBhdXRob3IgaXBwbzYxNVxyXG4gICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXHJcbiAgICogQHBhcmFtIHtJbWFnZURhdGF9IHNyYywgdGhlIHNvdXJjZSBpbWFnZSBkYXRhICh3aGF0IHdpbGwgYmUgdHJhbnNmb3JtZWQpXHJcbiAgICogQHBhcmFtIHtJbWFnZURhdGF9IGRzdCwgdGhlIGRlc3RpbmF0aW9uIGltYWdlIGRhdGEgKHdoZXJlIGl0IHdpbGwgYmUgc2F2ZWQpXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdFxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0LnBvbGFyQ2VudGVyWF0gaG9yaXpvbnRhbCBsb2NhdGlvbiBmb3IgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlLFxyXG4gICAqICBkZWZhdWx0IGlzIGluIHRoZSBtaWRkbGVcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdC5wb2xhckNlbnRlclldIHZlcnRpY2FsIGxvY2F0aW9uIGZvciB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUsXHJcbiAgICogIGRlZmF1bHQgaXMgaW4gdGhlIG1pZGRsZVxyXG4gICAqL1xyXG5cclxuICAgIHZhciBUb1BvbGFyID0gZnVuY3Rpb24oc3JjLCBkc3QsIG9wdCl7XHJcblxyXG4gICAgICAgIHZhciBzcmNQaXhlbHMgPSBzcmMuZGF0YSxcclxuICAgICAgICAgICAgZHN0UGl4ZWxzID0gZHN0LmRhdGEsXHJcbiAgICAgICAgICAgIHhTaXplID0gc3JjLndpZHRoLFxyXG4gICAgICAgICAgICB5U2l6ZSA9IHNyYy5oZWlnaHQsXHJcbiAgICAgICAgICAgIHhNaWQgPSBvcHQucG9sYXJDZW50ZXJYIHx8IHhTaXplIC8gMixcclxuICAgICAgICAgICAgeU1pZCA9IG9wdC5wb2xhckNlbnRlclkgfHwgeVNpemUgLyAyLFxyXG4gICAgICAgICAgICBpLCB4LCB5LCByID0gMCwgZyA9IDAsIGIgPSAwLCBhID0gMDtcclxuXHJcbiAgICAgICAgLy8gRmluZCB0aGUgbGFyZ2VzdCByYWRpdXNcclxuICAgICAgICB2YXIgcmFkLCByTWF4ID0gTWF0aC5zcXJ0KCB4TWlkICogeE1pZCArIHlNaWQgKiB5TWlkICk7XHJcbiAgICAgICAgeCA9IHhTaXplIC0geE1pZDtcclxuICAgICAgICB5ID0geVNpemUgLSB5TWlkO1xyXG4gICAgICAgIHJhZCA9IE1hdGguc3FydCggeCAqIHggKyB5ICogeSApO1xyXG4gICAgICAgIHJNYXggPSAocmFkID4gck1heCkgPyByYWQgOiByTWF4O1xyXG5cclxuICAgICAgICAvLyBXZSdsbCBiZSB1aXNuZyB5IGFzIHRoZSByYWRpdXMsIGFuZCB4IGFzIHRoZSBhbmdsZSAodGhldGE9dClcclxuICAgICAgICB2YXIgclNpemUgPSB5U2l6ZSxcclxuICAgICAgICAgICAgdFNpemUgPSB4U2l6ZSxcclxuICAgICAgICAgICAgcmFkaXVzLCB0aGV0YTtcclxuXHJcbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb3ZlciBhbGwgYW5nbGVzICgwLTM2MCkgYW5kIHdlIG5lZWQgdG8gY29udmVydCB0b1xyXG4gICAgICAgIC8vIHJhZGlhbnMgKCpQSS8xODApXHJcbiAgICAgICAgdmFyIGNvbnZlcnNpb24gPSAzNjAgLyB0U2l6ZSAqIE1hdGguUEkgLyAxODAsIHNpbiwgY29zO1xyXG5cclxuICAgICAgICAvLyB2YXIgeDEsIHgyLCB4MWksIHgyaSwgeTEsIHkyLCB5MWksIHkyaSwgc2NhbGU7XHJcblxyXG4gICAgICAgIGZvciggdGhldGEgPSAwOyB0aGV0YSA8IHRTaXplOyB0aGV0YSArPSAxICl7XHJcbiAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKHRoZXRhICogY29udmVyc2lvbik7XHJcbiAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKHRoZXRhICogY29udmVyc2lvbik7XHJcbiAgICAgICAgICAgIGZvciggcmFkaXVzID0gMDsgcmFkaXVzIDwgclNpemU7IHJhZGl1cyArPSAxICl7XHJcbiAgICAgICAgICAgICAgICB4ID0gTWF0aC5mbG9vcih4TWlkICsgck1heCAqIHJhZGl1cyAvIHJTaXplICogY29zKTtcclxuICAgICAgICAgICAgICAgIHkgPSBNYXRoLmZsb29yKHlNaWQgKyByTWF4ICogcmFkaXVzIC8gclNpemUgKiBzaW4pO1xyXG4gICAgICAgICAgICAgICAgaSA9ICh5ICogeFNpemUgKyB4KSAqIDQ7XHJcbiAgICAgICAgICAgICAgICByID0gc3JjUGl4ZWxzW2kgKyAwXTtcclxuICAgICAgICAgICAgICAgIGcgPSBzcmNQaXhlbHNbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgYiA9IHNyY1BpeGVsc1tpICsgMl07XHJcbiAgICAgICAgICAgICAgICBhID0gc3JjUGl4ZWxzW2kgKyAzXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBpdFxyXG4gICAgICAgICAgICAgICAgLy9pID0gKHRoZXRhICogeFNpemUgICsgIHJhZGl1cykgKiA0O1xyXG4gICAgICAgICAgICAgICAgaSA9ICh0aGV0YSArIHJhZGl1cyAqIHhTaXplKSAqIDQ7XHJcbiAgICAgICAgICAgICAgICBkc3RQaXhlbHNbaSArIDBdID0gcjtcclxuICAgICAgICAgICAgICAgIGRzdFBpeGVsc1tpICsgMV0gPSBnO1xyXG4gICAgICAgICAgICAgICAgZHN0UGl4ZWxzW2kgKyAyXSA9IGI7XHJcbiAgICAgICAgICAgICAgICBkc3RQaXhlbHNbaSArIDNdID0gYTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qXHJcbiAgICAgKiBGcm9tUG9sYXIgRmlsdGVyLiBDb252ZXJ0cyBpbWFnZSBkYXRhIGZyb20gcG9sYXIgY29vcmRpbmF0ZXMgYmFjayB0byByZWN0YW5ndWxhci5cclxuICAgICAqICBQZXJmb3JtcyB3KmgqNCBwaXhlbCByZWFkcyBhbmQgdypoIHBpeGVsIHdyaXRlcy5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQGF1dGhvciBpcHBvNjE1XHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xyXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IHNyYywgdGhlIHNvdXJjZSBpbWFnZSBkYXRhICh3aGF0IHdpbGwgYmUgdHJhbnNmb3JtZWQpXHJcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gZHN0LCB0aGUgZGVzdGluYXRpb24gaW1hZ2UgZGF0YSAod2hlcmUgaXQgd2lsbCBiZSBzYXZlZClcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0LnBvbGFyQ2VudGVyWF0gaG9yaXpvbnRhbCBsb2NhdGlvbiBmb3IgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlLFxyXG4gICAgICogIGRlZmF1bHQgaXMgaW4gdGhlIG1pZGRsZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHQucG9sYXJDZW50ZXJZXSB2ZXJ0aWNhbCBsb2NhdGlvbiBmb3IgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlLFxyXG4gICAgICogIGRlZmF1bHQgaXMgaW4gdGhlIG1pZGRsZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHQucG9sYXJSb3RhdGlvbl0gYW1vdW50IHRvIHJvdGF0ZSB0aGUgaW1hZ2UgY291bnRlcmNsb2Nrd2lzLFxyXG4gICAgICogIDAgaXMgbm8gcm90YXRpb24sIDM2MCBkZWdyZWVzIGlzIGEgZnVsbCByb3RhdGlvblxyXG4gICAgICovXHJcblxyXG4gICAgdmFyIEZyb21Qb2xhciA9IGZ1bmN0aW9uKHNyYywgZHN0LCBvcHQpe1xyXG5cclxuICAgICAgICB2YXIgc3JjUGl4ZWxzID0gc3JjLmRhdGEsXHJcbiAgICAgICAgICAgIGRzdFBpeGVscyA9IGRzdC5kYXRhLFxyXG4gICAgICAgICAgICB4U2l6ZSA9IHNyYy53aWR0aCxcclxuICAgICAgICAgICAgeVNpemUgPSBzcmMuaGVpZ2h0LFxyXG4gICAgICAgICAgICB4TWlkID0gb3B0LnBvbGFyQ2VudGVyWCB8fCB4U2l6ZSAvIDIsXHJcbiAgICAgICAgICAgIHlNaWQgPSBvcHQucG9sYXJDZW50ZXJZIHx8IHlTaXplIC8gMixcclxuICAgICAgICAgICAgaSwgeCwgeSwgZHgsIGR5LCByID0gMCwgZyA9IDAsIGIgPSAwLCBhID0gMDtcclxuXHJcblxyXG4gICAgICAgIC8vIEZpbmQgdGhlIGxhcmdlc3QgcmFkaXVzXHJcbiAgICAgICAgdmFyIHJhZCwgck1heCA9IE1hdGguc3FydCggeE1pZCAqIHhNaWQgKyB5TWlkICogeU1pZCApO1xyXG4gICAgICAgIHggPSB4U2l6ZSAtIHhNaWQ7XHJcbiAgICAgICAgeSA9IHlTaXplIC0geU1pZDtcclxuICAgICAgICByYWQgPSBNYXRoLnNxcnQoIHggKiB4ICsgeSAqIHkgKTtcclxuICAgICAgICByTWF4ID0gKHJhZCA+IHJNYXgpID8gcmFkIDogck1heDtcclxuXHJcbiAgICAgICAgLy8gV2UnbGwgYmUgdWlzbmcgeCBhcyB0aGUgcmFkaXVzLCBhbmQgeSBhcyB0aGUgYW5nbGUgKHRoZXRhPXQpXHJcbiAgICAgICAgdmFyIHJTaXplID0geVNpemUsXHJcbiAgICAgICAgdFNpemUgPSB4U2l6ZSxcclxuICAgICAgICByYWRpdXMsIHRoZXRhLFxyXG4gICAgICAgIHBoYXNlU2hpZnQgPSBvcHQucG9sYXJSb3RhdGlvbiB8fCAwO1xyXG5cclxuICAgICAgICAvLyBXZSBuZWVkIHRvIGNvbnZlcnQgdG8gZGVncmVlcyBhbmQgd2UgbmVlZCB0byBtYWtlIHN1cmVcclxuICAgICAgICAvLyBpdCdzIGJldHdlZW4gKDAtMzYwKVxyXG4gICAgICAgIC8vIHZhciBjb252ZXJzaW9uID0gdFNpemUvMzYwKjE4MC9NYXRoLlBJO1xyXG4gICAgICAgIC8vdmFyIGNvbnZlcnNpb24gPSB0U2l6ZS8zNjAqMTgwL01hdGguUEk7XHJcblxyXG4gICAgICAgIHZhciB4MSwgeTE7XHJcblxyXG4gICAgICAgIGZvciggeCA9IDA7IHggPCB4U2l6ZTsgeCArPSAxICl7XHJcbiAgICAgICAgICAgIGZvciggeSA9IDA7IHkgPCB5U2l6ZTsgeSArPSAxICl7XHJcbiAgICAgICAgICAgICAgICBkeCA9IHggLSB4TWlkO1xyXG4gICAgICAgICAgICAgICAgZHkgPSB5IC0geU1pZDtcclxuICAgICAgICAgICAgICAgIHJhZGl1cyA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkgKiByU2l6ZSAvIHJNYXg7XHJcbiAgICAgICAgICAgICAgICB0aGV0YSA9IChNYXRoLmF0YW4yKGR5LCBkeCkgKiAxODAgLyBNYXRoLlBJICsgMzYwICsgcGhhc2VTaGlmdCkgJSAzNjA7XHJcbiAgICAgICAgICAgICAgICB0aGV0YSA9IHRoZXRhICogdFNpemUgLyAzNjA7XHJcbiAgICAgICAgICAgICAgICB4MSA9IE1hdGguZmxvb3IodGhldGEpO1xyXG4gICAgICAgICAgICAgICAgeTEgPSBNYXRoLmZsb29yKHJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICBpID0gKHkxICogeFNpemUgKyB4MSkgKiA0O1xyXG4gICAgICAgICAgICAgICAgciA9IHNyY1BpeGVsc1tpICsgMF07XHJcbiAgICAgICAgICAgICAgICBnID0gc3JjUGl4ZWxzW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIGIgPSBzcmNQaXhlbHNbaSArIDJdO1xyXG4gICAgICAgICAgICAgICAgYSA9IHNyY1BpeGVsc1tpICsgM107XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgaXRcclxuICAgICAgICAgICAgICAgIGkgPSAoeSAqIHhTaXplICsgeCkgKiA0O1xyXG4gICAgICAgICAgICAgICAgZHN0UGl4ZWxzW2kgKyAwXSA9IHI7XHJcbiAgICAgICAgICAgICAgICBkc3RQaXhlbHNbaSArIDFdID0gZztcclxuICAgICAgICAgICAgICAgIGRzdFBpeGVsc1tpICsgMl0gPSBiO1xyXG4gICAgICAgICAgICAgICAgZHN0UGl4ZWxzW2kgKyAzXSA9IGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvL0tvbnZhLkZpbHRlcnMuVG9Qb2xhciA9IEtvbnZhLlV0aWwuX0ZpbHRlcldyYXBEb3VibGVCdWZmZXIoVG9Qb2xhcik7XHJcbiAgICAvL0tvbnZhLkZpbHRlcnMuRnJvbVBvbGFyID0gS29udmEuVXRpbC5fRmlsdGVyV3JhcERvdWJsZUJ1ZmZlcihGcm9tUG9sYXIpO1xyXG5cclxuICAgIC8vIGNyZWF0ZSBhIHRlbXBvcmFyeSBjYW52YXMgZm9yIHdvcmtpbmcgLSBzaGFyZWQgYmV0d2VlbiBtdWx0aXBsZSBjYWxsc1xyXG4gICAgdmFyIHRlbXBDYW52YXMgPSBLb252YS5VdGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcclxuXHJcbiAgICAvKlxyXG4gICAgICogS2FsZWlkb3Njb3BlIEZpbHRlci5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQG5hbWUgS2FsZWlkb3Njb3BlXHJcbiAgICAgKiBAYXV0aG9yIGlwcG82MTVcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogbm9kZS5jYWNoZSgpO1xyXG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkthbGVpZG9zY29wZV0pO1xyXG4gICAgICogbm9kZS5rYWxlaWRvc2NvcGVQb3dlcigzKTtcclxuICAgICAqIG5vZGUua2FsZWlkb3Njb3BlQW5nbGUoNDUpO1xyXG4gICAgICovXHJcbiAgICBLb252YS5GaWx0ZXJzLkthbGVpZG9zY29wZSA9IGZ1bmN0aW9uKGltYWdlRGF0YSl7XHJcbiAgICAgICAgdmFyIHhTaXplID0gaW1hZ2VEYXRhLndpZHRoLFxyXG4gICAgICAgICAgICB5U2l6ZSA9IGltYWdlRGF0YS5oZWlnaHQ7XHJcblxyXG4gICAgICAgIHZhciB4LCB5LCB4b2ZmLCBpLCByLCBnLCBiLCBhLCBzcmNQb3MsIGRzdFBvcztcclxuICAgICAgICB2YXIgcG93ZXIgPSBNYXRoLnJvdW5kKCB0aGlzLmthbGVpZG9zY29wZVBvd2VyKCkgKTtcclxuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLnJvdW5kKCB0aGlzLmthbGVpZG9zY29wZUFuZ2xlKCkgKTtcclxuICAgICAgICB2YXIgb2Zmc2V0ID0gTWF0aC5mbG9vcih4U2l6ZSAqIChhbmdsZSAlIDM2MCkgLyAzNjApO1xyXG5cclxuICAgICAgICBpZiggcG93ZXIgPCAxICl7cmV0dXJuOyB9XHJcblxyXG4gICAgICAgIC8vIFdvcmsgd2l0aCBvdXIgc2hhcmVkIGJ1ZmZlciBjYW52YXNcclxuICAgICAgICB0ZW1wQ2FudmFzLndpZHRoID0geFNpemU7XHJcbiAgICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSB5U2l6ZTtcclxuICAgICAgICB2YXIgc2NyYXRjaERhdGEgPSB0ZW1wQ2FudmFzLmdldENvbnRleHQoJzJkJykuZ2V0SW1hZ2VEYXRhKDAsIDAsIHhTaXplLCB5U2l6ZSk7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgdGhoZSBvcmlnaW5hbCB0byBwb2xhciBjb29yZGluYXRlc1xyXG4gICAgICAgIFRvUG9sYXIoIGltYWdlRGF0YSwgc2NyYXRjaERhdGEsIHtcclxuICAgICAgICAgICAgcG9sYXJDZW50ZXJYOiB4U2l6ZSAvIDIsXHJcbiAgICAgICAgICAgIHBvbGFyQ2VudGVyWTogeVNpemUgLyAyXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSBob3cgYmlnIGVhY2ggc2VjdGlvbiB3aWxsIGJlLCBpZiBpdCdzIHRvbyBzbWFsbFxyXG4gICAgICAgIC8vIG1ha2UgaXQgYmlnZ2VyXHJcbiAgICAgICAgdmFyIG1pblNlY3Rpb25TaXplID0geFNpemUgLyBNYXRoLnBvdygyLCBwb3dlcik7XHJcbiAgICAgICAgd2hpbGUoIG1pblNlY3Rpb25TaXplIDw9IDgpe1xyXG4gICAgICAgICAgICBtaW5TZWN0aW9uU2l6ZSA9IG1pblNlY3Rpb25TaXplICogMjtcclxuICAgICAgICAgICAgcG93ZXIgLT0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWluU2VjdGlvblNpemUgPSBNYXRoLmNlaWwobWluU2VjdGlvblNpemUpO1xyXG4gICAgICAgIHZhciBzZWN0aW9uU2l6ZSA9IG1pblNlY3Rpb25TaXplO1xyXG5cclxuICAgICAgICAvLyBDb3B5IHRoZSBvZmZzZXQgcmVnaW9uIHRvIDBcclxuICAgICAgICAvLyBEZXBlbmRpbmcgb24gdGhlIHNpemUgb2YgZmlsdGVyIGFuZCBsb2NhdGlvbiBvZiB0aGUgb2Zmc2V0IHdlIG1heSBuZWVkXHJcbiAgICAgICAgLy8gdG8gY29weSB0aGUgc2VjdGlvbiBiYWNrd2FyZHMgdG8gcHJldmVudCBpdCBmcm9tIHJld3JpdGluZyBpdHNlbGZcclxuICAgICAgICB2YXIgeFN0YXJ0ID0gMCxcclxuICAgICAgICAgIHhFbmQgPSBzZWN0aW9uU2l6ZSxcclxuICAgICAgICAgIHhEZWx0YSA9IDE7XHJcbiAgICAgICAgaWYoIG9mZnNldCArIG1pblNlY3Rpb25TaXplID4geFNpemUgKXtcclxuICAgICAgICAgICAgeFN0YXJ0ID0gc2VjdGlvblNpemU7XHJcbiAgICAgICAgICAgIHhFbmQgPSAwO1xyXG4gICAgICAgICAgICB4RGVsdGEgPSAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yKCB5ID0gMDsgeSA8IHlTaXplOyB5ICs9IDEgKXtcclxuICAgICAgICAgICAgZm9yKCB4ID0geFN0YXJ0OyB4ICE9PSB4RW5kOyB4ICs9IHhEZWx0YSApe1xyXG4gICAgICAgICAgICAgICAgeG9mZiA9IE1hdGgucm91bmQoeCArIG9mZnNldCkgJSB4U2l6ZTtcclxuICAgICAgICAgICAgICAgIHNyY1BvcyA9ICh4U2l6ZSAqIHkgKyB4b2ZmKSAqIDQ7XHJcbiAgICAgICAgICAgICAgICByID0gc2NyYXRjaERhdGEuZGF0YVtzcmNQb3MgKyAwXTtcclxuICAgICAgICAgICAgICAgIGcgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDFdO1xyXG4gICAgICAgICAgICAgICAgYiA9IHNjcmF0Y2hEYXRhLmRhdGFbc3JjUG9zICsgMl07XHJcbiAgICAgICAgICAgICAgICBhID0gc2NyYXRjaERhdGEuZGF0YVtzcmNQb3MgKyAzXTtcclxuICAgICAgICAgICAgICAgIGRzdFBvcyA9ICh4U2l6ZSAqIHkgKyB4KSAqIDQ7XHJcbiAgICAgICAgICAgICAgICBzY3JhdGNoRGF0YS5kYXRhW2RzdFBvcyArIDBdID0gcjtcclxuICAgICAgICAgICAgICAgIHNjcmF0Y2hEYXRhLmRhdGFbZHN0UG9zICsgMV0gPSBnO1xyXG4gICAgICAgICAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAyXSA9IGI7XHJcbiAgICAgICAgICAgICAgICBzY3JhdGNoRGF0YS5kYXRhW2RzdFBvcyArIDNdID0gYTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUGVyZm9ybSB0aGUgYWN0dWFsIGVmZmVjdFxyXG4gICAgICAgIGZvciggeSA9IDA7IHkgPCB5U2l6ZTsgeSArPSAxICl7XHJcbiAgICAgICAgICAgIHNlY3Rpb25TaXplID0gTWF0aC5mbG9vciggbWluU2VjdGlvblNpemUgKTtcclxuICAgICAgICAgICAgZm9yKCBpID0gMDsgaSA8IHBvd2VyOyBpICs9IDEgKXtcclxuICAgICAgICAgICAgICAgIGZvciggeCA9IDA7IHggPCBzZWN0aW9uU2l6ZSArIDE7IHggKz0gMSApe1xyXG4gICAgICAgICAgICAgICAgICAgIHNyY1BvcyA9ICh4U2l6ZSAqIHkgKyB4KSAqIDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgciA9IHNjcmF0Y2hEYXRhLmRhdGFbc3JjUG9zICsgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgZyA9IHNjcmF0Y2hEYXRhLmRhdGFbc3JjUG9zICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IHNjcmF0Y2hEYXRhLmRhdGFbc3JjUG9zICsgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IHNjcmF0Y2hEYXRhLmRhdGFbc3JjUG9zICsgM107XHJcbiAgICAgICAgICAgICAgICAgICAgZHN0UG9zID0gKHhTaXplICogeSArIHNlY3Rpb25TaXplICogMiAtIHggLSAxKSAqIDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAwXSA9IHI7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAxXSA9IGc7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAyXSA9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAzXSA9IGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9uU2l6ZSAqPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IGJhY2sgZnJvbSBwb2xhciBjb29yZGluYXRlc1xyXG4gICAgICAgIEZyb21Qb2xhcihzY3JhdGNoRGF0YSwgaW1hZ2VEYXRhLCB7cG9sYXJSb3RhdGlvbjogMH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICogZ2V0L3NldCBrYWxlaWRvc2NvcGUgcG93ZXIuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkthbGVpZG9zY29wZX0gZmlsdGVyLlxyXG4gICAgKiBAbmFtZSBrYWxlaWRvc2NvcGVQb3dlclxyXG4gICAgKiBAbWV0aG9kXHJcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgKiBAcGFyYW0ge0ludGVnZXJ9IHBvd2VyIG9mIGthbGVpZG9zY29wZVxyXG4gICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cclxuICAgICovXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAna2FsZWlkb3Njb3BlUG93ZXInLCAyLCBudWxsLCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcclxuXHJcbiAgICAvKipcclxuICAgICogZ2V0L3NldCBrYWxlaWRvc2NvcGUgYW5nbGUuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkthbGVpZG9zY29wZX0gZmlsdGVyLlxyXG4gICAgKiBAbmFtZSBrYWxlaWRvc2NvcGVBbmdsZVxyXG4gICAgKiBAbWV0aG9kXHJcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgKiBAcGFyYW0ge0ludGVnZXJ9IGRlZ3JlZXNcclxuICAgICogQHJldHVybnMge0ludGVnZXJ9XHJcbiAgICAqL1xyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2thbGVpZG9zY29wZUFuZ2xlJywgMCwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XHJcblxyXG59KSgpO1xyXG5cbihmdW5jdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICBmdW5jdGlvbiBpc1ZhbGlkU2VsZWN0b3Ioc2VsZWN0b3IpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmaXJzdENoYXIgPSBzZWxlY3RvclswXTtcclxuICAgICAgICByZXR1cm4gZmlyc3RDaGFyID09PSAnIycgfHwgZmlyc3RDaGFyID09PSAnLicgfHwgZmlyc3RDaGFyID09PSBmaXJzdENoYXIudG9VcHBlckNhc2UoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udGFpbmVyIGNvbnN0cnVjdG9yLiZuYnNwOyBDb250YWluZXJzIGFyZSB1c2VkIHRvIGNvbnRhaW4gbm9kZXMgb3Igb3RoZXIgY29udGFpbmVyc1xyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcclxuICAgICAqIEBhdWdtZW50cyBLb252YS5Ob2RlXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXHJcbiAgICAgKiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmNsaXBdIHNldCBjbGlwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFhdIHNldCBjbGlwIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWV0gc2V0IGNsaXAgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBXaWR0aF0gc2V0IGNsaXAgd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwSGVpZ2h0XSBzZXQgY2xpcCBoZWlnaHRcblxyXG4gICAgICovXHJcbiAgICBLb252YS5Db250YWluZXIgPSBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICB0aGlzLl9faW5pdChjb25maWcpO1xyXG4gICAgfTtcclxuXHJcbiAgICBLb252YS5VdGlsLmFkZE1ldGhvZHMoS29udmEuQ29udGFpbmVyLCB7XHJcbiAgICAgICAgX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBLb252YS5Db2xsZWN0aW9uKCk7XHJcbiAgICAgICAgICAgIEtvbnZhLk5vZGUuY2FsbCh0aGlzLCBjb25maWcpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogcmV0dXJucyBhIHtAbGluayBLb252YS5Db2xsZWN0aW9ufSBvZiBkaXJlY3QgZGVzY2VuZGFudCBub2Rlc1xyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtmaWx0ZXJGdW5jXSBmaWx0ZXIgZnVuY3Rpb25cclxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuQ29sbGVjdGlvbn1cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqIC8vIGdldCBhbGwgY2hpbGRyZW5cclxuICAgICAgICAgKiB2YXIgY2hpbGRyZW4gPSBsYXllci5nZXRDaGlsZHJlbigpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogLy8gZ2V0IG9ubHkgY2lyY2xlc1xyXG4gICAgICAgICAqIHZhciBjaXJjbGVzID0gbGF5ZXIuZ2V0Q2hpbGRyZW4oZnVuY3Rpb24obm9kZSl7XHJcbiAgICAgICAgICogICAgcmV0dXJuIG5vZGUuZ2V0Q2xhc3NOYW1lKCkgPT09ICdDaXJjbGUnO1xyXG4gICAgICAgICAqIH0pO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldENoaWxkcmVuOiBmdW5jdGlvbihmaWx0ZXJGdW5jKSB7XHJcbiAgICAgICAgICAgIGlmICghZmlsdGVyRnVuYykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gbmV3IEtvbnZhLkNvbGxlY3Rpb24oKTtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5lYWNoKGZ1bmN0aW9uKGNoaWxkKXtcclxuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJGdW5jKGNoaWxkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGRldGVybWluZSBpZiBub2RlIGhhcyBjaGlsZHJlblxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGhhc0NoaWxkcmVuOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2hpbGRyZW4oKS5sZW5ndGggPiAwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogcmVtb3ZlIGFsbCBjaGlsZHJlblxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlbW92ZUNoaWxkcmVuOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gS29udmEuQ29sbGVjdGlvbi50b0NvbGxlY3Rpb24odGhpcy5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIC8vIHJlc2V0IHBhcmVudCB0byBwcmV2ZW50IG1hbnkgX3NldENoaWxkcmVuSW5kaWNlcyBjYWxsc1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGNoaWxkLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIGNoaWxkLmluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5oYXNDaGlsZHJlbigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQucmVtb3ZlQ2hpbGRyZW4oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNoaWxkLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBLb252YS5Db2xsZWN0aW9uKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogZGVzdHJveSBhbGwgY2hpbGRyZW5cclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBkZXN0cm95Q2hpbGRyZW46IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgIHZhciBjaGlsZHJlbiA9IEtvbnZhLkNvbGxlY3Rpb24udG9Db2xsZWN0aW9uKHRoaXMuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICAvLyByZXNldCBwYXJlbnQgdG8gcHJldmVudCBtYW55IF9zZXRDaGlsZHJlbkluZGljZXMgY2FsbHNcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBjaGlsZC5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5pbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IEtvbnZhLkNvbGxlY3Rpb24oKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGQgbm9kZSBvciBub2RlcyB0byBjb250YWluZXIuXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHsuLi5Lb252YS5Ob2RlfSBjaGlsZFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtDb250YWluZXJ9XHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiBsYXllci5hZGQoc2hhcGUxLCBzaGFwZTIsIHNoYXBlMyk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWRkOiBmdW5jdGlvbihjaGlsZCkge1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoYXJndW1lbnRzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5nZXRQYXJlbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQubW92ZVRvKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcclxuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVBZGQoY2hpbGQpO1xyXG4gICAgICAgICAgICBjaGlsZC5pbmRleCA9IGNoaWxkcmVuLmxlbmd0aDtcclxuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcclxuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpcmUoJ2FkZCcsIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkOiBjaGlsZFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIG5vZGUgdW5kZXIgZHJhZyB3ZSBuZWVkIHRvIHVwZGF0ZSBkcmFnIGFuaW1hdGlvblxyXG4gICAgICAgICAgICBpZiAoS29udmEuREQgJiYgY2hpbGQuaXNEcmFnZ2luZygpKSB7XHJcbiAgICAgICAgICAgICAgICBLb252YS5ERC5hbmltLnNldExheWVycyhjaGlsZC5nZXRMYXllcigpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gY2hhaW5hYmxlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vIGRlc3Ryb3kgY2hpbGRyZW5cclxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzQ2hpbGRyZW4oKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95Q2hpbGRyZW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0aGVuIGRlc3Ryb3kgc2VsZlxyXG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiByZXR1cm4gYSB7QGxpbmsgS29udmEuQ29sbGVjdGlvbn0gb2Ygbm9kZXMgdGhhdCBtYXRjaCB0aGUgc2VsZWN0b3IuICBVc2UgJyMnIGZvciBpZCBzZWxlY3Rpb25zXHJcbiAgICAgICAgICogYW5kICcuJyBmb3IgbmFtZSBzZWxlY3Rpb25zLiAgWW91IGNhbiBhbHNvIHNlbGVjdCBieSB0eXBlIG9yIGNsYXNzIG5hbWUuIFBhc3MgbXVsdGlwbGUgc2VsZWN0b3JzXHJcbiAgICAgICAgICogc2VwYXJhdGVkIGJ5IGEgc3BhY2UuXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXHJcbiAgICAgICAgICogQHJldHVybnMge0NvbGxlY3Rpb259XHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAvLyBzZWxlY3Qgbm9kZSB3aXRoIGlkIGZvb1xyXG4gICAgICAgICAqIHZhciBub2RlID0gc3RhZ2UuZmluZCgnI2ZvbycpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogLy8gc2VsZWN0IG5vZGVzIHdpdGggbmFtZSBiYXIgaW5zaWRlIGxheWVyXHJcbiAgICAgICAgICogdmFyIG5vZGVzID0gbGF5ZXIuZmluZCgnLmJhcicpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogLy8gc2VsZWN0IGFsbCBncm91cHMgaW5zaWRlIGxheWVyXHJcbiAgICAgICAgICogdmFyIG5vZGVzID0gbGF5ZXIuZmluZCgnR3JvdXAnKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIC8vIHNlbGVjdCBhbGwgcmVjdGFuZ2xlcyBpbnNpZGUgbGF5ZXJcclxuICAgICAgICAgKiB2YXIgbm9kZXMgPSBsYXllci5maW5kKCdSZWN0Jyk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAvLyBzZWxlY3Qgbm9kZSB3aXRoIGFuIGlkIG9mIGZvbyBvciBhIG5hbWUgb2YgYmFyIGluc2lkZSBsYXllclxyXG4gICAgICAgICAqIHZhciBub2RlcyA9IGxheWVyLmZpbmQoJyNmb28sIC5iYXInKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBmaW5kOiBmdW5jdGlvbihzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICB2YXIgcmV0QXJyID0gW10sXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RvckFyciA9IHNlbGVjdG9yLnJlcGxhY2UoLyAvZywgJycpLnNwbGl0KCcsJyksXHJcbiAgICAgICAgICAgICAgICBsZW4gPSBzZWxlY3RvckFyci5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBuLCBpLCBzZWwsIGFyciwgbm9kZSwgY2hpbGRyZW4sIGNsZW47XHJcblxyXG4gICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcclxuICAgICAgICAgICAgICAgIHNlbCA9IHNlbGVjdG9yQXJyW25dO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkU2VsZWN0b3Ioc2VsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwud2FybignU2VsZWN0b3IgXCInICsgc2VsICsgJ1wiIGlzIGludmFsaWQuIEFsbG93ZWQgc2VsZWN0b3JzIGV4YW1wbGVzIGFyZSBcIiNmb29cIiwgXCIuYmFyXCIgb3IgXCJHcm91cFwiLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwud2FybignSWYgeW91IGhhdmUgYSBjdXN0b20gc2hhcGUgd2l0aCBzdWNoIGNsYXNzTmFtZSwgcGxlYXNlIGNoYW5nZSBpdCB0byBzdGFydCB3aXRoIHVwcGVyIGxldHRlciBsaWtlIFwiVHJpYW5nbGVcIi4nKTtcclxuICAgICAgICAgICAgICAgICAgICBLb252YS5VdGlsLndhcm4oJ0tvbnZhIGlzIGF3ZXNvbWUsIHJpZ2h0PycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaWQgc2VsZWN0b3JcclxuICAgICAgICAgICAgICAgIGlmKHNlbC5jaGFyQXQoMCkgPT09ICcjJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLl9nZXROb2RlQnlJZChzZWwuc2xpY2UoMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0QXJyLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gbmFtZSBzZWxlY3RvclxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihzZWwuY2hhckF0KDApID09PSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcnIgPSB0aGlzLl9nZXROb2Rlc0J5TmFtZShzZWwuc2xpY2UoMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldEFyciA9IHJldEFyci5jb25jYXQoYXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHVucmVjb2duaXplZCBzZWxlY3RvciwgcGFzcyB0byBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlbiA9IGNoaWxkcmVuLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBjbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0QXJyID0gcmV0QXJyLmNvbmNhdChjaGlsZHJlbltpXS5fZ2V0KHNlbCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIEtvbnZhLkNvbGxlY3Rpb24udG9Db2xsZWN0aW9uKHJldEFycik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiByZXR1cm4gYSBmaXJzdCBub2RlIGZyb20gYGZpbmRgIG1ldGhvZFxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxyXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogLy8gc2VsZWN0IG5vZGUgd2l0aCBpZCBmb29cclxuICAgICAgICAgKiB2YXIgbm9kZSA9IHN0YWdlLmZpbmRPbmUoJyNmb28nKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIC8vIHNlbGVjdCBub2RlIHdpdGggbmFtZSBiYXIgaW5zaWRlIGxheWVyXHJcbiAgICAgICAgICogdmFyIG5vZGVzID0gbGF5ZXIuZmluZE9uZSgnLmJhcicpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZpbmRPbmU6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmQoc2VsZWN0b3IpWzBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldE5vZGVCeUlkOiBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSBLb252YS5pZHNba2V5XTtcclxuXHJcbiAgICAgICAgICAgIGlmKG5vZGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmlzQW5jZXN0b3JPZihub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0Tm9kZXNCeU5hbWU6IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICB2YXIgYXJyID0gS29udmEubmFtZXNba2V5XSB8fCBbXTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldERlc2NlbmRhbnRzKGFycik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0OiBmdW5jdGlvbihzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICB2YXIgcmV0QXJyID0gS29udmEuTm9kZS5wcm90b3R5cGUuX2dldC5jYWxsKHRoaXMsIHNlbGVjdG9yKTtcclxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xyXG4gICAgICAgICAgICB2YXIgbGVuID0gY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IodmFyIG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcclxuICAgICAgICAgICAgICAgIHJldEFyciA9IHJldEFyci5jb25jYXQoY2hpbGRyZW5bbl0uX2dldChzZWxlY3RvcikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXRBcnI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBleHRlbmRlcnNcclxuICAgICAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBvYmogPSBLb252YS5Ob2RlLnByb3RvdHlwZS50b09iamVjdC5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgb2JqLmNoaWxkcmVuID0gW107XHJcblxyXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XHJcbiAgICAgICAgICAgIHZhciBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvcih2YXIgbiA9IDA7IG4gPCBsZW47IG4rKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5bbl07XHJcbiAgICAgICAgICAgICAgICBvYmouY2hpbGRyZW4ucHVzaChjaGlsZC50b09iamVjdCgpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXREZXNjZW5kYW50czogZnVuY3Rpb24oYXJyKSB7XHJcbiAgICAgICAgICAgIHZhciByZXRBcnIgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvcih2YXIgbiA9IDA7IG4gPCBsZW47IG4rKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBhcnJbbl07XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmlzQW5jZXN0b3JPZihub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldEFyci5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmV0QXJyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogZGV0ZXJtaW5lIGlmIG5vZGUgaXMgYW4gYW5jZXN0b3JcclxuICAgICAgICAgKiBvZiBkZXNjZW5kYW50XHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtLb252YS5Ob2RlfSBub2RlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNBbmNlc3Rvck9mOiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xyXG4gICAgICAgICAgICB3aGlsZShwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmKHBhcmVudC5faWQgPT09IHRoaXMuX2lkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBtZXRob2RcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSBLb252YS5Ob2RlLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsIG9iaik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdldENoaWxkcmVuKCkuZWFjaChmdW5jdGlvbihubykge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5hZGQobm8uY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGdldCBhbGwgc2hhcGVzIHRoYXQgaW50ZXJzZWN0IGEgcG9pbnQuICBOb3RlOiBiZWNhdXNlIHRoaXMgbWV0aG9kIG11c3QgY2xlYXIgYSB0ZW1wb3JhcnlcclxuICAgICAgICAgKiBjYW52YXMgYW5kIHJlZHJhdyBldmVyeSBzaGFwZSBpbnNpZGUgdGhlIGNvbnRhaW5lciwgaXQgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3Igc3BlY2lhbCBzaXRhdGlvbnNcclxuICAgICAgICAgKiBiZWNhdXNlIGl0IHBlcmZvcm1zIHZlcnkgcG9vcmx5LiAgUGxlYXNlIHVzZSB0aGUge0BsaW5rIEtvbnZhLlN0YWdlI2dldEludGVyc2VjdGlvbn0gbWV0aG9kIGlmIGF0IGFsbCBwb3NzaWJsZVxyXG4gICAgICAgICAqIGJlY2F1c2UgaXQgcGVyZm9ybXMgbXVjaCBiZXR0ZXJcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9zXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy54XHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy55XHJcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fSBhcnJheSBvZiBzaGFwZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRBbGxJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbihwb3MpIHtcclxuICAgICAgICAgICAgdmFyIGFyciA9IFtdO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5maW5kKCdTaGFwZScpLmVhY2goZnVuY3Rpb24oc2hhcGUpIHtcclxuICAgICAgICAgICAgICAgIGlmKHNoYXBlLmlzVmlzaWJsZSgpICYmIHNoYXBlLmludGVyc2VjdHMocG9zKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKHNoYXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3NldENoaWxkcmVuSW5kaWNlczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZWFjaChmdW5jdGlvbihjaGlsZCwgbikge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQuaW5kZXggPSBuO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRyYXdTY2VuZTogZnVuY3Rpb24oY2FuLCB0b3AsIGNhY2hpbmcpIHtcclxuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpLFxyXG4gICAgICAgICAgICAgICAgY2FudmFzID0gY2FuIHx8IChsYXllciAmJiBsYXllci5nZXRDYW52YXMoKSksXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gY2FudmFzICYmIGNhbnZhcy5nZXRDb250ZXh0KCksXHJcbiAgICAgICAgICAgICAgICBjYWNoZWRDYW52YXMgPSB0aGlzLl9jYWNoZS5jYW52YXMsXHJcbiAgICAgICAgICAgICAgICBjYWNoZWRTY2VuZUNhbnZhcyA9IGNhY2hlZENhbnZhcyAmJiBjYWNoZWRDYW52YXMuc2NlbmU7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc1Zpc2libGUoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoaW5nICYmIGNhY2hlZFNjZW5lQ2FudmFzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuX2FwcGx5VHJhbnNmb3JtKHRoaXMsIGNvbnRleHQsIHRvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhd0NhY2hlZFNjZW5lQ2FudmFzKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhd0NoaWxkcmVuKGNhbnZhcywgJ2RyYXdTY2VuZScsIHRvcCwgZmFsc2UsIGNhY2hpbmcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZHJhd0hpdDogZnVuY3Rpb24oY2FuLCB0b3AsIGNhY2hpbmcpIHtcclxuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpLFxyXG4gICAgICAgICAgICAgICAgY2FudmFzID0gY2FuIHx8IChsYXllciAmJiBsYXllci5oaXRDYW52YXMpLFxyXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgY2FjaGVkQ2FudmFzID0gdGhpcy5fY2FjaGUuY2FudmFzLFxyXG4gICAgICAgICAgICAgICAgY2FjaGVkSGl0Q2FudmFzID0gY2FjaGVkQ2FudmFzICYmIGNhY2hlZENhbnZhcy5oaXQ7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5zaG91bGREcmF3SGl0KGNhbnZhcykpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsYXllcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyLmNsZWFySGl0Q2FjaGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghY2FjaGluZyAmJiBjYWNoZWRIaXRDYW52YXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBsYXllci5fYXBwbHlUcmFuc2Zvcm0odGhpcywgY29udGV4dCwgdG9wKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmF3Q2FjaGVkSGl0Q2FudmFzKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhd0NoaWxkcmVuKGNhbnZhcywgJ2RyYXdIaXQnLCB0b3ApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2RyYXdDaGlsZHJlbjogZnVuY3Rpb24oY2FudmFzLCBkcmF3TWV0aG9kLCB0b3AsIGNhY2hpbmcsIHNraXBCdWZmZXIpIHtcclxuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpLFxyXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgY2xpcFdpZHRoID0gdGhpcy5nZXRDbGlwV2lkdGgoKSxcclxuICAgICAgICAgICAgICAgIGNsaXBIZWlnaHQgPSB0aGlzLmdldENsaXBIZWlnaHQoKSxcclxuICAgICAgICAgICAgICAgIGhhc0NsaXAgPSBjbGlwV2lkdGggJiYgY2xpcEhlaWdodCxcclxuICAgICAgICAgICAgICAgIGNsaXBYLCBjbGlwWTtcclxuXHJcbiAgICAgICAgICAgIGlmIChoYXNDbGlwICYmIGxheWVyKSB7XHJcbiAgICAgICAgICAgICAgICBjbGlwWCA9IHRoaXMuZ2V0Q2xpcFgoKTtcclxuICAgICAgICAgICAgICAgIGNsaXBZID0gdGhpcy5nZXRDbGlwWSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgbGF5ZXIuX2FwcGx5VHJhbnNmb3JtKHRoaXMsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVjdChjbGlwWCwgY2xpcFksIGNsaXBXaWR0aCwgY2xpcEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsaXAoKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVzZXQoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5lYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZFtkcmF3TWV0aG9kXShjYW52YXMsIHRvcCwgY2FjaGluZywgc2tpcEJ1ZmZlcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGhhc0NsaXApIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaG91bGREcmF3SGl0OiBmdW5jdGlvbihjYW52YXMpIHtcclxuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xyXG4gICAgICAgICAgICB2YXIgZGQgPSBLb252YS5ERDtcclxuICAgICAgICAgICAgdmFyIGxheWVyVW5kZXJEcmFnID0gZGQgJiYgS29udmEuaXNEcmFnZ2luZygpICYmIChLb252YS5ERC5hbmltLmdldExheWVycygpLmluZGV4T2YobGF5ZXIpICE9PSAtMSk7XHJcbiAgICAgICAgICAgIHJldHVybiAoY2FudmFzICYmIGNhbnZhcy5pc0NhY2hlKSB8fCAobGF5ZXIgJiYgbGF5ZXIuaGl0R3JhcGhFbmFibGVkKCkpXHJcbiAgICAgICAgICAgICAgICAmJiB0aGlzLmlzVmlzaWJsZSgpICYmICFsYXllclVuZGVyRHJhZztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldENsaWVudFJlY3Q6IGZ1bmN0aW9uKHNraXBUcmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFk7XHJcbiAgICAgICAgICAgIHZhciBzZWxmUmVjdCA9IHtcclxuICAgICAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5lYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGNoaWxkLmdldENsaWVudFJlY3QoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBza2lwIGludmlzaWJsZSBjaGlsZHJlbiAobGlrZSBlbXB0eSBncm91cHMpXHJcbiAgICAgICAgICAgICAgICAvLyBvciBkb24ndCBza2lwLi4uIGhtbW0uLi5cclxuICAgICAgICAgICAgICAgIC8vIGlmIChyZWN0LndpZHRoID09PSAwICYmIHJlY3QuaGVpZ2h0ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtaW5YID09PSB1bmRlZmluZWQpIHsgLy8gaW5pdGlhbCB2YWx1ZSBmb3IgZmlyc3QgY2hpbGRcclxuICAgICAgICAgICAgICAgICAgICBtaW5YID0gcmVjdC54O1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblkgPSByZWN0Lnk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IHJlY3QueCArIHJlY3Qud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4WSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgcmVjdC54KTtcclxuICAgICAgICAgICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgcmVjdC55KTtcclxuICAgICAgICAgICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgcmVjdC54ICsgcmVjdC53aWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmUmVjdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBtaW5YLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IG1pblksXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG1heFggLSBtaW5YLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogbWF4WSAtIG1pbllcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghc2tpcFRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybWVkUmVjdChzZWxmUmVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNlbGZSZWN0O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkNvbnRhaW5lciwgS29udmEuTm9kZSk7XHJcbiAgICAvLyBkZXByZWNhdGVkIG1ldGhvZHNcclxuICAgIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUuZ2V0ID0gS29udmEuQ29udGFpbmVyLnByb3RvdHlwZS5maW5kO1xyXG5cclxuICAgIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5Db250YWluZXIsICdjbGlwJywgWyd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0J10pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IGNsaXBcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBuYW1lIGNsaXBcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2xpcFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNsaXAueFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNsaXAueVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNsaXAud2lkdGhcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjbGlwLmhlaWdodFxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgY2xpcFxyXG4gICAgICogdmFyIGNsaXAgPSBjb250YWluZXIuY2xpcCgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBjbGlwXHJcbiAgICAgKiBjb250YWluZXIuc2V0Q2xpcCh7XHJcbiAgICAgKiAgIHg6IDIwLFxyXG4gICAgICogICB5OiAyMCxcclxuICAgICAqICAgd2lkdGg6IDIwLFxyXG4gICAgICogICBoZWlnaHQ6IDIwXHJcbiAgICAgKiB9KTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkNvbnRhaW5lciwgJ2NsaXBYJyk7XHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgY2xpcCB4XHJcbiAgICAgKiBAbmFtZSBjbGlwWFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBjbGlwIHhcclxuICAgICAqIHZhciBjbGlwWCA9IGNvbnRhaW5lci5jbGlwWCgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBjbGlwIHhcclxuICAgICAqIGNvbnRhaW5lci5jbGlwWCgxMCk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Db250YWluZXIsICdjbGlwWScpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IGNsaXAgeVxyXG4gICAgICogQG5hbWUgY2xpcFlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgY2xpcCB5XHJcbiAgICAgKiB2YXIgY2xpcFkgPSBjb250YWluZXIuY2xpcFkoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgY2xpcCB5XHJcbiAgICAgKiBjb250YWluZXIuY2xpcFkoMTApO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuQ29udGFpbmVyLCAnY2xpcFdpZHRoJyk7XHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgY2xpcCB3aWR0aFxyXG4gICAgICogQG5hbWUgY2xpcFdpZHRoXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBjbGlwIHdpZHRoXHJcbiAgICAgKiB2YXIgY2xpcFdpZHRoID0gY29udGFpbmVyLmNsaXBXaWR0aCgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBjbGlwIHdpZHRoXHJcbiAgICAgKiBjb250YWluZXIuY2xpcFdpZHRoKDEwMCk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Db250YWluZXIsICdjbGlwSGVpZ2h0Jyk7XHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgY2xpcCBoZWlnaHRcclxuICAgICAqIEBuYW1lIGNsaXBIZWlnaHRcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBjbGlwIGhlaWdodFxyXG4gICAgICogdmFyIGNsaXBIZWlnaHQgPSBjb250YWluZXIuY2xpcEhlaWdodCgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBjbGlwIGhlaWdodFxyXG4gICAgICogY29udGFpbmVyLmNsaXBIZWlnaHQoMTAwKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5Db250YWluZXIpO1xyXG59KSgpO1xyXG5cbihmdW5jdGlvbihLb252YSkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdmFyIEhBU19TSEFET1cgPSAnaGFzU2hhZG93JztcclxuICAgIHZhciBTSEFET1dfUkdCQSA9ICdzaGFkb3dSR0JBJztcclxuXHJcbiAgICBmdW5jdGlvbiBfZmlsbEZ1bmMoY29udGV4dCkge1xyXG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gX3N0cm9rZUZ1bmMoY29udGV4dCkge1xyXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBfZmlsbEZ1bmNIaXQoY29udGV4dCkge1xyXG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gX3N0cm9rZUZ1bmNIaXQoY29udGV4dCkge1xyXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2NsZWFySGFzU2hhZG93Q2FjaGUoKSB7XHJcbiAgICAgICAgdGhpcy5fY2xlYXJDYWNoZShIQVNfU0hBRE9XKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfY2xlYXJHZXRTaGFkb3dSR0JBQ2FjaGUoKSB7XHJcbiAgICAgICAgdGhpcy5fY2xlYXJDYWNoZShTSEFET1dfUkdCQSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaGFwZSBjb25zdHJ1Y3Rvci4gIFNoYXBlcyBhcmUgcHJpbWl0aXZlIG9iamVjdHMgc3VjaCBhcyByZWN0YW5nbGVzLFxyXG4gICAgICogIGNpcmNsZXMsIHRleHQsIGxpbmVzLCBldGMuXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxyXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLk5vZGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiB2YXIgY3VzdG9tU2hhcGUgPSBuZXcgS29udmEuU2hhcGUoe1xyXG4gICAgICAgICAqICAgeDogNSxcclxuICAgICAgICAgKiAgIHk6IDEwLFxyXG4gICAgICAgICAqICAgZmlsbDogJ3JlZCcsXHJcbiAgICAgICAgICogICAvLyBhIEtvbnZhLkNhbnZhcyByZW5kZXJlciBpcyBwYXNzZWQgaW50byB0aGUgZHJhd0Z1bmMgZnVuY3Rpb25cclxuICAgICAgICAgKiAgIGRyYXdGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XHJcbiAgICAgICAgICogICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICogICAgIGNvbnRleHQubW92ZVRvKDIwMCwgNTApO1xyXG4gICAgICAgICAqICAgICBjb250ZXh0LmxpbmVUbyg0MjAsIDgwKTtcclxuICAgICAgICAgKiAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKDMwMCwgMTAwLCAyNjAsIDE3MCk7XHJcbiAgICAgICAgICogICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICogICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xyXG4gICAgICAgICAqICAgfVxyXG4gICAgICAgICAqfSk7XHJcbiAgICAgKi9cclxuICAgIEtvbnZhLlNoYXBlID0gZnVuY3Rpb24oY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5fX2luaXQoY29uZmlnKTtcclxuICAgIH07XHJcblxyXG4gICAgS29udmEuVXRpbC5hZGRNZXRob2RzKEtvbnZhLlNoYXBlLCB7XHJcbiAgICAgICAgX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICAgICAgdGhpcy5ub2RlVHlwZSA9ICdTaGFwZSc7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpbGxGdW5jID0gX2ZpbGxGdW5jO1xyXG4gICAgICAgICAgICB0aGlzLl9zdHJva2VGdW5jID0gX3N0cm9rZUZ1bmM7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpbGxGdW5jSGl0ID0gX2ZpbGxGdW5jSGl0O1xyXG4gICAgICAgICAgICB0aGlzLl9zdHJva2VGdW5jSGl0ID0gX3N0cm9rZUZ1bmNIaXQ7XHJcblxyXG4gICAgICAgICAgICAvLyBzZXQgY29sb3JLZXlcclxuICAgICAgICAgICAgdmFyIHNoYXBlcyA9IEtvbnZhLnNoYXBlcztcclxuICAgICAgICAgICAgdmFyIGtleTtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGtleSA9IEtvbnZhLlV0aWwuZ2V0UmFuZG9tQ29sb3IoKTtcclxuICAgICAgICAgICAgICAgIGlmKGtleSAmJiAhKCBrZXkgaW4gc2hhcGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNvbG9yS2V5ID0ga2V5O1xyXG4gICAgICAgICAgICBzaGFwZXNba2V5XSA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgIEtvbnZhLk5vZGUuY2FsbCh0aGlzLCBjb25maWcpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5vbignc2hhZG93Q29sb3JDaGFuZ2Uua29udmEgc2hhZG93Qmx1ckNoYW5nZS5rb252YSBzaGFkb3dPZmZzZXRDaGFuZ2Uua29udmEgc2hhZG93T3BhY2l0eUNoYW5nZS5rb252YSBzaGFkb3dFbmFibGVkQ2hhbmdlLmtvbnZhJywgX2NsZWFySGFzU2hhZG93Q2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5vbignc2hhZG93Q29sb3JDaGFuZ2Uua29udmEgc2hhZG93T3BhY2l0eUNoYW5nZS5rb252YSBzaGFkb3dFbmFibGVkQ2hhbmdlLmtvbnZhJywgX2NsZWFyR2V0U2hhZG93UkdCQUNhY2hlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhc0NoaWxkcmVuOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0Q2hpbGRyZW46IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBnZXQgY2FudmFzIGNvbnRleHQgdGllZCB0byB0aGUgbGF5ZXJcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Db250ZXh0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMYXllcigpLmdldENvbnRleHQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGdldCBjYW52YXMgcmVuZGVyZXIgdGllZCB0byB0aGUgbGF5ZXIuICBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIGEgY2FudmFzIHJlbmRlcmVyLCBub3QgYSBjYW52YXMgZWxlbWVudFxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLkNhbnZhc31cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRDYW52YXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMYXllcigpLmdldENhbnZhcygpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogcmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhIHNoYWRvdyB3aWxsIGJlIHJlbmRlcmVkXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBoYXNTaGFkb3c6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoSEFTX1NIQURPVywgdGhpcy5faGFzU2hhZG93KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9oYXNTaGFkb3c6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTaGFkb3dFbmFibGVkKCkgJiYgKHRoaXMuZ2V0U2hhZG93T3BhY2l0eSgpICE9PSAwICYmICEhKHRoaXMuZ2V0U2hhZG93Q29sb3IoKSB8fCB0aGlzLmdldFNoYWRvd0JsdXIoKSB8fCB0aGlzLmdldFNoYWRvd09mZnNldFgoKSB8fCB0aGlzLmdldFNoYWRvd09mZnNldFkoKSkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0U2hhZG93UkdCQTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZShTSEFET1dfUkdCQSwgdGhpcy5fZ2V0U2hhZG93UkdCQSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0U2hhZG93UkdCQTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1NoYWRvdygpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmdiYSA9IEtvbnZhLlV0aWwuY29sb3JUb1JHQkEodGhpcy5zaGFkb3dDb2xvcigpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAncmdiYSgnICsgcmdiYS5yICsgJywnICsgcmdiYS5nICsgJywnICsgcmdiYS5iICsgJywnICsgKHJnYmEuYSAqICh0aGlzLmdldFNoYWRvd09wYWNpdHkoKSB8fCAxKSkgKyAnKSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHNoYXBlIHdpbGwgYmUgZmlsbGVkXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBoYXNGaWxsOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhKHRoaXMuZ2V0RmlsbCgpIHx8IHRoaXMuZ2V0RmlsbFBhdHRlcm5JbWFnZSgpIHx8IHRoaXMuZ2V0RmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wcygpIHx8IHRoaXMuZ2V0RmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wcygpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHNoYXBlIHdpbGwgYmUgc3Ryb2tlZFxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaGFzU3Ryb2tlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhKHRoaXMuc3Ryb2tlKCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogZGV0ZXJtaW5lcyBpZiBwb2ludCBpcyBpbiB0aGUgc2hhcGUsIHJlZ2FyZGxlc3MgaWYgb3RoZXIgc2hhcGVzIGFyZSBvbiB0b3Agb2YgaXQuICBOb3RlOiBiZWNhdXNlXHJcbiAgICAgICAgICogIHRoaXMgbWV0aG9kIGNsZWFycyBhIHRlbXBvcmFyeSBjYW52YXMgYW5kIHRoZW4gcmVkcmF3cyB0aGUgc2hhcGUsIGl0IHBlcmZvcm1zIHZlcnkgcG9vcmx5IGlmIGV4ZWN1dGVkIG1hbnkgdGltZXNcclxuICAgICAgICAgKiAgY29uc2VjdXRpdmVseS4gIFBsZWFzZSB1c2UgdGhlIHtAbGluayBLb252YS5TdGFnZSNnZXRJbnRlcnNlY3Rpb259IG1ldGhvZCBpZiBhdCBhbGwgcG9zc2libGVcclxuICAgICAgICAgKiAgYmVjYXVzZSBpdCBwZXJmb3JtcyBtdWNoIGJldHRlclxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50XHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvaW50LnhcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9pbnQueVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGludGVyc2VjdHM6IGZ1bmN0aW9uKHBvaW50KSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKSxcclxuICAgICAgICAgICAgICAgIGJ1ZmZlckhpdENhbnZhcyA9IHN0YWdlLmJ1ZmZlckhpdENhbnZhcyxcclxuICAgICAgICAgICAgICAgIHA7XHJcblxyXG4gICAgICAgICAgICBidWZmZXJIaXRDYW52YXMuZ2V0Q29udGV4dCgpLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd1NjZW5lKGJ1ZmZlckhpdENhbnZhcyk7XHJcbiAgICAgICAgICAgIHAgPSBidWZmZXJIaXRDYW52YXMuY29udGV4dC5nZXRJbWFnZURhdGEoTWF0aC5yb3VuZChwb2ludC54KSwgTWF0aC5yb3VuZChwb2ludC55KSwgMSwgMSkuZGF0YTtcclxuICAgICAgICAgICAgcmV0dXJuIHBbM10gPiAwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gZXh0ZW5kcyBOb2RlLnByb3RvdHlwZS5kZXN0cm95XHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgZGVsZXRlIEtvbnZhLnNoYXBlc1t0aGlzLmNvbG9yS2V5XTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF91c2VCdWZmZXJDYW52YXM6IGZ1bmN0aW9uKGNhY2hpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuICFjYWNoaW5nICYmICh0aGlzLnBlcmZlY3REcmF3RW5hYmxlZCgpICYmICh0aGlzLmdldEFic29sdXRlT3BhY2l0eSgpICE9PSAxKSAmJiB0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLmhhc1N0cm9rZSgpICYmIHRoaXMuZ2V0U3RhZ2UoKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICh0aGlzLnBlcmZlY3REcmF3RW5hYmxlZCgpICYmIHRoaXMuaGFzU2hhZG93KCkgJiYgKHRoaXMuZ2V0QWJzb2x1dGVPcGFjaXR5KCkgIT09IDEpICYmIHRoaXMuaGFzRmlsbCgpICYmIHRoaXMuaGFzU3Ryb2tlKCkgJiYgdGhpcy5nZXRTdGFnZSgpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHJldHVybiBzZWxmIHJlY3RhbmdsZSAoeCwgeSwgd2lkdGgsIGhlaWdodCkgb2Ygc2hhcGUuXHJcbiAgICAgICAgICogVGhpcyBtZXRob2QgYXJlIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgdHJhbnNmb3JtYXRpb24gYW5kIHN0eWxlcy5cclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gcmVjdCB3aXRoIHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIHJlY3QuZ2V0U2VsZlJlY3QoKTsgIC8vIHJldHVybiB7eDowLCB5OjAsIHdpZHRoOnJlY3Qud2lkdGgoKSwgaGVpZ2h0OnJlY3QuaGVpZ2h0KCl9XHJcbiAgICAgICAgICogY2lyY2xlLmdldFNlbGZSZWN0KCk7ICAvLyByZXR1cm4ge3g6IC0gY2lyY2xlLndpZHRoKCkgLyAyLCB5OiAtIGNpcmNsZS5oZWlnaHQoKSAvIDIsIHdpZHRoOmNpcmNsZS53aWR0aCgpLCBoZWlnaHQ6Y2lyY2xlLmhlaWdodCgpfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0U2VsZlJlY3Q6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgeDogdGhpcy5fY2VudHJvaWQgPyBNYXRoLnJvdW5kKC1zaXplLndpZHRoIC8gMikgOiAwLFxyXG4gICAgICAgICAgICAgICAgeTogdGhpcy5fY2VudHJvaWQgPyBNYXRoLnJvdW5kKC1zaXplLmhlaWdodCAvIDIpIDogMCxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0Q2xpZW50UmVjdDogZnVuY3Rpb24oc2tpcFRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICB2YXIgZmlsbFJlY3QgPSB0aGlzLmdldFNlbGZSZWN0KCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3Ryb2tlV2lkdGggPSAodGhpcy5oYXNTdHJva2UoKSAmJiB0aGlzLnN0cm9rZVdpZHRoKCkpIHx8IDA7XHJcbiAgICAgICAgICAgIHZhciBmaWxsQW5kU3Ryb2tlV2lkdGggPSBmaWxsUmVjdC53aWR0aCArIHN0cm9rZVdpZHRoO1xyXG4gICAgICAgICAgICB2YXIgZmlsbEFuZFN0cm9rZUhlaWdodCA9IGZpbGxSZWN0LmhlaWdodCArIHN0cm9rZVdpZHRoO1xyXG5cclxuICAgICAgICAgICAgdmFyIHNoYWRvd09mZnNldFggPSB0aGlzLnNoYWRvd09mZnNldFgoKTtcclxuICAgICAgICAgICAgdmFyIHNoYWRvd09mZnNldFkgPSB0aGlzLnNoYWRvd09mZnNldFkoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwcmVXaWR0aCA9IGZpbGxBbmRTdHJva2VXaWR0aCArIE1hdGguYWJzKHNoYWRvd09mZnNldFgpO1xyXG4gICAgICAgICAgICB2YXIgcHJlSGVpZ2h0ID0gZmlsbEFuZFN0cm9rZUhlaWdodCArIE1hdGguYWJzKHNoYWRvd09mZnNldFkpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGJsdXJSYWRpdXMgPSAodGhpcy5oYXNTaGFkb3coKSAmJiB0aGlzLnNoYWRvd0JsdXIoKSB8fCAwKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHByZVdpZHRoICsgYmx1clJhZGl1cyAqIDI7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBwcmVIZWlnaHQgKyBibHVyUmFkaXVzICogMjtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIHN0cm9rZSwgZm9yIGV4YW1wbGUgPSAzXHJcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gc2V0IHggdG8gMS41LCBidXQgYWZ0ZXIgTWF0aC5yb3VuZCBpdCB3aWxsIGJlIDJcclxuICAgICAgICAgICAgLy8gYXMgd2UgaGF2ZSBhZGRpdGlvbmFsIG9mZnNldCB3ZSBuZWVkIHRvIGluY3JlYXNlIHdpZHRoIGFuZCBoZWlnaHQgYnkgMSBwaXhlbFxyXG4gICAgICAgICAgICB2YXIgcm91bmRpbmdPZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICBpZiAoTWF0aC5yb3VuZChzdHJva2VXaWR0aCAvIDIpICE9PSBzdHJva2VXaWR0aCAvIDIpIHtcclxuICAgICAgICAgICAgICAgIHJvdW5kaW5nT2Zmc2V0ID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVjdCA9IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCArIHJvdW5kaW5nT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyByb3VuZGluZ09mZnNldCxcclxuICAgICAgICAgICAgICAgIHg6IC1NYXRoLnJvdW5kKHN0cm9rZVdpZHRoIC8gMiArIGJsdXJSYWRpdXMpICsgTWF0aC5taW4oc2hhZG93T2Zmc2V0WCwgMCkgKyBmaWxsUmVjdC54LFxyXG4gICAgICAgICAgICAgICAgeTogLU1hdGgucm91bmQoc3Ryb2tlV2lkdGggLyAyICsgYmx1clJhZGl1cykgKyBNYXRoLm1pbihzaGFkb3dPZmZzZXRZLCAwKSArIGZpbGxSZWN0LnlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKCFza2lwVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtZWRSZWN0KHJlY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZWN0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZHJhd1NjZW5lOiBmdW5jdGlvbihjYW4sIHRvcCwgY2FjaGluZywgc2tpcEJ1ZmZlcikge1xyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksXHJcbiAgICAgICAgICAgICAgICBjYW52YXMgPSBjYW4gfHwgbGF5ZXIuZ2V0Q2FudmFzKCksXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoKSxcclxuICAgICAgICAgICAgICAgIGNhY2hlZENhbnZhcyA9IHRoaXMuX2NhY2hlLmNhbnZhcyxcclxuICAgICAgICAgICAgICAgIGRyYXdGdW5jID0gdGhpcy5zY2VuZUZ1bmMoKSxcclxuICAgICAgICAgICAgICAgIGhhc1NoYWRvdyA9IHRoaXMuaGFzU2hhZG93KCksXHJcbiAgICAgICAgICAgICAgICBoYXNTdHJva2UgPSB0aGlzLmhhc1N0cm9rZSgpLFxyXG4gICAgICAgICAgICAgICAgc3RhZ2UsIGJ1ZmZlckNhbnZhcywgYnVmZmVyQ29udGV4dDtcclxuXHJcbiAgICAgICAgICAgIGlmKCF0aGlzLmlzVmlzaWJsZSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2FjaGVkQ2FudmFzKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgIGxheWVyLl9hcHBseVRyYW5zZm9ybSh0aGlzLCBjb250ZXh0LCB0b3ApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhd0NhY2hlZFNjZW5lQ2FudmFzKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWRyYXdGdW5jKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcclxuICAgICAgICAgICAgLy8gaWYgYnVmZmVyIGNhbnZhcyBpcyBuZWVkZWRcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3VzZUJ1ZmZlckNhbnZhcyhjYWNoaW5nKSAmJiAhc2tpcEJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCk7XHJcbiAgICAgICAgICAgICAgICBidWZmZXJDYW52YXMgPSBzdGFnZS5idWZmZXJDYW52YXM7XHJcbiAgICAgICAgICAgICAgICBidWZmZXJDb250ZXh0ID0gYnVmZmVyQ2FudmFzLmdldENvbnRleHQoKTtcclxuICAgICAgICAgICAgICAgIGJ1ZmZlckNvbnRleHQuY2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIGJ1ZmZlckNvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgYnVmZmVyQ29udGV4dC5fYXBwbHlMaW5lSm9pbih0aGlzKTtcclxuICAgICAgICAgICAgICAgIC8vIGxheWVyIG1pZ2h0IGJlIHVuZGVmaW5lZCBpZiB3ZSBhcmUgdXNpbmcgY2FjaGUgYmVmb3JlIGFkZGluZyB0byBsYXllclxyXG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLl9hcHBseVRyYW5zZm9ybSh0aGlzLCBidWZmZXJDb250ZXh0LCB0b3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gdGhpcy5nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApLmdldE1hdHJpeCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zZm9ybShtWzBdLCBtWzFdLCBtWzJdLCBtWzNdLCBtWzRdLCBtWzVdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZHJhd0Z1bmMuY2FsbCh0aGlzLCBidWZmZXJDb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGJ1ZmZlckNvbnRleHQucmVzdG9yZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChoYXNTaGFkb3cgJiYgIWNhbnZhcy5oaXRDYW52YXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5U2hhZG93KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Ll9hcHBseU9wYWNpdHkodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGJ1ZmZlckNhbnZhcy5fY2FudmFzLCAwLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5T3BhY2l0eSh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShidWZmZXJDYW52YXMuX2NhbnZhcywgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgYnVmZmVyIGNhbnZhcyBpcyBub3QgbmVlZGVkXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5fYXBwbHlMaW5lSm9pbih0aGlzKTtcclxuICAgICAgICAgICAgICAgIC8vIGxheWVyIG1pZ2h0IGJlIHVuZGVmaW5lZCBpZiB3ZSBhcmUgdXNpbmcgY2FjaGUgYmVmb3JlIGFkZGluZyB0byBsYXllclxyXG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLl9hcHBseVRyYW5zZm9ybSh0aGlzLCBjb250ZXh0LCB0b3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gdGhpcy5nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApLmdldE1hdHJpeCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zZm9ybShvWzBdLCBvWzFdLCBvWzJdLCBvWzNdLCBvWzRdLCBvWzVdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGhhc1NoYWRvdyAmJiBoYXNTdHJva2UgJiYgIWNhbnZhcy5oaXRDYW52YXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhcHBseSBzaGFkb3dcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhY2hpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5fYXBwbHlPcGFjaXR5KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Ll9hcHBseVNoYWRvdyh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBkcmF3RnVuYy5jYWxsKHRoaXMsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHNoYXBlIGhhcyBzdHJva2Ugd2UgbmVlZCB0byByZWRyYXcgc2hhcGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2Ugd2lsbCBzZWUgYSBzaGFkb3cgdW5kZXIgc3Ryb2tlIChhbmQgb3ZlciBmaWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBJIHRoaW5rIHRoaXMgaXMgdW5leHBlY3RlZCBiZWhhdmlvclxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLmdldFNoYWRvd0ZvclN0cm9rZUVuYWJsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3RnVuYy5jYWxsKHRoaXMsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzU2hhZG93ICYmICFjYW52YXMuaGl0Q2FudmFzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWNoaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5T3BhY2l0eSh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5fYXBwbHlTaGFkb3codGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZHJhd0Z1bmMuY2FsbCh0aGlzLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWNoaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5T3BhY2l0eSh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZHJhd0Z1bmMuY2FsbCh0aGlzLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkcmF3SGl0OiBmdW5jdGlvbihjYW4sIHRvcCwgY2FjaGluZykge1xyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksXHJcbiAgICAgICAgICAgICAgICBjYW52YXMgPSBjYW4gfHwgbGF5ZXIuaGl0Q2FudmFzLFxyXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCksXHJcbiAgICAgICAgICAgICAgICBkcmF3RnVuYyA9IHRoaXMuaGl0RnVuYygpIHx8IHRoaXMuc2NlbmVGdW5jKCksXHJcbiAgICAgICAgICAgICAgICBjYWNoZWRDYW52YXMgPSB0aGlzLl9jYWNoZS5jYW52YXMsXHJcbiAgICAgICAgICAgICAgICBjYWNoZWRIaXRDYW52YXMgPSBjYWNoZWRDYW52YXMgJiYgY2FjaGVkQ2FudmFzLmhpdDtcclxuXHJcbiAgICAgICAgICAgIGlmKCF0aGlzLnNob3VsZERyYXdIaXQoY2FudmFzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxheWVyKSB7XHJcbiAgICAgICAgICAgICAgICBsYXllci5jbGVhckhpdENhY2hlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNhY2hlZEhpdENhbnZhcykge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICBsYXllci5fYXBwbHlUcmFuc2Zvcm0odGhpcywgY29udGV4dCwgdG9wKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdDYWNoZWRIaXRDYW52YXMoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghZHJhd0Z1bmMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgICAgICBjb250ZXh0Ll9hcHBseUxpbmVKb2luKHRoaXMpO1xyXG4gICAgICAgICAgICBpZiAoIWNhY2hpbmcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsYXllcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9hcHBseVRyYW5zZm9ybSh0aGlzLCBjb250ZXh0LCB0b3ApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHRoaXMuZ2V0QWJzb2x1dGVUcmFuc2Zvcm0odG9wKS5nZXRNYXRyaXgoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zZm9ybShvWzBdLCBvWzFdLCBvWzJdLCBvWzNdLCBvWzRdLCBvWzVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkcmF3RnVuYy5jYWxsKHRoaXMsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAqIGRyYXcgaGl0IGdyYXBoIHVzaW5nIHRoZSBjYWNoZWQgc2NlbmUgY2FudmFzXHJcbiAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXHJcbiAgICAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGFscGhhVGhyZXNob2xkIGFscGhhIGNoYW5uZWwgdGhyZXNob2xkIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdFxyXG4gICAgICAgICogIGEgcGl4ZWwgc2hvdWxkIGJlIGRyYXduIG9udG8gdGhlIGhpdCBncmFwaC4gIE11c3QgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NS5cclxuICAgICAgICAqICBUaGUgZGVmYXVsdCBpcyAwXHJcbiAgICAgICAgKiBAcmV0dXJucyB7S29udmEuU2hhcGV9XHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogc2hhcGUuY2FjaGUoKTtcclxuICAgICAgICAqIHNoYXBlLmRyYXdIaXRGcm9tQ2FjaGUoKTtcclxuICAgICAgICAqL1xyXG4gICAgICAgIGRyYXdIaXRGcm9tQ2FjaGU6IGZ1bmN0aW9uKGFscGhhVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgIHZhciB0aHJlc2hvbGQgPSBhbHBoYVRocmVzaG9sZCB8fCAwLFxyXG4gICAgICAgICAgICAgICAgY2FjaGVkQ2FudmFzID0gdGhpcy5fY2FjaGUuY2FudmFzLFxyXG4gICAgICAgICAgICAgICAgc2NlbmVDYW52YXMgPSB0aGlzLl9nZXRDYWNoZWRTY2VuZUNhbnZhcygpLFxyXG4gICAgICAgICAgICAgICAgaGl0Q2FudmFzID0gY2FjaGVkQ2FudmFzLmhpdCxcclxuICAgICAgICAgICAgICAgIGhpdENvbnRleHQgPSBoaXRDYW52YXMuZ2V0Q29udGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgaGl0V2lkdGggPSBoaXRDYW52YXMuZ2V0V2lkdGgoKSxcclxuICAgICAgICAgICAgICAgIGhpdEhlaWdodCA9IGhpdENhbnZhcy5nZXRIZWlnaHQoKSxcclxuICAgICAgICAgICAgICAgIGhpdEltYWdlRGF0YSwgaGl0RGF0YSwgbGVuLCByZ2JDb2xvcktleSwgaSwgYWxwaGE7XHJcblxyXG4gICAgICAgICAgICBoaXRDb250ZXh0LmNsZWFyKCk7XHJcbiAgICAgICAgICAgIGhpdENvbnRleHQuZHJhd0ltYWdlKHNjZW5lQ2FudmFzLl9jYW52YXMsIDAsIDAsIGhpdFdpZHRoLCBoaXRIZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGhpdEltYWdlRGF0YSA9IGhpdENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGhpdFdpZHRoLCBoaXRIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgaGl0RGF0YSA9IGhpdEltYWdlRGF0YS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgbGVuID0gaGl0RGF0YS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICByZ2JDb2xvcktleSA9IEtvbnZhLlV0aWwuX2hleFRvUmdiKHRoaXMuY29sb3JLZXkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2Ugbm9uIHRyYW5zcGFyZW50IHBpeGVscyB3aXRoIGNvbG9yIGtleVxyXG4gICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IGhpdERhdGFbaSArIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYSA+IHRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaXREYXRhW2ldID0gcmdiQ29sb3JLZXkucjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGl0RGF0YVtpICsgMV0gPSByZ2JDb2xvcktleS5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaXREYXRhW2kgKyAyXSA9IHJnYkNvbG9yS2V5LmI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdERhdGFbaSArIDNdID0gMjU1O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGl0RGF0YVtpICsgM10gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGhpdENvbnRleHQucHV0SW1hZ2VEYXRhKGhpdEltYWdlRGF0YSwgMCwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgS29udmEuVXRpbC5lcnJvcignVW5hYmxlIHRvIGRyYXcgaGl0IGdyYXBoIGZyb20gY2FjaGVkIHNjZW5lIGNhbnZhcy4gJyArIGUubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuU2hhcGUsIEtvbnZhLk5vZGUpO1xyXG5cclxuICAgIC8vIGFkZCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3N0cm9rZScpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBzdHJva2UgY29sb3JcclxuICAgICAqIEBuYW1lIHN0cm9rZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBzdHJva2UgY29sb3JcclxuICAgICAqIHZhciBzdHJva2UgPSBzaGFwZS5zdHJva2UoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgc3Ryb2tlIGNvbG9yIHdpdGggY29sb3Igc3RyaW5nXHJcbiAgICAgKiBzaGFwZS5zdHJva2UoJ2dyZWVuJyk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IHN0cm9rZSBjb2xvciB3aXRoIGhleFxyXG4gICAgICogc2hhcGUuc3Ryb2tlKCcjMDBmZjAwJyk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IHN0cm9rZSBjb2xvciB3aXRoIHJnYlxyXG4gICAgICogc2hhcGUuc3Ryb2tlKCdyZ2IoMCwyNTUsMCknKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgc3Ryb2tlIGNvbG9yIHdpdGggcmdiYSBhbmQgbWFrZSBpdCA1MCUgb3BhcXVlXHJcbiAgICAgKiBzaGFwZS5zdHJva2UoJ3JnYmEoMCwyNTUsMCwwLjUnKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkRGVwcmVjYXRlZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3N0cm9rZVJlZCcsIDAsIEtvbnZhLlZhbGlkYXRvcnMuUkdCQ29tcG9uZW50KTtcclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkRGVwcmVjYXRlZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3N0cm9rZUdyZWVuJywgMCwgS29udmEuVmFsaWRhdG9ycy5SR0JDb21wb25lbnQpO1xyXG4gICAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc3Ryb2tlQmx1ZScsIDAsIEtvbnZhLlZhbGlkYXRvcnMuUkdCQ29tcG9uZW50KTtcclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkRGVwcmVjYXRlZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3N0cm9rZUFscGhhJywgMSwgS29udmEuVmFsaWRhdG9ycy5hbHBoYUNvbXBvbmVudCk7XHJcblxyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc3Ryb2tlV2lkdGgnLCAyKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgc3Ryb2tlIHdpZHRoXHJcbiAgICAgKiBAbmFtZSBzdHJva2VXaWR0aFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0cm9rZVdpZHRoXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBzdHJva2Ugd2lkdGhcclxuICAgICAqIHZhciBzdHJva2VXaWR0aCA9IHNoYXBlLnN0cm9rZVdpZHRoKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IHN0cm9rZSB3aWR0aFxyXG4gICAgICogc2hhcGUuc3Ryb2tlV2lkdGgoKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc3Ryb2tlSGl0RW5hYmxlZCcsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBzdHJva2VIaXRFbmFibGVkIHByb3BlcnR5LiBVc2VmdWwgZm9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi5cclxuICAgICAqIFlvdSBtYXkgc2V0IGBzaGFwZS5zdHJva2VIaXRFbmFibGVkKGZhbHNlKWAuIEluIHRoaXMgY2FzZSBzdHJva2Ugd2lsbCBiZSBubyBkcmF3IG9uIGhpdCBjYW52YXMsIHNvIGhpdCBhcmVhXHJcbiAgICAgKiBvZiBzaGFwZSB3aWxsIGJlIGRlY3JlYXNlZCAoYnkgbGluZVdpZHRoIC8gMikuIFJlbWVtYmVyIHRoYXQgbm9uIGNsb3NlZCBsaW5lIHdpdGggYHN0cm9rZUhpdEVuYWJsZWQgPSBmYWxzZWBcclxuICAgICAqIHdpbGwgYmUgbm90IGRyYXduIG9uIGhpdCBjYW52YXMsIHRoYXQgaXMgbWVhbiBsaW5lIHdpbGwgbm8gdHJpZ2dlciBwb2ludGVyIGV2ZW50cyAobGlrZSBtb3VzZW92ZXIpXHJcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIHRydWVcclxuICAgICAqIEBuYW1lIHN0cm9rZUhpdEVuYWJsZWRcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3Ryb2tlSGl0RW5hYmxlZFxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IHN0cm9rZUhpdEVuYWJsZWRcclxuICAgICAqIHZhciBzdHJva2VIaXRFbmFibGVkID0gc2hhcGUuc3Ryb2tlSGl0RW5hYmxlZCgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBzdHJva2VIaXRFbmFibGVkXHJcbiAgICAgKiBzaGFwZS5zdHJva2VIaXRFbmFibGVkKCk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3BlcmZlY3REcmF3RW5hYmxlZCcsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBwZXJmZWN0RHJhd0VuYWJsZWQuIElmIGEgc2hhcGUgaGFzIGZpbGwsIHN0cm9rZSBhbmQgb3BhY2l0eSB5b3UgbWF5IHNldCBgcGVyZmVjdERyYXdFbmFibGVkYCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLlxyXG4gICAgICogU2VlIGh0dHA6Ly9rb252YWpzLmdpdGh1Yi5pby9kb2NzL3BlcmZvcm1hbmNlL0Rpc2FibGVfUGVyZmVjdF9EcmF3Lmh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIHRydWVcclxuICAgICAqIEBuYW1lIHBlcmZlY3REcmF3RW5hYmxlZFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBwZXJmZWN0RHJhd0VuYWJsZWRcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBwZXJmZWN0RHJhd0VuYWJsZWRcclxuICAgICAqIHZhciBwZXJmZWN0RHJhd0VuYWJsZWQgPSBzaGFwZS5wZXJmZWN0RHJhd0VuYWJsZWQoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgcGVyZmVjdERyYXdFbmFibGVkXHJcbiAgICAgKiBzaGFwZS5wZXJmZWN0RHJhd0VuYWJsZWQoKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZCcsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBzaGFkb3dGb3JTdHJva2VFbmFibGVkLiBVc2VmdWwgZm9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi5cclxuICAgICAqIFlvdSBtYXkgc2V0IGBzaGFwZS5zaGFkb3dGb3JTdHJva2VFbmFibGVkKGZhbHNlKWAuIEluIHRoaXMgY2FzZSBzdHJva2Ugd2lsbCBiZSBubyBkcmF3IHNoYWRvdyBmb3Igc3Ryb2tlLlxyXG4gICAgICogUmVtZW1iZXIgaWYgeW91IHNldCBgc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZCA9IGZhbHNlYCBmb3Igbm9uIGNsb3NlZCBsaW5lIC0gdGhhdCBsaW5lIHdpdGggaGF2ZSBubyBzaGFkb3chLlxyXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyB0cnVlXHJcbiAgICAgKiBAbmFtZSBzaGFkb3dGb3JTdHJva2VFbmFibGVkXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNoYWRvd0ZvclN0cm9rZUVuYWJsZWRcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBzaGFkb3dGb3JTdHJva2VFbmFibGVkXHJcbiAgICAgKiB2YXIgc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZCA9IHNoYXBlLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWQoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZFxyXG4gICAgICogc2hhcGUuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZCgpO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdsaW5lSm9pbicpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBsaW5lIGpvaW4uICBDYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZVxyXG4gICAgICogIGRlZmF1bHQgaXMgbWl0ZXJcclxuICAgICAqIEBuYW1lIGxpbmVKb2luXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZUpvaW5cclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGxpbmUgam9pblxyXG4gICAgICogdmFyIGxpbmVKb2luID0gc2hhcGUubGluZUpvaW4oKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgbGluZSBqb2luXHJcbiAgICAgKiBzaGFwZS5saW5lSm9pbigncm91bmQnKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnbGluZUNhcCcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBsaW5lIGNhcC4gIENhbiBiZSBidXR0LCByb3VuZCwgb3Igc3F1YXJlXHJcbiAgICAgKiBAbmFtZSBsaW5lQ2FwXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZUNhcFxyXG4gICAgICogQHJldHVybnMge1N0cmluZ31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgbGluZSBjYXBcclxuICAgICAqIHZhciBsaW5lQ2FwID0gc2hhcGUubGluZUNhcCgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBsaW5lIGNhcFxyXG4gICAgICogc2hhcGUubGluZUNhcCgncm91bmQnKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2NlbmVGdW5jJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IHNjZW5lIGRyYXcgZnVuY3Rpb25cclxuICAgICAqIEBuYW1lIHNjZW5lRnVuY1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZHJhd0Z1bmMgZHJhd2luZyBmdW5jdGlvblxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBzY2VuZSBkcmF3IGZ1bmN0aW9uXHJcbiAgICAgKiB2YXIgc2NlbmVGdW5jID0gc2hhcGUuc2NlbmVGdW5jKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IHNjZW5lIGRyYXcgZnVuY3Rpb25cclxuICAgICAqIHNoYXBlLnNjZW5lRnVuYyhmdW5jdGlvbihjb250ZXh0KSB7XHJcbiAgICAgKiAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgKiAgIGNvbnRleHQucmVjdCgwLCAwLCB0aGlzLndpZHRoKCksIHRoaXMuaGVpZ2h0KCkpO1xyXG4gICAgICogICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICogICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcclxuICAgICAqIH0pO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdoaXRGdW5jJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IGhpdCBkcmF3IGZ1bmN0aW9uXHJcbiAgICAgKiBAbmFtZSBoaXRGdW5jXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmF3RnVuYyBkcmF3aW5nIGZ1bmN0aW9uXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGhpdCBkcmF3IGZ1bmN0aW9uXHJcbiAgICAgKiB2YXIgaGl0RnVuYyA9IHNoYXBlLmhpdEZ1bmMoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgaGl0IGRyYXcgZnVuY3Rpb25cclxuICAgICAqIHNoYXBlLmhpdEZ1bmMoZnVuY3Rpb24oY29udGV4dCkge1xyXG4gICAgICogICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICogICBjb250ZXh0LnJlY3QoMCwgMCwgdGhpcy53aWR0aCgpLCB0aGlzLmhlaWdodCgpKTtcclxuICAgICAqICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAqICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XHJcbiAgICAgKiB9KTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZGFzaCcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBkYXNoIGFycmF5IGZvciBzdHJva2UuXHJcbiAgICAgKiBAbmFtZSBkYXNoXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXNoXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogIC8vIGFwcGx5IGRhc2hlZCBzdHJva2UgdGhhdCBpcyAxMHB4IGxvbmcgYW5kIDUgcGl4ZWxzIGFwYXJ0XHJcbiAgICAgKiAgbGluZS5kYXNoKFsxMCwgNV0pO1xyXG4gICAgICogIC8vIGFwcGx5IGRhc2hlZCBzdHJva2UgdGhhdCBpcyBtYWRlIHVwIG9mIGFsdGVybmF0aW5nIGRhc2hlZFxyXG4gICAgICogIC8vIGxpbmVzIHRoYXQgYXJlIDEwcHggbG9uZyBhbmQgMjBweCBhcGFydCwgYW5kIGRvdHMgdGhhdCBoYXZlXHJcbiAgICAgKiAgLy8gYSByYWRpdXMgb2YgNXB4IGFuZCBhcmUgMjBweCBhcGFydFxyXG4gICAgICogIGxpbmUuZGFzaChbMTAsIDIwLCAwLjAwMSwgMjBdKTtcclxuICAgICAqL1xyXG5cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3NoYWRvd0NvbG9yJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IHNoYWRvdyBjb2xvclxyXG4gICAgICogQG5hbWUgc2hhZG93Q29sb3JcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvclxyXG4gICAgICogQHJldHVybnMge1N0cmluZ31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgc2hhZG93IGNvbG9yXHJcbiAgICAgKiB2YXIgc2hhZG93ID0gc2hhcGUuc2hhZG93Q29sb3IoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgc2hhZG93IGNvbG9yIHdpdGggY29sb3Igc3RyaW5nXHJcbiAgICAgKiBzaGFwZS5zaGFkb3dDb2xvcignZ3JlZW4nKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgc2hhZG93IGNvbG9yIHdpdGggaGV4XHJcbiAgICAgKiBzaGFwZS5zaGFkb3dDb2xvcignIzAwZmYwMCcpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBzaGFkb3cgY29sb3Igd2l0aCByZ2JcclxuICAgICAqIHNoYXBlLnNoYWRvd0NvbG9yKCdyZ2IoMCwyNTUsMCknKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgc2hhZG93IGNvbG9yIHdpdGggcmdiYSBhbmQgbWFrZSBpdCA1MCUgb3BhcXVlXHJcbiAgICAgKiBzaGFwZS5zaGFkb3dDb2xvcigncmdiYSgwLDI1NSwwLDAuNScpO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2hhZG93UmVkJywgMCwgS29udmEuVmFsaWRhdG9ycy5SR0JDb21wb25lbnQpO1xyXG4gICAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2hhZG93R3JlZW4nLCAwLCBLb252YS5WYWxpZGF0b3JzLlJHQkNvbXBvbmVudCk7XHJcbiAgICBLb252YS5GYWN0b3J5LmFkZERlcHJlY2F0ZWRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dCbHVlJywgMCwgS29udmEuVmFsaWRhdG9ycy5SR0JDb21wb25lbnQpO1xyXG4gICAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2hhZG93QWxwaGEnLCAxLCBLb252YS5WYWxpZGF0b3JzLmFscGhhQ29tcG9uZW50KTtcclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3NoYWRvd0JsdXInKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgc2hhZG93IGJsdXJcclxuICAgICAqIEBuYW1lIHNoYWRvd0JsdXJcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBibHVyXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBzaGFkb3cgYmx1clxyXG4gICAgICogdmFyIHNoYWRvd0JsdXIgPSBzaGFwZS5zaGFkb3dCbHVyKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IHNoYWRvdyBibHVyXHJcbiAgICAgKiBzaGFwZS5zaGFkb3dCbHVyKDEwKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2hhZG93T3BhY2l0eScpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBzaGFkb3cgb3BhY2l0eS4gIG11c3QgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDFcclxuICAgICAqIEBuYW1lIHNoYWRvd09wYWNpdHlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcGFjaXR5XHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBzaGFkb3cgb3BhY2l0eVxyXG4gICAgICogdmFyIHNoYWRvd09wYWNpdHkgPSBzaGFwZS5zaGFkb3dPcGFjaXR5KCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IHNoYWRvdyBvcGFjaXR5XHJcbiAgICAgKiBzaGFwZS5zaGFkb3dPcGFjaXR5KDAuNSk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dPZmZzZXQnLCBbJ3gnLCAneSddKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgc2hhZG93IG9mZnNldFxyXG4gICAgICogQG5hbWUgc2hhZG93T2Zmc2V0XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0LnhcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQueVxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgc2hhZG93IG9mZnNldFxyXG4gICAgICogdmFyIHNoYWRvd09mZnNldCA9IHNoYXBlLnNoYWRvd09mZnNldCgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBzaGFkb3cgb2Zmc2V0XHJcbiAgICAgKiBzaGFwZS5zaGFkb3dPZmZzZXQoe1xyXG4gICAgICogICB4OiAyMFxyXG4gICAgICogICB5OiAxMFxyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3NoYWRvd09mZnNldFgnLCAwKTtcclxuXHJcbiAgICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IHNoYWRvdyBvZmZzZXQgeFxyXG4gICAgICogQG5hbWUgc2hhZG93T2Zmc2V0WFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IHNoYWRvdyBvZmZzZXQgeFxyXG4gICAgICogdmFyIHNoYWRvd09mZnNldFggPSBzaGFwZS5zaGFkb3dPZmZzZXRYKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IHNoYWRvdyBvZmZzZXQgeFxyXG4gICAgICogc2hhcGUuc2hhZG93T2Zmc2V0WCg1KTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2hhZG93T2Zmc2V0WScsIDApO1xyXG5cclxuICAgICAvKipcclxuICAgICAqIGdldC9zZXQgc2hhZG93IG9mZnNldCB5XHJcbiAgICAgKiBAbmFtZSBzaGFkb3dPZmZzZXRZXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgc2hhZG93IG9mZnNldCB5XHJcbiAgICAgKiB2YXIgc2hhZG93T2Zmc2V0WSA9IHNoYXBlLnNoYWRvd09mZnNldFkoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgc2hhZG93IG9mZnNldCB5XHJcbiAgICAgKiBzaGFwZS5zaGFkb3dPZmZzZXRZKDUpO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUGF0dGVybkltYWdlJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiBpbWFnZVxyXG4gICAgICogQG5hbWUgZmlsbFBhdHRlcm5JbWFnZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2Ugb2JqZWN0XHJcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2V9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGZpbGwgcGF0dGVybiBpbWFnZVxyXG4gICAgICogdmFyIGZpbGxQYXR0ZXJuSW1hZ2UgPSBzaGFwZS5maWxsUGF0dGVybkltYWdlKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IGZpbGwgcGF0dGVybiBpbWFnZVxyXG4gICAgICogdmFyIGltYWdlT2JqID0gbmV3IEltYWdlKCk7XHJcbiAgICAgKiBpbWFnZU9iai5vbmxvYWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAqICAgc2hhcGUuZmlsbFBhdHRlcm5JbWFnZShpbWFnZU9iaik7XHJcbiAgICAgKiB9O1xyXG4gICAgICogaW1hZ2VPYmouc3JjID0gJ3BhdGgvdG8vaW1hZ2UvanBnJztcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbCcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBmaWxsIGNvbG9yXHJcbiAgICAgKiBAbmFtZSBmaWxsXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3JcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGZpbGwgY29sb3JcclxuICAgICAqIHZhciBmaWxsID0gc2hhcGUuZmlsbCgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBmaWxsIGNvbG9yIHdpdGggY29sb3Igc3RyaW5nXHJcbiAgICAgKiBzaGFwZS5maWxsKCdncmVlbicpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBmaWxsIGNvbG9yIHdpdGggaGV4XHJcbiAgICAgKiBzaGFwZS5maWxsKCcjMDBmZjAwJyk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IGZpbGwgY29sb3Igd2l0aCByZ2JcclxuICAgICAqIHNoYXBlLmZpbGwoJ3JnYigwLDI1NSwwKScpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBmaWxsIGNvbG9yIHdpdGggcmdiYSBhbmQgbWFrZSBpdCA1MCUgb3BhcXVlXHJcbiAgICAgKiBzaGFwZS5maWxsKCdyZ2JhKDAsMjU1LDAsMC41Jyk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2hhcGUgd2l0aG91dCBmaWxsXHJcbiAgICAgKiBzaGFwZS5maWxsKG51bGwpO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFJlZCcsIDAsIEtvbnZhLlZhbGlkYXRvcnMuUkdCQ29tcG9uZW50KTtcclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkRGVwcmVjYXRlZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxHcmVlbicsIDAsIEtvbnZhLlZhbGlkYXRvcnMuUkdCQ29tcG9uZW50KTtcclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkRGVwcmVjYXRlZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxCbHVlJywgMCwgS29udmEuVmFsaWRhdG9ycy5SR0JDb21wb25lbnQpO1xyXG4gICAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbEFscGhhJywgMSwgS29udmEuVmFsaWRhdG9ycy5hbHBoYUNvbXBvbmVudCk7XHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUGF0dGVyblgnLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgZmlsbCBwYXR0ZXJuIHhcclxuICAgICAqIEBuYW1lIGZpbGxQYXR0ZXJuWFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGZpbGwgcGF0dGVybiB4XHJcbiAgICAgKiB2YXIgZmlsbFBhdHRlcm5YID0gc2hhcGUuZmlsbFBhdHRlcm5YKCk7XHJcbiAgICAgKiAvLyBzZXQgZmlsbCBwYXR0ZXJuIHhcclxuICAgICAqIHNoYXBlLmZpbGxQYXR0ZXJuWCgyMCk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQYXR0ZXJuWScsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4geVxyXG4gICAgICogQG5hbWUgZmlsbFBhdHRlcm5ZXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIHlcclxuICAgICAqIHZhciBmaWxsUGF0dGVyblkgPSBzaGFwZS5maWxsUGF0dGVyblkoKTtcclxuICAgICAqIC8vIHNldCBmaWxsIHBhdHRlcm4geVxyXG4gICAgICogc2hhcGUuZmlsbFBhdHRlcm5ZKDIwKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wcycpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBmaWxsIGxpbmVhciBncmFkaWVudCBjb2xvciBzdG9wc1xyXG4gICAgICogQG5hbWUgZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29sb3JTdG9wc1xyXG4gICAgICogQHJldHVybnMge0FycmF5fSBjb2xvclN0b3BzXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGNvbG9yIHN0b3BzXHJcbiAgICAgKiB2YXIgY29sb3JTdG9wcyA9IHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBjcmVhdGUgYSBsaW5lYXIgZ3JhZGllbnQgdGhhdCBzdGFydHMgd2l0aCByZWQsIGNoYW5nZXMgdG8gYmx1ZVxyXG4gICAgICogLy8gaGFsZndheSB0aHJvdWdoLCBhbmQgdGhlbiBjaGFuZ2VzIHRvIGdyZWVuXHJcbiAgICAgKiBzaGFwZS5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzKDAsICdyZWQnLCAwLjUsICdibHVlJywgMSwgJ2dyZWVuJyk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzJywgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHJhZGl1c1xyXG4gICAgICogQG5hbWUgZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IHJhZGlhbCBncmFkaWVudCBzdGFydCByYWRpdXNcclxuICAgICAqIHZhciBzdGFydFJhZGl1cyA9IHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IHJhZGlhbCBncmFkaWVudCBzdGFydCByYWRpdXNcclxuICAgICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzKDApO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXMnLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgZW5kIHJhZGl1c1xyXG4gICAgICogQG5hbWUgZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCByYWRpYWwgZ3JhZGllbnQgZW5kIHJhZGl1c1xyXG4gICAgICogdmFyIGVuZFJhZGl1cyA9IHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1cygpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCByYWRpYWwgZ3JhZGllbnQgZW5kIHJhZGl1c1xyXG4gICAgICogc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzKDEwMCk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMnKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgY29sb3Igc3RvcHNcclxuICAgICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb2xvclN0b3BzXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGNvbG9yIHN0b3BzXHJcbiAgICAgKiB2YXIgY29sb3JTdG9wcyA9IHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBjcmVhdGUgYSByYWRpYWwgZ3JhZGllbnQgdGhhdCBzdGFydHMgd2l0aCByZWQsIGNoYW5nZXMgdG8gYmx1ZVxyXG4gICAgICogLy8gaGFsZndheSB0aHJvdWdoLCBhbmQgdGhlbiBjaGFuZ2VzIHRvIGdyZWVuXHJcbiAgICAgKiBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzKDAsICdyZWQnLCAwLjUsICdibHVlJywgMSwgJ2dyZWVuJyk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQYXR0ZXJuUmVwZWF0JywgJ3JlcGVhdCcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gcmVwZWF0LiAgQ2FuIGJlICdyZXBlYXQnLCAncmVwZWF0LXgnLCAncmVwZWF0LXknLCBvciAnbm8tcmVwZWF0Jy4gIFRoZSBkZWZhdWx0IGlzICdyZXBlYXQnXHJcbiAgICAgKiBAbmFtZSBmaWxsUGF0dGVyblJlcGVhdFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcGVhdFxyXG4gICAgICogQHJldHVybnMge1N0cmluZ31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIHJlcGVhdFxyXG4gICAgICogdmFyIHJlcGVhdCA9IHNoYXBlLmZpbGxQYXR0ZXJuUmVwZWF0KCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gcmVwZWF0IHBhdHRlcm4gaW4geCBkaXJlY3Rpb24gb25seVxyXG4gICAgICogc2hhcGUuZmlsbFBhdHRlcm5SZXBlYXQoJ3JlcGVhdC14Jyk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gZG8gbm90IHJlcGVhdCB0aGUgcGF0dGVyblxyXG4gICAgICogc2hhcGUuZmlsbFBhdHRlcm5SZXBlYXQoJ25vIHJlcGVhdCcpO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsRW5hYmxlZCcsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBmaWxsIGVuYWJsZWQgZmxhZ1xyXG4gICAgICogQG5hbWUgZmlsbEVuYWJsZWRcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZFxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGZpbGwgZW5hYmxlZCBmbGFnXHJcbiAgICAgKiB2YXIgZmlsbEVuYWJsZWQgPSBzaGFwZS5maWxsRW5hYmxlZCgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIGRpc2FibGUgZmlsbFxyXG4gICAgICogc2hhcGUuZmlsbEVuYWJsZWQoZmFsc2UpO1xyXG4gICAgICpcclxuICAgICAqIC8vIGVuYWJsZSBmaWxsXHJcbiAgICAgKiBzaGFwZS5maWxsRW5hYmxlZCh0cnVlKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc3Ryb2tlRW5hYmxlZCcsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBzdHJva2UgZW5hYmxlZCBmbGFnXHJcbiAgICAgKiBAbmFtZSBzdHJva2VFbmFibGVkXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWRcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBzdHJva2UgZW5hYmxlZCBmbGFnXHJcbiAgICAgKiB2YXIgc3Ryb2tlRW5hYmxlZCA9IHNoYXBlLnN0cm9rZUVuYWJsZWQoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBkaXNhYmxlIHN0cm9rZVxyXG4gICAgICogc2hhcGUuc3Ryb2tlRW5hYmxlZChmYWxzZSk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gZW5hYmxlIHN0cm9rZVxyXG4gICAgICogc2hhcGUuc3Ryb2tlRW5hYmxlZCh0cnVlKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2hhZG93RW5hYmxlZCcsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBzaGFkb3cgZW5hYmxlZCBmbGFnXHJcbiAgICAgKiBAbmFtZSBzaGFkb3dFbmFibGVkXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWRcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBzaGFkb3cgZW5hYmxlZCBmbGFnXHJcbiAgICAgKiB2YXIgc2hhZG93RW5hYmxlZCA9IHNoYXBlLnNoYWRvd0VuYWJsZWQoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBkaXNhYmxlIHNoYWRvd1xyXG4gICAgICogc2hhcGUuc2hhZG93RW5hYmxlZChmYWxzZSk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gZW5hYmxlIHNoYWRvd1xyXG4gICAgICogc2hhcGUuc2hhZG93RW5hYmxlZCh0cnVlKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZGFzaEVuYWJsZWQnLCB0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgZGFzaCBlbmFibGVkIGZsYWdcclxuICAgICAqIEBuYW1lIGRhc2hFbmFibGVkXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWRcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBkYXNoIGVuYWJsZWQgZmxhZ1xyXG4gICAgICogdmFyIGRhc2hFbmFibGVkID0gc2hhcGUuZGFzaEVuYWJsZWQoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBkaXNhYmxlIGRhc2hcclxuICAgICAqIHNoYXBlLmRhc2hFbmFibGVkKGZhbHNlKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBlbmFibGUgZGFzaFxyXG4gICAgICogc2hhcGUuZGFzaEVuYWJsZWQodHJ1ZSk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3N0cm9rZVNjYWxlRW5hYmxlZCcsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBzdHJva2VTY2FsZSBlbmFibGVkIGZsYWdcclxuICAgICAqIEBuYW1lIHN0cm9rZVNjYWxlRW5hYmxlZFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgc3Ryb2tlIHNjYWxlIGVuYWJsZWQgZmxhZ1xyXG4gICAgICogdmFyIHN0cm9rZVNjYWxlRW5hYmxlZCA9IHNoYXBlLnN0cm9rZVNjYWxlRW5hYmxlZCgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIGRpc2FibGUgc3Ryb2tlIHNjYWxlXHJcbiAgICAgKiBzaGFwZS5zdHJva2VTY2FsZUVuYWJsZWQoZmFsc2UpO1xyXG4gICAgICpcclxuICAgICAqIC8vIGVuYWJsZSBzdHJva2Ugc2NhbGVcclxuICAgICAqIHNoYXBlLnN0cm9rZVNjYWxlRW5hYmxlZCh0cnVlKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFByaW9yaXR5JywgJ2NvbG9yJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IGZpbGwgcHJpb3JpdHkuICBjYW4gYmUgY29sb3IsIHBhdHRlcm4sIGxpbmVhci1ncmFkaWVudCwgb3IgcmFkaWFsLWdyYWRpZW50LiAgVGhlIGRlZmF1bHQgaXMgY29sb3IuXHJcbiAgICAgKiAgIFRoaXMgaXMgaGFuZHkgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuXHJcbiAgICAgKiBAbmFtZSBmaWxsUHJpb3JpdHlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcmlvcml0eVxyXG4gICAgICogQHJldHVybnMge1N0cmluZ31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgZmlsbCBwcmlvcml0eVxyXG4gICAgICogdmFyIGZpbGxQcmlvcml0eSA9IHNoYXBlLmZpbGxQcmlvcml0eSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBmaWxsIHByaW9yaXR5XHJcbiAgICAgKiBzaGFwZS5maWxsUHJpb3JpdHkoJ2xpbmVhci1ncmFkaWVudCcpO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5PZmZzZXQnLCBbJ3gnLCAneSddKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgZmlsbCBwYXR0ZXJuIG9mZnNldFxyXG4gICAgICogQG5hbWUgZmlsbFBhdHRlcm5PZmZzZXRcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvZmZzZXRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQueFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldC55XHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gb2Zmc2V0XHJcbiAgICAgKiB2YXIgcGF0dGVybk9mZnNldCA9IHNoYXBlLmZpbGxQYXR0ZXJuT2Zmc2V0KCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IGZpbGwgcGF0dGVybiBvZmZzZXRcclxuICAgICAqIHNoYXBlLmZpbGxQYXR0ZXJuT2Zmc2V0KHtcclxuICAgICAqICAgeDogMjBcclxuICAgICAqICAgeTogMTBcclxuICAgICAqIH0pO1xyXG4gICAgICovXHJcblxyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5PZmZzZXRYJywgMCk7XHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgZmlsbCBwYXR0ZXJuIG9mZnNldCB4XHJcbiAgICAgKiBAbmFtZSBmaWxsUGF0dGVybk9mZnNldFhcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gb2Zmc2V0IHhcclxuICAgICAqIHZhciBwYXR0ZXJuT2Zmc2V0WCA9IHNoYXBlLmZpbGxQYXR0ZXJuT2Zmc2V0WCgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBmaWxsIHBhdHRlcm4gb2Zmc2V0IHhcclxuICAgICAqIHNoYXBlLmZpbGxQYXR0ZXJuT2Zmc2V0WCgyMCk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQYXR0ZXJuT2Zmc2V0WScsIDApO1xyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiBvZmZzZXQgeVxyXG4gICAgICogQG5hbWUgZmlsbFBhdHRlcm5PZmZzZXRZXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIG9mZnNldCB5XHJcbiAgICAgKiB2YXIgcGF0dGVybk9mZnNldFkgPSBzaGFwZS5maWxsUGF0dGVybk9mZnNldFkoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgZmlsbCBwYXR0ZXJuIG9mZnNldCB5XHJcbiAgICAgKiBzaGFwZS5maWxsUGF0dGVybk9mZnNldFkoMTApO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5TY2FsZScsIFsneCcsICd5J10pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gc2NhbGVcclxuICAgICAqIEBuYW1lIGZpbGxQYXR0ZXJuU2NhbGVcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY2FsZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlLnhcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZS55XHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gc2NhbGVcclxuICAgICAqIHZhciBwYXR0ZXJuU2NhbGUgPSBzaGFwZS5maWxsUGF0dGVyblNjYWxlKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IGZpbGwgcGF0dGVybiBzY2FsZVxyXG4gICAgICogc2hhcGUuZmlsbFBhdHRlcm5TY2FsZSh7XHJcbiAgICAgKiAgIHg6IDJcclxuICAgICAqICAgeTogMlxyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUGF0dGVyblNjYWxlWCcsIDEpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiBzY2FsZSB4XHJcbiAgICAgKiBAbmFtZSBmaWxsUGF0dGVyblNjYWxlWFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGZpbGwgcGF0dGVybiBzY2FsZSB4XHJcbiAgICAgKiB2YXIgcGF0dGVyblNjYWxlWCA9IHNoYXBlLmZpbGxQYXR0ZXJuU2NhbGVYKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IGZpbGwgcGF0dGVybiBzY2FsZSB4XHJcbiAgICAgKiBzaGFwZS5maWxsUGF0dGVyblNjYWxlWCgyKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5TY2FsZVknLCAxKTtcclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gc2NhbGUgeVxyXG4gICAgICogQG5hbWUgZmlsbFBhdHRlcm5TY2FsZVlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gc2NhbGUgeVxyXG4gICAgICogdmFyIHBhdHRlcm5TY2FsZVkgPSBzaGFwZS5maWxsUGF0dGVyblNjYWxlWSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBmaWxsIHBhdHRlcm4gc2NhbGUgeVxyXG4gICAgICogc2hhcGUuZmlsbFBhdHRlcm5TY2FsZVkoMik7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50JywgWyd4JywgJ3knXSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50XHJcbiAgICAgKiBAbmFtZSBmaWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhcnRQb2ludFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0UG9pbnQueFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0UG9pbnQueVxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnRcclxuICAgICAqIHZhciBzdGFydFBvaW50ID0gc2hhcGUuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludCgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBmaWxsIGxpbmVhciBncmFkaWVudCBzdGFydCBwb2ludFxyXG4gICAgICogc2hhcGUuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludCh7XHJcbiAgICAgKiAgIHg6IDIwXHJcbiAgICAgKiAgIHk6IDEwXHJcbiAgICAgKiB9KTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFgnLCAwKTtcclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBmaWxsIGxpbmVhciBncmFkaWVudCBzdGFydCBwb2ludCB4XHJcbiAgICAgKiBAbmFtZSBmaWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50IHhcclxuICAgICAqIHZhciBzdGFydFBvaW50WCA9IHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50IHhcclxuICAgICAqIHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYKDIwKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFknLCAwKTtcclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBmaWxsIGxpbmVhciBncmFkaWVudCBzdGFydCBwb2ludCB5XHJcbiAgICAgKiBAbmFtZSBmaWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50IHlcclxuICAgICAqIHZhciBzdGFydFBvaW50WSA9IHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50IHlcclxuICAgICAqIHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZKDIwKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50JywgWyd4JywgJ3knXSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludFxyXG4gICAgICogQG5hbWUgZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbmRQb2ludFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZFBvaW50LnhcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRQb2ludC55XHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnRcclxuICAgICAqIHZhciBlbmRQb2ludCA9IHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50KCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludFxyXG4gICAgICogc2hhcGUuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnQoe1xyXG4gICAgICogICB4OiAyMFxyXG4gICAgICogICB5OiAxMFxyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WCcsIDApO1xyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludCB4XHJcbiAgICAgKiBAbmFtZSBmaWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnQgeFxyXG4gICAgICogdmFyIGVuZFBvaW50WCA9IHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WCgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnQgeFxyXG4gICAgICogc2hhcGUuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYKDIwKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZJywgMCk7XHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgZW5kIHBvaW50IHlcclxuICAgICAqIEBuYW1lIGZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludCB5XHJcbiAgICAgKiB2YXIgZW5kUG9pbnRZID0gc2hhcGUuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludCB5XHJcbiAgICAgKiBzaGFwZS5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFkoMjApO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludCcsIFsneCcsICd5J10pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludFxyXG4gICAgICogQG5hbWUgZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXJ0UG9pbnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFBvaW50LnhcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFBvaW50LnlcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHBvaW50XHJcbiAgICAgKiB2YXIgc3RhcnRQb2ludCA9IHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnQoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcG9pbnRcclxuICAgICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnQoe1xyXG4gICAgICogICB4OiAyMFxyXG4gICAgICogICB5OiAxMFxyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYJywgMCk7XHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxyXG4gICAgICogQG5hbWUgZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludCB4XHJcbiAgICAgKiB2YXIgc3RhcnRQb2ludFggPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WCgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludCB4XHJcbiAgICAgKiBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WCgyMCk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZJywgMCk7XHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeVxyXG4gICAgICogQG5hbWUgZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludCB5XHJcbiAgICAgKiB2YXIgc3RhcnRQb2ludFkgPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludCB5XHJcbiAgICAgKiBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WSgyMCk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludCcsIFsneCcsICd5J10pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnRcclxuICAgICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW5kUG9pbnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRQb2ludC54XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kUG9pbnQueVxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgZW5kIHBvaW50XHJcbiAgICAgKiB2YXIgZW5kUG9pbnQgPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludCgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnRcclxuICAgICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50KHtcclxuICAgICAqICAgeDogMjBcclxuICAgICAqICAgeTogMTBcclxuICAgICAqIH0pO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFgnLCAwKTtcclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnQgeFxyXG4gICAgICogQG5hbWUgZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgZW5kIHBvaW50IHhcclxuICAgICAqIHZhciBlbmRQb2ludFggPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFgoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgZW5kIHBvaW50IHhcclxuICAgICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WCgyMCk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WScsIDApO1xyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCBwb2ludCB5XHJcbiAgICAgKiBAbmFtZSBmaWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnQgeVxyXG4gICAgICogdmFyIGVuZFBvaW50WSA9IHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnQgeVxyXG4gICAgICogc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZKDIwKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5Sb3RhdGlvbicsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gcm90YXRpb24gaW4gZGVncmVlc1xyXG4gICAgICogQG5hbWUgZmlsbFBhdHRlcm5Sb3RhdGlvblxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJvdGF0aW9uXHJcbiAgICAgKiBAcmV0dXJucyB7S29udmEuU2hhcGV9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGZpbGwgcGF0dGVybiByb3RhdGlvblxyXG4gICAgICogdmFyIHBhdHRlcm5Sb3RhdGlvbiA9IHNoYXBlLmZpbGxQYXR0ZXJuUm90YXRpb24oKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgZmlsbCBwYXR0ZXJuIHJvdGF0aW9uXHJcbiAgICAgKiBzaGFwZS5maWxsUGF0dGVyblJvdGF0aW9uKDIwKTtcclxuICAgICAqL1xyXG5cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmJhY2tDb21wYXQoS29udmEuU2hhcGUsIHtcclxuICAgICAgICBkYXNoQXJyYXk6ICdkYXNoJyxcclxuICAgICAgICBnZXREYXNoQXJyYXk6ICdnZXREYXNoJyxcclxuICAgICAgICBzZXREYXNoQXJyYXk6ICdnZXREYXNoJyxcclxuXHJcbiAgICAgICAgZHJhd0Z1bmM6ICdzY2VuZUZ1bmMnLFxyXG4gICAgICAgIGdldERyYXdGdW5jOiAnZ2V0U2NlbmVGdW5jJyxcclxuICAgICAgICBzZXREcmF3RnVuYzogJ3NldFNjZW5lRnVuYycsXHJcblxyXG4gICAgICAgIGRyYXdIaXRGdW5jOiAnaGl0RnVuYycsXHJcbiAgICAgICAgZ2V0RHJhd0hpdEZ1bmM6ICdnZXRIaXRGdW5jJyxcclxuICAgICAgICBzZXREcmF3SGl0RnVuYzogJ3NldEhpdEZ1bmMnXHJcbiAgICB9KTtcclxuXHJcbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuU2hhcGUpO1xyXG59KShLb252YSk7XHJcblxuKGZ1bmN0aW9uKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgLy8gQ09OU1RBTlRTXHJcbiAgICB2YXIgU1RBR0UgPSAnU3RhZ2UnLFxyXG4gICAgICAgIFNUUklORyA9ICdzdHJpbmcnLFxyXG4gICAgICAgIFBYID0gJ3B4JyxcclxuXHJcbiAgICAgICAgTU9VU0VPVVQgPSAnbW91c2VvdXQnLFxyXG4gICAgICAgIE1PVVNFTEVBVkUgPSAnbW91c2VsZWF2ZScsXHJcbiAgICAgICAgTU9VU0VPVkVSID0gJ21vdXNlb3ZlcicsXHJcbiAgICAgICAgTU9VU0VFTlRFUiA9ICdtb3VzZWVudGVyJyxcclxuICAgICAgICBNT1VTRU1PVkUgPSAnbW91c2Vtb3ZlJyxcclxuICAgICAgICBNT1VTRURPV04gPSAnbW91c2Vkb3duJyxcclxuICAgICAgICBNT1VTRVVQID0gJ21vdXNldXAnLFxyXG4gICAgICAgIENMSUNLID0gJ2NsaWNrJyxcclxuICAgICAgICBEQkxfQ0xJQ0sgPSAnZGJsY2xpY2snLFxyXG4gICAgICAgIFRPVUNIU1RBUlQgPSAndG91Y2hzdGFydCcsXHJcbiAgICAgICAgVE9VQ0hFTkQgPSAndG91Y2hlbmQnLFxyXG4gICAgICAgIFRBUCA9ICd0YXAnLFxyXG4gICAgICAgIERCTF9UQVAgPSAnZGJsdGFwJyxcclxuICAgICAgICBUT1VDSE1PVkUgPSAndG91Y2htb3ZlJyxcclxuICAgICAgICBET01NT1VTRVNDUk9MTCA9ICdET01Nb3VzZVNjcm9sbCcsXHJcbiAgICAgICAgTU9VU0VXSEVFTCA9ICdtb3VzZXdoZWVsJyxcclxuICAgICAgICBXSEVFTCA9ICd3aGVlbCcsXHJcblxyXG4gICAgICAgIENPTlRFTlRfTU9VU0VPVVQgPSAnY29udGVudE1vdXNlb3V0JyxcclxuICAgICAgICBDT05URU5UX01PVVNFT1ZFUiA9ICdjb250ZW50TW91c2VvdmVyJyxcclxuICAgICAgICBDT05URU5UX01PVVNFTU9WRSA9ICdjb250ZW50TW91c2Vtb3ZlJyxcclxuICAgICAgICBDT05URU5UX01PVVNFRE9XTiA9ICdjb250ZW50TW91c2Vkb3duJyxcclxuICAgICAgICBDT05URU5UX01PVVNFVVAgPSAnY29udGVudE1vdXNldXAnLFxyXG4gICAgICAgIENPTlRFTlRfQ0xJQ0sgPSAnY29udGVudENsaWNrJyxcclxuICAgICAgICBDT05URU5UX0RCTF9DTElDSyA9ICdjb250ZW50RGJsY2xpY2snLFxyXG4gICAgICAgIENPTlRFTlRfVE9VQ0hTVEFSVCA9ICdjb250ZW50VG91Y2hzdGFydCcsXHJcbiAgICAgICAgQ09OVEVOVF9UT1VDSEVORCA9ICdjb250ZW50VG91Y2hlbmQnLFxyXG4gICAgICAgIENPTlRFTlRfREJMX1RBUCA9ICdjb250ZW50RGJsdGFwJyxcclxuICAgICAgICBDT05URU5UX1RPVUNITU9WRSA9ICdjb250ZW50VG91Y2htb3ZlJyxcclxuXHJcbiAgICAgICAgRElWID0gJ2RpdicsXHJcbiAgICAgICAgUkVMQVRJVkUgPSAncmVsYXRpdmUnLFxyXG4gICAgICAgIEtPTlZBX0NPTlRFTlQgPSAna29udmFqcy1jb250ZW50JyxcclxuICAgICAgICBTUEFDRSA9ICcgJyxcclxuICAgICAgICBVTkRFUlNDT1JFID0gJ18nLFxyXG4gICAgICAgIENPTlRBSU5FUiA9ICdjb250YWluZXInLFxyXG4gICAgICAgIEVNUFRZX1NUUklORyA9ICcnLFxyXG4gICAgICAgIEVWRU5UUyA9IFtNT1VTRURPV04sIE1PVVNFTU9WRSwgTU9VU0VVUCwgTU9VU0VPVVQsIFRPVUNIU1RBUlQsIFRPVUNITU9WRSwgVE9VQ0hFTkQsIE1PVVNFT1ZFUiwgRE9NTU9VU0VTQ1JPTEwsIE1PVVNFV0hFRUwsIFdIRUVMXSxcclxuXHJcbiAgICAgICAgLy8gY2FjaGVkIHZhcmlhYmxlc1xyXG4gICAgICAgIGV2ZW50c0xlbmd0aCA9IEVWRU5UUy5sZW5ndGg7XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkRXZlbnQoY3R4LCBldmVudE5hbWUpIHtcclxuICAgICAgICBjdHguY29udGVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgIGN0eFtVTkRFUlNDT1JFICsgZXZlbnROYW1lXShldnQpO1xyXG4gICAgICAgIH0sIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YWdlIGNvbnN0cnVjdG9yLiAgQSBzdGFnZSBpcyB1c2VkIHRvIGNvbnRhaW4gbXVsdGlwbGUgbGF5ZXJzXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxyXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLkNvbnRhaW5lclxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudH0gY29uZmlnLmNvbnRhaW5lciBDb250YWluZXIgaWQgb3IgRE9NIGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogdmFyIHN0YWdlID0gbmV3IEtvbnZhLlN0YWdlKHtcclxuICAgICAgICAgKiAgIHdpZHRoOiA1MDAsXHJcbiAgICAgICAgICogICBoZWlnaHQ6IDgwMCxcclxuICAgICAgICAgKiAgIGNvbnRhaW5lcjogJ2NvbnRhaW5lcklkJ1xyXG4gICAgICAgICAqIH0pO1xyXG4gICAgICovXHJcbiAgICBLb252YS5TdGFnZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xyXG4gICAgfTtcclxuXHJcbiAgICBLb252YS5VdGlsLmFkZE1ldGhvZHMoS29udmEuU3RhZ2UsIHtcclxuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICAgICAgdGhpcy5ub2RlVHlwZSA9IFNUQUdFO1xyXG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgIEtvbnZhLkNvbnRhaW5lci5jYWxsKHRoaXMsIGNvbmZpZyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2lkID0gS29udmEuaWRDb3VudGVyKys7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1aWxkRE9NKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2JpbmRDb250ZW50RXZlbnRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZU5lc3RlZFRyYW5zZm9ybXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgS29udmEuc3RhZ2VzLnB1c2godGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfdmFsaWRhdGVBZGQ6IGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5nZXRUeXBlKCkgIT09ICdMYXllcicpIHtcclxuICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwudGhyb3coJ1lvdSBtYXkgb25seSBhZGQgbGF5ZXJzIHRvIHRoZSBzdGFnZS4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogc2V0IGNvbnRhaW5lciBkb20gZWxlbWVudCB3aGljaCBjb250YWlucyB0aGUgc3RhZ2Ugd3JhcHBlciBkaXYgZWxlbWVudFxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtEb21FbGVtZW50fSBjb250YWluZXIgY2FuIHBhc3MgaW4gYSBkb20gZWxlbWVudCBvciBpZCBzdHJpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRDb250YWluZXI6IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICBpZiggdHlwZW9mIGNvbnRhaW5lciA9PT0gU1RSSU5HKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBjb250YWluZXI7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBLb252YS5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnQ2FuIG5vdCBmaW5kIGNvbnRhaW5lciBpbiBkb2N1bWVudCB3aXRoIGlkICcgKyBpZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zZXRBdHRyKENPTlRBSU5FUiwgY29udGFpbmVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaG91bGREcmF3SGl0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkcmF3OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuZHJhdy5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGRyYXcgbGF5ZXIgc2NlbmUgZ3JhcGhzXHJcbiAgICAgICAgICogQG5hbWUgZHJhd1xyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGRyYXcgbGF5ZXIgaGl0IGdyYXBoc1xyXG4gICAgICAgICAqIEBuYW1lIGRyYXdIaXRcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBzZXQgaGVpZ2h0XHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcclxuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0LmNhbGwodGhpcywgaGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhpcy5fcmVzaXplRE9NKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogc2V0IHdpZHRoXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcclxuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0V2lkdGguY2FsbCh0aGlzLCB3aWR0aCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZURPTSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGNsZWFyIGFsbCBsYXllcnNcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuY2hpbGRyZW4sXHJcbiAgICAgICAgICAgICAgICBsZW4gPSBsYXllcnMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgbjtcclxuXHJcbiAgICAgICAgICAgIGZvcihuID0gMDsgbiA8IGxlbjsgbisrKSB7XHJcbiAgICAgICAgICAgICAgICBsYXllcnNbbl0uY2xlYXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICAgICAgaWYgKCFvYmopIHtcclxuICAgICAgICAgICAgICAgIG9iaiA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9iai5jb250YWluZXIgPSBLb252YS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KERJVik7XHJcbiAgICAgICAgICAgIHJldHVybiBLb252YS5Db250YWluZXIucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcywgb2JqKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGRlc3Ryb3kgc3RhZ2VcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHRoaXMuY29udGVudDtcclxuICAgICAgICAgICAgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcblxyXG4gICAgICAgICAgICBpZihjb250ZW50ICYmIEtvbnZhLlV0aWwuX2lzSW5Eb2N1bWVudChjb250ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRDb250YWluZXIoKS5yZW1vdmVDaGlsZChjb250ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBLb252YS5zdGFnZXMuaW5kZXhPZih0aGlzKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIEtvbnZhLnN0YWdlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBnZXQgcG9pbnRlciBwb3NpdGlvbiB3aGljaCBjYW4gYmUgYSB0b3VjaCBwb3NpdGlvbiBvciBtb3VzZSBwb3NpdGlvblxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRQb2ludGVyUG9zaXRpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb2ludGVyUG9zO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0U3RhZ2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGdldCBzdGFnZSBjb250ZW50IGRpdiBlbGVtZW50IHdoaWNoIGhhcyB0aGVcclxuICAgICAgICAgKiAgdGhlIGNsYXNzIG5hbWUgXCJrb252YWpzLWNvbnRlbnRcIlxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0Q29udGVudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgY29tcG9zaXRlIGRhdGEgVVJMXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5jYWxsYmFja10gZnVuY3Rpb24gZXhlY3V0ZWQgd2hlbiB0aGUgY29tcG9zaXRlIGhhcyBjb21wbGV0ZWQuIERlcHJlY2F0ZWQgYXMgbWV0aG9kIGlzIHN5bmMgbm93LlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm1pbWVUeXBlXSBjYW4gYmUgXCJpbWFnZS9wbmdcIiBvciBcImltYWdlL2pwZWdcIi5cclxuICAgICAgICAgKiAgXCJpbWFnZS9wbmdcIiBpcyB0aGUgZGVmYXVsdFxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdIHggcG9zaXRpb24gb2YgY2FudmFzIHNlY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XSB5IHBvc2l0aW9uIG9mIGNhbnZhcyBzZWN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdIHdpZHRoIG9mIGNhbnZhcyBzZWN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XSBoZWlnaHQgb2YgY2FudmFzIHNlY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5xdWFsaXR5XSBqcGVnIHF1YWxpdHkuICBJZiB1c2luZyBhbiBcImltYWdlL2pwZWdcIiBtaW1lVHlwZSxcclxuICAgICAgICAgKiAgeW91IGNhbiBzcGVjaWZ5IHRoZSBxdWFsaXR5IGZyb20gMCB0byAxLCB3aGVyZSAwIGlzIHZlcnkgcG9vciBxdWFsaXR5IGFuZCAxXHJcbiAgICAgICAgICogIGlzIHZlcnkgaGlnaCBxdWFsaXR5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdG9EYXRhVVJMOiBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgdmFyIG1pbWVUeXBlID0gY29uZmlnLm1pbWVUeXBlIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICBxdWFsaXR5ID0gY29uZmlnLnF1YWxpdHkgfHwgbnVsbCxcclxuICAgICAgICAgICAgICAgIHggPSBjb25maWcueCB8fCAwLFxyXG4gICAgICAgICAgICAgICAgeSA9IGNvbmZpZy55IHx8IDAsXHJcbiAgICAgICAgICAgICAgICBjYW52YXMgPSBuZXcgS29udmEuU2NlbmVDYW52YXMoe1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb25maWcud2lkdGggfHwgdGhpcy5nZXRXaWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogY29uZmlnLmhlaWdodCB8fCB0aGlzLmdldEhlaWdodCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHBpeGVsUmF0aW86IGNvbmZpZy5waXhlbFJhdGlvXHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgIF9jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoKS5fY29udGV4dCxcclxuICAgICAgICAgICAgICAgIGxheWVycyA9IHRoaXMuY2hpbGRyZW47XHJcblxyXG4gICAgICAgICAgICBpZih4IHx8IHkpIHtcclxuICAgICAgICAgICAgICAgIF9jb250ZXh0LnRyYW5zbGF0ZSgtMSAqIHgsIC0xICogeSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBsYXllcnMuZWFjaChmdW5jdGlvbihsYXllcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gbGF5ZXIuZ2V0Q2FudmFzKCkuZ2V0V2lkdGgoKTtcclxuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBsYXllci5nZXRDYW52YXMoKS5nZXRIZWlnaHQoKTtcclxuICAgICAgICAgICAgICAgIHZhciByYXRpbyA9IGxheWVyLmdldENhbnZhcygpLmdldFBpeGVsUmF0aW8oKTtcclxuICAgICAgICAgICAgICAgIF9jb250ZXh0LmRyYXdJbWFnZShsYXllci5nZXRDYW52YXMoKS5fY2FudmFzLCAwLCAwLCB3aWR0aCAvIHJhdGlvLCBoZWlnaHQgLyByYXRpbyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgc3JjID0gY2FudmFzLnRvRGF0YVVSTChtaW1lVHlwZSwgcXVhbGl0eSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWcuY2FsbGJhY2soc3JjKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNyYztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGNvbnZlcnRzIHN0YWdlIGludG8gYW4gaW1hZ2UuXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZmlnLmNhbGxiYWNrIGZ1bmN0aW9uIGV4ZWN1dGVkIHdoZW4gdGhlIGNvbXBvc2l0ZSBoYXMgY29tcGxldGVkXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubWltZVR5cGVdIGNhbiBiZSBcImltYWdlL3BuZ1wiIG9yIFwiaW1hZ2UvanBlZ1wiLlxyXG4gICAgICAgICAqICBcImltYWdlL3BuZ1wiIGlzIHRoZSBkZWZhdWx0XHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF0geCBwb3NpdGlvbiBvZiBjYW52YXMgc2VjdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldIHkgcG9zaXRpb24gb2YgY2FudmFzIHNlY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF0gd2lkdGggb2YgY2FudmFzIHNlY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdIGhlaWdodCBvZiBjYW52YXMgc2VjdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnF1YWxpdHldIGpwZWcgcXVhbGl0eS4gIElmIHVzaW5nIGFuIFwiaW1hZ2UvanBlZ1wiIG1pbWVUeXBlLFxyXG4gICAgICAgICAqICB5b3UgY2FuIHNwZWNpZnkgdGhlIHF1YWxpdHkgZnJvbSAwIHRvIDEsIHdoZXJlIDAgaXMgdmVyeSBwb29yIHF1YWxpdHkgYW5kIDFcclxuICAgICAgICAgKiAgaXMgdmVyeSBoaWdoIHF1YWxpdHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0b0ltYWdlOiBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICAgICAgdmFyIGNiID0gY29uZmlnLmNhbGxiYWNrO1xyXG5cclxuICAgICAgICAgICAgY29uZmlnLmNhbGxiYWNrID0gZnVuY3Rpb24oZGF0YVVybCkge1xyXG4gICAgICAgICAgICAgICAgS29udmEuVXRpbC5fZ2V0SW1hZ2UoZGF0YVVybCwgZnVuY3Rpb24oaW1nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2IoaW1nKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnRvRGF0YVVSTChjb25maWcpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogZ2V0IHZpc2libGUgaW50ZXJzZWN0aW9uIHNoYXBlLiBUaGlzIGlzIHRoZSBwcmVmZXJyZWRcclxuICAgICAgICAgKiAgbWV0aG9kIGZvciBkZXRlcm1pbmluZyBpZiBhIHBvaW50IGludGVyc2VjdHMgYSBzaGFwZSBvciBub3RcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb3NcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zLnhcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zLnlcclxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuU2hhcGV9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0SW50ZXJzZWN0aW9uOiBmdW5jdGlvbihwb3MpIHtcclxuICAgICAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuZ2V0Q2hpbGRyZW4oKSxcclxuICAgICAgICAgICAgICAgIGxlbiA9IGxheWVycy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBlbmQgPSBsZW4gLSAxLFxyXG4gICAgICAgICAgICAgICAgbiwgc2hhcGU7XHJcblxyXG4gICAgICAgICAgICBmb3IobiA9IGVuZDsgbiA+PSAwOyBuLS0pIHtcclxuICAgICAgICAgICAgICAgIHNoYXBlID0gbGF5ZXJzW25dLmdldEludGVyc2VjdGlvbihwb3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9yZXNpemVET006IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZih0aGlzLmNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGxheWVycyA9IHRoaXMuZ2V0Q2hpbGRyZW4oKSxcclxuICAgICAgICAgICAgICAgICAgICBsZW4gPSBsYXllcnMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIG4sIGxheWVyO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHNldCBjb250ZW50IGRpbWVuc2lvbnNcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5zdHlsZS53aWR0aCA9IHdpZHRoICsgUFg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgUFg7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXJDYW52YXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVySGl0Q2FudmFzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc2V0IGxheWVyIGRpbWVuc2lvbnNcclxuICAgICAgICAgICAgICAgIGZvcihuID0gMDsgbiA8IGxlbjsgbisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIgPSBsYXllcnNbbl07XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBsYXllci5kcmF3KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGFkZCBsYXllciBvciBsYXllcnMgdG8gc3RhZ2VcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7Li4uS29udmEuTGF5ZXJ9IGxheWVyXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiBzdGFnZS5hZGQobGF5ZXIxLCBsYXllcjIsIGxheWVyMyk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWRkOiBmdW5jdGlvbihsYXllcikge1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoYXJndW1lbnRzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgbGF5ZXIpO1xyXG4gICAgICAgICAgICBsYXllci5fc2V0Q2FudmFzU2l6ZSh0aGlzLndpZHRoKCksIHRoaXMuaGVpZ2h0KCkpO1xyXG5cclxuICAgICAgICAgICAgLy8gZHJhdyBsYXllciBhbmQgYXBwZW5kIGNhbnZhcyB0byBjb250YWluZXJcclxuICAgICAgICAgICAgbGF5ZXIuZHJhdygpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuYXBwZW5kQ2hpbGQobGF5ZXIuY2FudmFzLl9jYW52YXMpO1xyXG5cclxuICAgICAgICAgICAgLy8gY2hhaW5hYmxlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0UGFyZW50OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRMYXllcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogcmV0dXJucyBhIHtAbGluayBLb252YS5Db2xsZWN0aW9ufSBvZiBsYXllcnNcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldExheWVyczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENoaWxkcmVuKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfYmluZENvbnRlbnRFdmVudHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGV2ZW50c0xlbmd0aDsgbisrKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRFdmVudCh0aGlzLCBFVkVOVFNbbl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfbW91c2VvdmVyOiBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICAgICAgaWYgKCFLb252YS5VQS5tb2JpbGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFBvaW50ZXJQb3NpdGlvbihldnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX01PVVNFT1ZFUiwge2V2dDogZXZ0fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9tb3VzZW91dDogZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgIGlmICghS29udmEuVUEubW9iaWxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRTaGFwZSA9IHRoaXMudGFyZ2V0U2hhcGU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYodGFyZ2V0U2hhcGUgJiYgIUtvbnZhLmlzRHJhZ2dpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFNoYXBlLl9maXJlQW5kQnViYmxlKE1PVVNFT1VULCB7ZXZ0OiBldnR9KTtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRTaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRUxFQVZFLCB7ZXZ0OiBldnR9KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFNoYXBlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlclBvcyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlKENPTlRFTlRfTU9VU0VPVVQsIHtldnQ6IGV2dH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfbW91c2Vtb3ZlOiBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgbW9iaWxlIElFIHRvIGZvcmNlIHRvdWNoIGV2ZW50IHdoZW4gdW5oYW5kbGVkIHBvaW50ZXIgZXZlbnQgZWxldmF0ZXMgaW50byBhIG1vdXNlIGV2ZW50XHJcbiAgICAgICAgICAgIGlmIChLb252YS5VQS5pZU1vYmlsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvdWNobW92ZShldnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHdvcmthcm91bmQgZmFrZSBtb3VzZW1vdmUgZXZlbnQgaW4gY2hyb21lIGJyb3dzZXIgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTE2MTQ2NFxyXG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBldnQubW92ZW1lbnRYICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZXZ0Lm1vdmVtZW50WSAhPT0gJ3VuZGVmaW5lZCcpICYmIGV2dC5tb3ZlbWVudFkgPT09IDAgJiYgZXZ0Lm1vdmVtZW50WCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKEtvbnZhLlVBLm1vYmlsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZTtcclxuXHJcbiAgICAgICAgICAgIGlmICghS29udmEuaXNEcmFnZ2luZygpKSB7XHJcbiAgICAgICAgICAgICAgICBzaGFwZSA9IHRoaXMuZ2V0SW50ZXJzZWN0aW9uKHRoaXMuZ2V0UG9pbnRlclBvc2l0aW9uKCkpO1xyXG4gICAgICAgICAgICAgICAgaWYoc2hhcGUgJiYgc2hhcGUuaXNMaXN0ZW5pbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFLb252YS5pc0RyYWdnaW5nKCkgJiYgKCF0aGlzLnRhcmdldFNoYXBlIHx8IHRoaXMudGFyZ2V0U2hhcGUuX2lkICE9PSBzaGFwZS5faWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMudGFyZ2V0U2hhcGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0U2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VPVVQsIHtldnQ6IGV2dH0sIHNoYXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0U2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VMRUFWRSwge2V2dDogZXZ0fSwgc2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKE1PVVNFT1ZFUiwge2V2dDogZXZ0fSwgdGhpcy50YXJnZXRTaGFwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKE1PVVNFRU5URVIsIHtldnQ6IGV2dH0sIHRoaXMudGFyZ2V0U2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFNoYXBlID0gc2hhcGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRU1PVkUsIHtldnQ6IGV2dH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBpZiBubyBzaGFwZSB3YXMgZGV0ZWN0ZWQsIGNsZWFyIHRhcmdldCBzaGFwZSBhbmQgdHJ5XHJcbiAgICAgICAgICAgICAgICAgKiB0byBydW4gbW91c2VvdXQgZnJvbSBwcmV2aW91cyB0YXJnZXQgc2hhcGVcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy50YXJnZXRTaGFwZSAmJiAhS29udmEuaXNEcmFnZ2luZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0U2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VPVVQsIHtldnQ6IGV2dH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFNoYXBlLl9maXJlQW5kQnViYmxlKE1PVVNFTEVBVkUsIHtldnQ6IGV2dH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFNoYXBlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNvbnRlbnQgZXZlbnRcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9NT1VTRU1PVkUsIHtldnQ6IGV2dH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBhbHdheXMgY2FsbCBwcmV2ZW50RGVmYXVsdCBmb3IgZGVza3RvcCBldmVudHMgYmVjYXVzZSBzb21lIGJyb3dzZXJzXHJcbiAgICAgICAgICAgIC8vIHRyeSB0byBkcmFnIGFuZCBkcm9wIHRoZSBjYW52YXMgZWxlbWVudFxyXG4gICAgICAgICAgICBpZiAoZXZ0LnByZXZlbnREZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX21vdXNlZG93bjogZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgIC8vIHdvcmthcm91bmQgZm9yIG1vYmlsZSBJRSB0byBmb3JjZSB0b3VjaCBldmVudCB3aGVuIHVuaGFuZGxlZCBwb2ludGVyIGV2ZW50IGVsZXZhdGVzIGludG8gYSBtb3VzZSBldmVudFxyXG4gICAgICAgICAgICBpZiAoS29udmEuVUEuaWVNb2JpbGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90b3VjaHN0YXJ0KGV2dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFLb252YS5VQS5tb2JpbGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFBvaW50ZXJQb3NpdGlvbihldnQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5nZXRJbnRlcnNlY3Rpb24odGhpcy5nZXRQb2ludGVyUG9zaXRpb24oKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgS29udmEubGlzdGVuQ2xpY2tUYXAgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5pc0xpc3RlbmluZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGlja1N0YXJ0U2hhcGUgPSBzaGFwZTtcclxuICAgICAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRURPV04sIHtldnQ6IGV2dH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNvbnRlbnQgZXZlbnRcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9NT1VTRURPV04sIHtldnQ6IGV2dH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBhbHdheXMgY2FsbCBwcmV2ZW50RGVmYXVsdCBmb3IgZGVza3RvcCBldmVudHMgYmVjYXVzZSBzb21lIGJyb3dzZXJzXHJcbiAgICAgICAgICAgIC8vIHRyeSB0byBkcmFnIGFuZCBkcm9wIHRoZSBjYW52YXMgZWxlbWVudFxyXG4gICAgICAgICAgICBpZiAoZXZ0LnByZXZlbnREZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX21vdXNldXA6IGZ1bmN0aW9uKGV2dCkge1xyXG5cclxuICAgICAgICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgbW9iaWxlIElFIHRvIGZvcmNlIHRvdWNoIGV2ZW50IHdoZW4gdW5oYW5kbGVkIHBvaW50ZXIgZXZlbnQgZWxldmF0ZXMgaW50byBhIG1vdXNlIGV2ZW50XHJcbiAgICAgICAgICAgIGlmIChLb252YS5VQS5pZU1vYmlsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvdWNoZW5kKGV2dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFLb252YS5VQS5tb2JpbGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFBvaW50ZXJQb3NpdGlvbihldnQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5nZXRJbnRlcnNlY3Rpb24odGhpcy5nZXRQb2ludGVyUG9zaXRpb24oKSksXHJcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tTdGFydFNoYXBlID0gdGhpcy5jbGlja1N0YXJ0U2hhcGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlyZURibENsaWNrID0gZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgZGQgPSBLb252YS5ERDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihLb252YS5pbkRibENsaWNrV2luZG93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyZURibENsaWNrID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBLb252YS5pbkRibENsaWNrV2luZG93ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBzZXQgaW5EYmxDbGlja1dpbmRvdyBhZnRlciBkcmFnZ2luZ1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWRkIHx8ICFkZC5qdXN0RHJhZ2dlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIEtvbnZhLmluRGJsQ2xpY2tXaW5kb3cgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRkLmp1c3REcmFnZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBLb252YS5pbkRibENsaWNrV2luZG93ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9LCBLb252YS5kYmxDbGlja1dpbmRvdyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLmlzTGlzdGVuaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRVVQLCB7ZXZ0OiBldnR9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGV0ZWN0IGlmIGNsaWNrIG9yIGRvdWJsZSBjbGljayBvY2N1cnJlZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKEtvbnZhLmxpc3RlbkNsaWNrVGFwICYmIGNsaWNrU3RhcnRTaGFwZSAmJiBjbGlja1N0YXJ0U2hhcGUuX2lkID09PSBzaGFwZS5faWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoQ0xJQ0ssIHtldnQ6IGV2dH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZmlyZURibENsaWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShEQkxfQ0xJQ0ssIHtldnQ6IGV2dH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY29udGVudCBldmVudHNcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9NT1VTRVVQLCB7ZXZ0OiBldnR9KTtcclxuICAgICAgICAgICAgICAgIGlmIChLb252YS5saXN0ZW5DbGlja1RhcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9DTElDSywge2V2dDogZXZ0fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZmlyZURibENsaWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9EQkxfQ0xJQ0ssIHtldnQ6IGV2dH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBLb252YS5saXN0ZW5DbGlja1RhcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBhbHdheXMgY2FsbCBwcmV2ZW50RGVmYXVsdCBmb3IgZGVza3RvcCBldmVudHMgYmVjYXVzZSBzb21lIGJyb3dzZXJzXHJcbiAgICAgICAgICAgIC8vIHRyeSB0byBkcmFnIGFuZCBkcm9wIHRoZSBjYW52YXMgZWxlbWVudFxyXG4gICAgICAgICAgICBpZiAoZXZ0LnByZXZlbnREZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3RvdWNoc3RhcnQ6IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5nZXRJbnRlcnNlY3Rpb24odGhpcy5nZXRQb2ludGVyUG9zaXRpb24oKSk7XHJcblxyXG4gICAgICAgICAgICBLb252YS5saXN0ZW5DbGlja1RhcCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2hhcGUgJiYgc2hhcGUuaXNMaXN0ZW5pbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50YXBTdGFydFNoYXBlID0gc2hhcGU7XHJcbiAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShUT1VDSFNUQVJULCB7ZXZ0OiBldnR9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGNhbGwgcHJldmVudERlZmF1bHQgaWYgdGhlIHNoYXBlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUuaXNMaXN0ZW5pbmcoKSAmJiBldnQucHJldmVudERlZmF1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjb250ZW50IGV2ZW50XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9UT1VDSFNUQVJULCB7ZXZ0OiBldnR9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF90b3VjaGVuZDogZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldFBvaW50ZXJQb3NpdGlvbihldnQpO1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLmdldEludGVyc2VjdGlvbih0aGlzLmdldFBvaW50ZXJQb3NpdGlvbigpKSxcclxuICAgICAgICAgICAgICAgIGZpcmVEYmxDbGljayA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYoS29udmEuaW5EYmxDbGlja1dpbmRvdykge1xyXG4gICAgICAgICAgICAgICAgZmlyZURibENsaWNrID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIEtvbnZhLmluRGJsQ2xpY2tXaW5kb3cgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIEtvbnZhLmluRGJsQ2xpY2tXaW5kb3cgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgS29udmEuaW5EYmxDbGlja1dpbmRvdyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9LCBLb252YS5kYmxDbGlja1dpbmRvdyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2hhcGUgJiYgc2hhcGUuaXNMaXN0ZW5pbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoVE9VQ0hFTkQsIHtldnQ6IGV2dH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGRldGVjdCBpZiB0YXAgb3IgZG91YmxlIHRhcCBvY2N1cnJlZFxyXG4gICAgICAgICAgICAgICAgaWYoS29udmEubGlzdGVuQ2xpY2tUYXAgJiYgc2hhcGUuX2lkID09PSB0aGlzLnRhcFN0YXJ0U2hhcGUuX2lkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoVEFQLCB7ZXZ0OiBldnR9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZmlyZURibENsaWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKERCTF9UQVAsIHtldnQ6IGV2dH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgY2FsbCBwcmV2ZW50RGVmYXVsdCBpZiB0aGUgc2hhcGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZS5pc0xpc3RlbmluZygpICYmIGV2dC5wcmV2ZW50RGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNvbnRlbnQgZXZlbnRzXHJcbiAgICAgICAgICAgIGlmIChLb252YS5saXN0ZW5DbGlja1RhcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX1RPVUNIRU5ELCB7ZXZ0OiBldnR9KTtcclxuICAgICAgICAgICAgICAgIGlmKGZpcmVEYmxDbGljaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9EQkxfVEFQLCB7ZXZ0OiBldnR9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgS29udmEubGlzdGVuQ2xpY2tUYXAgPSBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF90b3VjaG1vdmU6IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcclxuICAgICAgICAgICAgdmFyIGRkID0gS29udmEuREQsXHJcbiAgICAgICAgICAgICAgICBzaGFwZTtcclxuICAgICAgICAgICAgaWYgKCFLb252YS5pc0RyYWdnaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgIHNoYXBlID0gdGhpcy5nZXRJbnRlcnNlY3Rpb24odGhpcy5nZXRQb2ludGVyUG9zaXRpb24oKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUgJiYgc2hhcGUuaXNMaXN0ZW5pbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKFRPVUNITU9WRSwge2V2dDogZXZ0fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBjYWxsIHByZXZlbnREZWZhdWx0IGlmIHRoZSBzaGFwZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaGFwZS5pc0xpc3RlbmluZygpICYmIGV2dC5wcmV2ZW50RGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlKENPTlRFTlRfVE9VQ0hNT1ZFLCB7ZXZ0OiBldnR9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihkZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKEtvbnZhLmlzRHJhZ2dpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfRE9NTW91c2VTY3JvbGw6IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgICAgICB0aGlzLl9tb3VzZXdoZWVsKGV2dCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfbW91c2V3aGVlbDogZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldFBvaW50ZXJQb3NpdGlvbihldnQpO1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLmdldEludGVyc2VjdGlvbih0aGlzLmdldFBvaW50ZXJQb3NpdGlvbigpKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5pc0xpc3RlbmluZygpKSB7XHJcbiAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRVdIRUVMLCB7ZXZ0OiBldnR9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3doZWVsOiBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fbW91c2V3aGVlbChldnQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3NldFBvaW50ZXJQb3NpdGlvbjogZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgIHZhciBjb250ZW50UG9zaXRpb24gPSB0aGlzLl9nZXRDb250ZW50UG9zaXRpb24oKSxcclxuICAgICAgICAgICAgICAgIHggPSBudWxsLFxyXG4gICAgICAgICAgICAgICAgeSA9IG51bGw7XHJcbiAgICAgICAgICAgIGV2dCA9IGV2dCA/IGV2dCA6IHdpbmRvdy5ldmVudDtcclxuXHJcbiAgICAgICAgICAgIC8vIHRvdWNoIGV2ZW50c1xyXG4gICAgICAgICAgICBpZihldnQudG91Y2hlcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50bHksIG9ubHkgaGFuZGxlIG9uZSBmaW5nZXJcclxuICAgICAgICAgICAgICAgIGlmIChldnQudG91Y2hlcy5sZW5ndGggPiAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3VjaCA9IGV2dC50b3VjaGVzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgaW5mb3JtYXRpb24gZm9yIGZpbmdlciAjMVxyXG4gICAgICAgICAgICAgICAgICAgIHggPSB0b3VjaC5jbGllbnRYIC0gY29udGVudFBvc2l0aW9uLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IHRvdWNoLmNsaWVudFkgLSBjb250ZW50UG9zaXRpb24udG9wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG1vdXNlIGV2ZW50c1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICghY29udGVudFBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IGV2dC5vZmZzZXRYO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBldnQub2ZmZXRZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gd2UgdW5mb3J0dW5hdGVseSBoYXZlIHRvIHVzZSBVQSBkZXRlY3Rpb24gaGVyZSBiZWNhdXNlIGFjY2Vzc2luZ1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGxheWVyWCBvciBsYXllclkgcHJvcGVydGllcyBpbiBuZXdlciB2ZXJzaW9ucyBvZiBDaHJvbWVcclxuICAgICAgICAgICAgICAgIC8vIHRocm93cyBhIEpTIHdhcm5pbmcuICBsYXllclggYW5kIGxheWVyWSBhcmUgcmVxdWlyZWQgZm9yIEZGXHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBjb250YWluZXIgaXMgdHJhbnNmb3JtZWQgdmlhIENTUy5cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEtvbnZhLlVBLmJyb3dzZXIgPT09ICdtb3ppbGxhJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSBldnQubGF5ZXJYIHx8IChldnQuY2xpZW50WCAtIGNvbnRlbnRQb3NpdGlvbi5sZWZ0KTtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gZXZ0LmxheWVyWSB8fCAoZXZ0LmNsaWVudFkgLSBjb250ZW50UG9zaXRpb24udG9wKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IGV2dC5jbGllbnRYIC0gY29udGVudFBvc2l0aW9uLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IGV2dC5jbGllbnRZIC0gY29udGVudFBvc2l0aW9uLnRvcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHggIT09IG51bGwgJiYgeSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyUG9zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogeVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldENvbnRlbnRQb3NpdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5jb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA/IHRoaXMuY29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IHsgdG9wOiAwLCBsZWZ0OiAwIH07XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0b3A6IHJlY3QudG9wLFxyXG4gICAgICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfYnVpbGRET006IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXRDb250YWluZXIoKTtcclxuICAgICAgICAgICAgaWYgKCFjb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChLb252YS5VdGlsLmlzQnJvd3NlcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ1N0YWdlIGhhcyBubyBjb250YWluZXIuIEEgY29udGFpbmVyIGlzIHJlcXVpcmVkLic7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgY3JlYXRlIGVsZW1lbnQgZm9yIGpzZG9tIGluIG5vZGVqcyBlbnZcclxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIgPSBLb252YS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KERJVik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY2xlYXIgY29udGVudCBpbnNpZGUgY29udGFpbmVyXHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBFTVBUWV9TVFJJTkc7XHJcblxyXG4gICAgICAgICAgICAvLyBjb250ZW50XHJcbiAgICAgICAgICAgIHRoaXMuY29udGVudCA9IEtvbnZhLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoRElWKTtcclxuICAgICAgICAgICAgdGhpcy5jb250ZW50LnN0eWxlLnBvc2l0aW9uID0gUkVMQVRJVkU7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5jbGFzc05hbWUgPSBLT05WQV9DT05URU5UO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xyXG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIHRoZSBidWZmZXIgY2FudmFzIHBpeGVsIHJhdGlvIG11c3QgYmUgMSBiZWNhdXNlIGl0IGlzIHVzZWQgYXMgYW5cclxuICAgICAgICAgICAgLy8gaW50ZXJtZWRpYXRlIGNhbnZhcyBiZWZvcmUgY29weWluZyB0aGUgcmVzdWx0IG9udG8gYSBzY2VuZSBjYW52YXMuXHJcbiAgICAgICAgICAgIC8vIG5vdCBzZXR0aW5nIGl0IHRvIDEgd2lsbCByZXN1bHQgaW4gYW4gb3ZlciBjb21wZW5zYXRpb25cclxuICAgICAgICAgICAgdGhpcy5idWZmZXJDYW52YXMgPSBuZXcgS29udmEuU2NlbmVDYW52YXMoe1xyXG4gICAgICAgICAgICAgICAgcGl4ZWxSYXRpbzogMVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXJIaXRDYW52YXMgPSBuZXcgS29udmEuSGl0Q2FudmFzKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9yZXNpemVET00oKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9vbkNvbnRlbnQ6IGZ1bmN0aW9uKHR5cGVzU3RyLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHZhciB0eXBlcyA9IHR5cGVzU3RyLnNwbGl0KFNQQUNFKSxcclxuICAgICAgICAgICAgICAgIGxlbiA9IHR5cGVzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIG4sIGJhc2VFdmVudDtcclxuXHJcbiAgICAgICAgICAgIGZvcihuID0gMDsgbiA8IGxlbjsgbisrKSB7XHJcbiAgICAgICAgICAgICAgICBiYXNlRXZlbnQgPSB0eXBlc1tuXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5hZGRFdmVudExpc3RlbmVyKGJhc2VFdmVudCwgaGFuZGxlciwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBjdXJyZW50bHkgY2FjaGUgZnVuY3Rpb24gaXMgbm93IHdvcmtpbmcgZm9yIHN0YWdlLCBiZWNhdXNlIHN0YWdlIGhhcyBubyBpdHMgb3duIGNhbnZhcyBlbGVtZW50XHJcbiAgICAgICAgLy8gVE9ETzogbWF5IGJlIGl0IGlzIGJldHRlciB0byBjYWNoZSBhbGwgY2hpbGRyZW4gbGF5ZXJzP1xyXG4gICAgICAgIGNhY2hlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdDYWNoZSBmdW5jdGlvbiBpcyBub3QgYWxsb3dlZCBmb3Igc3RhZ2UuIFlvdSBtYXkgdXNlIGNhY2hlIG9ubHkgZm9yIGxheWVycywgZ3JvdXBzIGFuZCBzaGFwZXMuJyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbGVhckNhY2hlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlN0YWdlLCBLb252YS5Db250YWluZXIpO1xyXG5cclxuICAgIC8vIGFkZCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlcihLb252YS5TdGFnZSwgJ2NvbnRhaW5lcicpO1xyXG4gICAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLlN0YWdlLCAnY29udGFpbmVyJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQgY29udGFpbmVyIERPTSBlbGVtZW50XHJcbiAgICAgKiBAbmFtZSBjb250YWluZXJcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcclxuICAgICAqIEByZXR1cm5zIHtEb21FbGVtZW50fSBjb250YWluZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgY29udGFpbmVyXHJcbiAgICAgKiB2YXIgY29udGFpbmVyID0gc3RhZ2UuY29udGFpbmVyKCk7XHJcbiAgICAgKiAvLyBzZXQgY29udGFpbmVyXHJcbiAgICAgKiB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgKiBib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XHJcbiAgICAgKiBzdGFnZS5jb250YWluZXIoY29udGFpbmVyKTtcclxuICAgICAqL1xyXG5cclxufSkoKTtcclxuXG4oZnVuY3Rpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICAvKipcclxuICAgICAqIEJhc2VMYXllciBjb25zdHJ1Y3Rvci5cclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXHJcbiAgICAgKiBAYXVnbWVudHMgS29udmEuQ29udGFpbmVyXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuY2xlYXJCZWZvcmVEcmF3XSBzZXQgdGhpcyBwcm9wZXJ0eSB0byBmYWxzZSBpZiB5b3UgZG9uJ3Qgd2FudFxyXG4gICAgICogdG8gY2xlYXIgdGhlIGNhbnZhcyBiZWZvcmUgZWFjaCBsYXllciBkcmF3LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXHJcbiAgICAgKiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmNsaXBdIHNldCBjbGlwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFhdIHNldCBjbGlwIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWV0gc2V0IGNsaXAgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBXaWR0aF0gc2V0IGNsaXAgd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwSGVpZ2h0XSBzZXQgY2xpcCBoZWlnaHRcblxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHZhciBsYXllciA9IG5ldyBLb252YS5MYXllcigpO1xyXG4gICAgICovXHJcbiAgICBLb252YS5CYXNlTGF5ZXIgPSBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcclxuICAgIH07XHJcblxyXG4gICAgS29udmEuVXRpbC5hZGRNZXRob2RzKEtvbnZhLkJhc2VMYXllciwge1xyXG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgICAgICAgICB0aGlzLm5vZGVUeXBlID0gJ0xheWVyJztcclxuICAgICAgICAgICAgS29udmEuQ29udGFpbmVyLmNhbGwodGhpcywgY29uZmlnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNyZWF0ZVBOR1N0cmVhbTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5fY2FudmFzLmNyZWF0ZVBOR1N0cmVhbSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogZ2V0IGxheWVyIGNhbnZhc1xyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQmFzZUxheWVyLnByb3RvdHlwZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldENhbnZhczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbnZhcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGdldCBsYXllciBoaXQgY2FudmFzXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0SGl0Q2FudmFzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGl0Q2FudmFzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogZ2V0IGxheWVyIGNhbnZhcyBjb250ZXh0XHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0Q29udGV4dDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENhbnZhcygpLmdldENvbnRleHQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGNsZWFyIHNjZW5lIGFuZCBoaXQgY2FudmFzIGNvbnRleHRzIHRpZWQgdG8gdGhlIGxheWVyXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtib3VuZHNdXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMueF1cclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2JvdW5kcy55XVxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbYm91bmRzLndpZHRoXVxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbYm91bmRzLmhlaWdodF1cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqIGxheWVyLmNsZWFyKCk7XHJcbiAgICAgICAgICogbGF5ZXIuY2xlYXIoe1xyXG4gICAgICAgICAqICAgeCA6IDAsXHJcbiAgICAgICAgICogICB5IDogMCxcclxuICAgICAgICAgKiAgIHdpZHRoIDogMTAwLFxyXG4gICAgICAgICAqICAgaGVpZ2h0IDogMTAwXHJcbiAgICAgICAgICogfSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uKGJvdW5kcykge1xyXG4gICAgICAgICAgICB0aGlzLmdldENvbnRleHQoKS5jbGVhcihib3VuZHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsZWFySGl0Q2FjaGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9oaXRJbWFnZURhdGEgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBleHRlbmQgTm9kZS5wcm90b3R5cGUuc2V0WkluZGV4XHJcbiAgICAgICAgc2V0WkluZGV4OiBmdW5jdGlvbihpbmRleCkge1xyXG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRaSW5kZXguY2FsbCh0aGlzLCBpbmRleCk7XHJcbiAgICAgICAgICAgIHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKTtcclxuICAgICAgICAgICAgaWYoc3RhZ2UpIHtcclxuICAgICAgICAgICAgICAgIHN0YWdlLmNvbnRlbnQucmVtb3ZlQ2hpbGQodGhpcy5nZXRDYW52YXMoKS5fY2FudmFzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihpbmRleCA8IHN0YWdlLmdldENoaWxkcmVuKCkubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWdlLmNvbnRlbnQuaW5zZXJ0QmVmb3JlKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcywgc3RhZ2UuZ2V0Q2hpbGRyZW4oKVtpbmRleCArIDFdLmdldENhbnZhcygpLl9jYW52YXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhZ2UuY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmdldENhbnZhcygpLl9jYW52YXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gZXh0ZW5kIE5vZGUucHJvdG90eXBlLm1vdmVUb1RvcFxyXG4gICAgICAgIG1vdmVUb1RvcDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLm1vdmVUb1RvcC5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB2YXIgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCk7XHJcbiAgICAgICAgICAgIGlmKHN0YWdlKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFnZS5jb250ZW50LnJlbW92ZUNoaWxkKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XHJcbiAgICAgICAgICAgICAgICBzdGFnZS5jb250ZW50LmFwcGVuZENoaWxkKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIGV4dGVuZCBOb2RlLnByb3RvdHlwZS5tb3ZlVXBcclxuICAgICAgICBtb3ZlVXA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgbW92ZWQgPSBLb252YS5Ob2RlLnByb3RvdHlwZS5tb3ZlVXAuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgaWYgKCFtb3ZlZCl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpO1xyXG4gICAgICAgICAgICBpZighc3RhZ2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdGFnZS5jb250ZW50LnJlbW92ZUNoaWxkKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLmluZGV4IDwgc3RhZ2UuZ2V0Q2hpbGRyZW4oKS5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFnZS5jb250ZW50Lmluc2VydEJlZm9yZSh0aGlzLmdldENhbnZhcygpLl9jYW52YXMsIHN0YWdlLmdldENoaWxkcmVuKClbdGhpcy5pbmRleCArIDFdLmdldENhbnZhcygpLl9jYW52YXMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3RhZ2UuY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmdldENhbnZhcygpLl9jYW52YXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBleHRlbmQgTm9kZS5wcm90b3R5cGUubW92ZURvd25cclxuICAgICAgICBtb3ZlRG93bjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmKEtvbnZhLk5vZGUucHJvdG90eXBlLm1vdmVEb3duLmNhbGwodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKTtcclxuICAgICAgICAgICAgICAgIGlmKHN0YWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gc3RhZ2UuZ2V0Q2hpbGRyZW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFnZS5jb250ZW50LnJlbW92ZUNoaWxkKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhZ2UuY29udGVudC5pbnNlcnRCZWZvcmUodGhpcy5nZXRDYW52YXMoKS5fY2FudmFzLCBjaGlsZHJlblt0aGlzLmluZGV4ICsgMV0uZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIGV4dGVuZCBOb2RlLnByb3RvdHlwZS5tb3ZlVG9Cb3R0b21cclxuICAgICAgICBtb3ZlVG9Cb3R0b206IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZihLb252YS5Ob2RlLnByb3RvdHlwZS5tb3ZlVG9Cb3R0b20uY2FsbCh0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYoc3RhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBzdGFnZS5nZXRDaGlsZHJlbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWdlLmNvbnRlbnQucmVtb3ZlQ2hpbGQodGhpcy5nZXRDYW52YXMoKS5fY2FudmFzKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFnZS5jb250ZW50Lmluc2VydEJlZm9yZSh0aGlzLmdldENhbnZhcygpLl9jYW52YXMsIGNoaWxkcmVuWzFdLmdldENhbnZhcygpLl9jYW52YXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRMYXllcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIF9jYW52YXMgPSB0aGlzLmdldENhbnZhcygpLl9jYW52YXM7XHJcblxyXG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIGlmKF9jYW52YXMgJiYgX2NhbnZhcy5wYXJlbnROb2RlICYmIEtvbnZhLlV0aWwuX2lzSW5Eb2N1bWVudChfY2FudmFzKSkge1xyXG4gICAgICAgICAgICAgICAgX2NhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKF9jYW52YXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0U3RhZ2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRTaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBnZXQvc2V0IHdpZHRoIG9mIGxheWVyLmdldHRlciByZXR1cm4gd2lkdGggb2Ygc3RhZ2UuIHNldHRlciBkb2luZyBub3RoaW5nLlxyXG4gICAgICAgICAqIGlmIHlvdSB3YW50IGNoYW5nZSB3aWR0aCB1c2UgYHN0YWdlLndpZHRoKHZhbHVlKTtgXHJcbiAgICAgICAgICogQG5hbWUgd2lkdGhcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkJhc2VMYXllci5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogdmFyIHdpZHRoID0gbGF5ZXIud2lkdGgoKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldFdpZHRoKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldFdpZHRoOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdDYW4gbm90IGNoYW5nZSB3aWR0aCBvZiBsYXllci4gVXNlIFwic3RhZ2Uud2lkdGgodmFsdWUpXCIgZnVuY3Rpb24gaW5zdGVhZC4nKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGdldC9zZXQgaGVpZ2h0IG9mIGxheWVyLmdldHRlciByZXR1cm4gaGVpZ2h0IG9mIHN0YWdlLiBzZXR0ZXIgZG9pbmcgbm90aGluZy5cclxuICAgICAgICAgKiBpZiB5b3Ugd2FudCBjaGFuZ2UgaGVpZ2h0IHVzZSBgc3RhZ2UuaGVpZ2h0KHZhbHVlKTtgXHJcbiAgICAgICAgICogQG5hbWUgaGVpZ2h0XHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqIHZhciBoZWlnaHQgPSBsYXllci5oZWlnaHQoKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRIZWlnaHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdDYW4gbm90IGNoYW5nZSBoZWlnaHQgb2YgbGF5ZXIuIFVzZSBcInN0YWdlLmhlaWdodCh2YWx1ZSlcIiBmdW5jdGlvbiBpbnN0ZWFkLicpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gdGhlIGFwcGx5IHRyYW5zZm9ybSBtZXRob2QgaXMgaGFuZGxlZCBieSB0aGUgTGF5ZXIgYW5kIEZhc3RMYXllciBjbGFzc1xyXG4gICAgICAgIC8vIGJlY2F1c2UgaXQgaXMgdXAgdG8gdGhlIGxheWVyIHRvIGRlY2lkZSBpZiBhbiBhYnNvbHV0ZSBvciByZWxhdGl2ZSB0cmFuc2Zvcm1cclxuICAgICAgICAvLyBzaG91bGQgYmUgdXNlZFxyXG4gICAgICAgIF9hcHBseVRyYW5zZm9ybTogZnVuY3Rpb24oc2hhcGUsIGNvbnRleHQsIHRvcCkge1xyXG4gICAgICAgICAgICB2YXIgbSA9IHNoYXBlLmdldEFic29sdXRlVHJhbnNmb3JtKHRvcCkuZ2V0TWF0cml4KCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNmb3JtKG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sIG1bNF0sIG1bNV0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuQmFzZUxheWVyLCBLb252YS5Db250YWluZXIpO1xyXG5cclxuICAgIC8vIGFkZCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5CYXNlTGF5ZXIsICdjbGVhckJlZm9yZURyYXcnLCB0cnVlKTtcclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBjbGVhckJlZm9yZURyYXcgZmxhZyB3aGljaCBkZXRlcm1pbmVzIGlmIHRoZSBsYXllciBpcyBjbGVhcmVkIG9yIG5vdFxyXG4gICAgICogIGJlZm9yZSBkcmF3aW5nXHJcbiAgICAgKiBAbmFtZSBjbGVhckJlZm9yZURyYXdcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNsZWFyQmVmb3JlRHJhd1xyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGNsZWFyQmVmb3JlRHJhdyBmbGFnXHJcbiAgICAgKiB2YXIgY2xlYXJCZWZvcmVEcmF3ID0gbGF5ZXIuY2xlYXJCZWZvcmVEcmF3KCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gZGlzYWJsZSBjbGVhciBiZWZvcmUgZHJhd1xyXG4gICAgICogbGF5ZXIuY2xlYXJCZWZvcmVEcmF3KGZhbHNlKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBlbmFibGUgY2xlYXIgYmVmb3JlIGRyYXdcclxuICAgICAqIGxheWVyLmNsZWFyQmVmb3JlRHJhdyh0cnVlKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5CYXNlTGF5ZXIpO1xyXG59KSgpO1xyXG5cbihmdW5jdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8vIGNvbnN0YW50c1xyXG4gICAgdmFyIEhBU0ggPSAnIycsXHJcbiAgICAgICAgQkVGT1JFX0RSQVcgPSAnYmVmb3JlRHJhdycsXHJcbiAgICAgICAgRFJBVyA9ICdkcmF3JyxcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiAyIC0gMyAtIDRcclxuICAgICAgICAgKiB8ICAgICAgIHxcclxuICAgICAgICAgKiAxIC0gMCAgIDVcclxuICAgICAgICAgKiAgICAgICAgIHxcclxuICAgICAgICAgKiA4IC0gNyAtIDZcclxuICAgICAgICAgKi9cclxuICAgICAgICBJTlRFUlNFQ1RJT05fT0ZGU0VUUyA9IFtcclxuICAgICAgICAgICAge3g6IDAsIHk6IDB9LCAgLy8gMFxyXG4gICAgICAgICAgICB7eDogLTEsIHk6IDB9LCAvLyAxXHJcbiAgICAgICAgICAgIHt4OiAtMSwgeTogLTF9LCAvLyAyXHJcbiAgICAgICAgICAgIHt4OiAwLCB5OiAtMX0sIC8vIDNcclxuICAgICAgICAgICAge3g6IDEsIHk6IC0xfSwgLy8gNFxyXG4gICAgICAgICAgICB7eDogMSwgeTogMH0sIC8vIDVcclxuICAgICAgICAgICAge3g6IDEsIHk6IDF9LCAvLyA2XHJcbiAgICAgICAgICAgIHt4OiAwLCB5OiAxfSwgLy8gN1xyXG4gICAgICAgICAgICB7eDogLTEsIHk6IDF9ICAvLyA4XHJcbiAgICAgICAgXSxcclxuICAgICAgICBJTlRFUlNFQ1RJT05fT0ZGU0VUU19MRU4gPSBJTlRFUlNFQ1RJT05fT0ZGU0VUUy5sZW5ndGg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMYXllciBjb25zdHJ1Y3Rvci4gIExheWVycyBhcmUgdGllZCB0byB0aGVpciBvd24gY2FudmFzIGVsZW1lbnQgYW5kIGFyZSB1c2VkXHJcbiAgICAgKiB0byBjb250YWluIGdyb3VwcyBvciBzaGFwZXMuXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxyXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLkJhc2VMYXllclxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmNsZWFyQmVmb3JlRHJhd10gc2V0IHRoaXMgcHJvcGVydHkgdG8gZmFsc2UgaWYgeW91IGRvbid0IHdhbnRcclxuICAgICAqIHRvIGNsZWFyIHRoZSBjYW52YXMgYmVmb3JlIGVhY2ggbGF5ZXIgZHJhdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWUuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxyXG4gICAgICogKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5jbGlwXSBzZXQgY2xpcFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBYXSBzZXQgY2xpcCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFldIHNldCBjbGlwIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwV2lkdGhdIHNldCBjbGlwIHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcEhlaWdodF0gc2V0IGNsaXAgaGVpZ2h0XG5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiB2YXIgbGF5ZXIgPSBuZXcgS29udmEuTGF5ZXIoKTtcclxuICAgICAqL1xyXG4gICAgS29udmEuTGF5ZXIgPSBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICB0aGlzLl9fX19pbml0KGNvbmZpZyk7XHJcbiAgICB9O1xyXG5cclxuICAgIEtvbnZhLlV0aWwuYWRkTWV0aG9kcyhLb252YS5MYXllciwge1xyXG4gICAgICAgIF9fX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICAgICAgdGhpcy5ub2RlVHlwZSA9ICdMYXllcic7XHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGl0Q2FudmFzID0gbmV3IEtvbnZhLkhpdENhbnZhcyh7XHJcbiAgICAgICAgICAgICAgICBwaXhlbFJhdGlvOiAxXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgIEtvbnZhLkJhc2VMYXllci5jYWxsKHRoaXMsIGNvbmZpZyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfc2V0Q2FudmFzU2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLmhpdENhbnZhcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3ZhbGlkYXRlQWRkOiBmdW5jdGlvbihjaGlsZCkge1xyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IGNoaWxkLmdldFR5cGUoKTtcclxuICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdHcm91cCcgJiYgdHlwZSAhPT0gJ1NoYXBlJykge1xyXG4gICAgICAgICAgICAgICAgS29udmEuVXRpbC50aHJvdygnWW91IG1heSBvbmx5IGFkZCBncm91cHMgYW5kIHNoYXBlcyB0byBhIGxheWVyLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBnZXQgdmlzaWJsZSBpbnRlcnNlY3Rpb24gc2hhcGUuIFRoaXMgaXMgdGhlIHByZWZlcnJlZFxyXG4gICAgICAgICAqIG1ldGhvZCBmb3IgZGV0ZXJtaW5pbmcgaWYgYSBwb2ludCBpbnRlcnNlY3RzIGEgc2hhcGUgb3Igbm90XHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5MYXllci5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9zXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy54XHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy55XHJcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLlNoYXBlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEludGVyc2VjdGlvbjogZnVuY3Rpb24ocG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBvYmosIGksIGludGVyc2VjdGlvbk9mZnNldCwgc2hhcGU7XHJcblxyXG4gICAgICAgICAgICBpZighdGhpcy5oaXRHcmFwaEVuYWJsZWQoKSB8fCAhdGhpcy5pc1Zpc2libGUoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaW4gc29tZSBjYXNlcyBhbnRpYWxpYXNlZCBhcmVhIG1heSBiZSBiaWdnZXIgdGhhbiAxcHhcclxuICAgICAgICAgICAgLy8gaXQgaXMgcG9zc2libGUgaWYgd2Ugd2lsbCBjYWNoZSBub2RlLCB0aGVuIHNjYWxlIGl0IGEgbG90XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGNoZWNrIHsgMDsgMCB9IHBvaW50IGJlZm9yZSBsb29wLCBhbmQgcmVtb3ZlIGl0IGZyb20gSU5URVJTRUNUSU9OX09GRlNFVFMuXHJcbiAgICAgICAgICAgIHZhciBzcGlyYWxTZWFyY2hEaXN0YW5jZSA9IDE7XHJcbiAgICAgICAgICAgIHZhciBjb250aW51ZVNlYXJjaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IElOVEVSU0VDVElPTl9PRkZTRVRTX0xFTjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uT2Zmc2V0ID0gSU5URVJTRUNUSU9OX09GRlNFVFNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gdGhpcy5fZ2V0SW50ZXJzZWN0aW9uKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogcG9zLnggKyBpbnRlcnNlY3Rpb25PZmZzZXQueCAqIHNwaXJhbFNlYXJjaERpc3RhbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBwb3MueSArIGludGVyc2VjdGlvbk9mZnNldC55ICogc3BpcmFsU2VhcmNoRGlzdGFuY2VcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzaGFwZSA9IG9iai5zaGFwZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzaG91bGQgY29udGludWUgc2VhcmNoIGlmIHdlIGZvdW5kIGFudGlhbGlhc2VkIHBpeGVsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBtZWFucyBvdXIgbm9kZSBzb21ld2hlcmUgdmVyeSBjbG9zZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlU2VhcmNoID0gISFvYmouYW50aWFsaWFzZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBzZWFyY2ggaWYgZm91bmQgZW1wdHkgcGl4ZWxcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9iai5hbnRpYWxpYXNlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBubyBzaGFwZSwgYW5kIG5vIGFudGlhbGlhc2VkIHBpeGVsLCB3ZSBzaG91bGQgZW5kIHNlYXJjaGluZ1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRpbnVlU2VhcmNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BpcmFsU2VhcmNoRGlzdGFuY2UgKz0gMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRJbWFnZURhdGE6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5oaXRDYW52YXMud2lkdGggfHwgMSxcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuaGl0Q2FudmFzLmhlaWdodCB8fCAxLFxyXG4gICAgICAgICAgICAgICAgaW5kZXggPSAoTWF0aC5yb3VuZCh5KSAqIHdpZHRoICkgKyBNYXRoLnJvdW5kKHgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9oaXRJbWFnZURhdGEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hpdEltYWdlRGF0YSA9IHRoaXMuaGl0Q2FudmFzLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGl0SW1hZ2VEYXRhLmRhdGFbNCAqIGluZGV4ICsgMF0sIC8vIFJlZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5faGl0SW1hZ2VEYXRhLmRhdGFbNCAqIGluZGV4ICsgMV0sIC8vIEdyZWVuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oaXRJbWFnZURhdGEuZGF0YVs0ICogaW5kZXggKyAyXSwgLy8gQmx1ZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5faGl0SW1hZ2VEYXRhLmRhdGFbNCAqIGluZGV4ICsgM10gLy8gQWxwaGFcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRJbnRlcnNlY3Rpb246IGZ1bmN0aW9uKHBvcykge1xyXG4gICAgICAgICAgICB2YXIgcmF0aW8gPSB0aGlzLmhpdENhbnZhcy5waXhlbFJhdGlvO1xyXG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMuaGl0Q2FudmFzLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKE1hdGgucm91bmQocG9zLnggKiByYXRpbyksIE1hdGgucm91bmQocG9zLnkgKiByYXRpbyksIDEsIDEpLmRhdGEsXHJcbiAgICAgICAgICAgICAgICBwMyA9IHBbM10sXHJcbiAgICAgICAgICAgICAgICBjb2xvcktleSwgc2hhcGU7XHJcbiAgICAgICAgICAgIC8vIGZ1bGx5IG9wYXF1ZSBwaXhlbFxyXG4gICAgICAgICAgICBpZihwMyA9PT0gMjU1KSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvcktleSA9IEtvbnZhLlV0aWwuX3JnYlRvSGV4KHBbMF0sIHBbMV0sIHBbMl0pO1xyXG4gICAgICAgICAgICAgICAgc2hhcGUgPSBLb252YS5zaGFwZXNbSEFTSCArIGNvbG9yS2V5XTtcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlOiBzaGFwZVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFudGlhbGlhc2VkOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFudGlhbGlhc2VkIHBpeGVsXHJcbiAgICAgICAgICAgIGVsc2UgaWYocDMgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFudGlhbGlhc2VkOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGVtcHR5IHBpeGVsXHJcbiAgICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRyYXdTY2VuZTogZnVuY3Rpb24oY2FuLCB0b3ApIHtcclxuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpLFxyXG4gICAgICAgICAgICAgICAgY2FudmFzID0gY2FuIHx8IChsYXllciAmJiBsYXllci5nZXRDYW52YXMoKSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9maXJlKEJFRk9SRV9EUkFXLCB7XHJcbiAgICAgICAgICAgICAgICBub2RlOiB0aGlzXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYodGhpcy5nZXRDbGVhckJlZm9yZURyYXcoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FudmFzLmdldENvbnRleHQoKS5jbGVhcigpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBLb252YS5Db250YWluZXIucHJvdG90eXBlLmRyYXdTY2VuZS5jYWxsKHRoaXMsIGNhbnZhcywgdG9wKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2ZpcmUoRFJBVywge1xyXG4gICAgICAgICAgICAgICAgbm9kZTogdGhpc1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZHJhd0hpdDogZnVuY3Rpb24oY2FuLCB0b3ApIHtcclxuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpLFxyXG4gICAgICAgICAgICAgICAgY2FudmFzID0gY2FuIHx8IChsYXllciAmJiBsYXllci5oaXRDYW52YXMpO1xyXG5cclxuICAgICAgICAgICAgaWYobGF5ZXIgJiYgbGF5ZXIuZ2V0Q2xlYXJCZWZvcmVEcmF3KCkpIHtcclxuICAgICAgICAgICAgICAgIGxheWVyLmdldEhpdENhbnZhcygpLmdldENvbnRleHQoKS5jbGVhcigpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBLb252YS5Db250YWluZXIucHJvdG90eXBlLmRyYXdIaXQuY2FsbCh0aGlzLCBjYW52YXMsIHRvcCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VEYXRhID0gbnVsbDsgLy8gQ2xlYXIgaW1hZ2VEYXRhIGNhY2hlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uKGJvdW5kcykge1xyXG4gICAgICAgICAgICBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlLmNsZWFyLmNhbGwodGhpcywgYm91bmRzKTtcclxuICAgICAgICAgICAgdGhpcy5nZXRIaXRDYW52YXMoKS5nZXRDb250ZXh0KCkuY2xlYXIoYm91bmRzKTtcclxuICAgICAgICAgICAgdGhpcy5pbWFnZURhdGEgPSBudWxsOyAvLyBDbGVhciBnZXRJbWFnZURhdGEgY2FjaGVcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBleHRlbmQgTm9kZS5wcm90b3R5cGUuc2V0VmlzaWJsZVxyXG4gICAgICAgIHNldFZpc2libGU6IGZ1bmN0aW9uKHZpc2libGUpIHtcclxuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0VmlzaWJsZS5jYWxsKHRoaXMsIHZpc2libGUpO1xyXG4gICAgICAgICAgICBpZih2aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdldENhbnZhcygpLl9jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhpdENhbnZhcy5fY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRDYW52YXMoKS5fY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhpdENhbnZhcy5fY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBlbmFibGUgaGl0IGdyYXBoXHJcbiAgICAgICAgICogQG5hbWUgZW5hYmxlSGl0R3JhcGhcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkxheWVyLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtMYXllcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBlbmFibGVIaXRHcmFwaDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0SGl0R3JhcGhFbmFibGVkKHRydWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGRpc2FibGUgaGl0IGdyYXBoXHJcbiAgICAgICAgICogQG5hbWUgZGlzYWJsZUhpdEdyYXBoXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5MYXllci5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7TGF5ZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGlzYWJsZUhpdEdyYXBoOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRIaXRHcmFwaEVuYWJsZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldFNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICAgICAgS29udmEuQmFzZUxheWVyLnByb3RvdHlwZS5zZXRTaXplLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGl0Q2FudmFzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5MYXllciwgS29udmEuQmFzZUxheWVyKTtcclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5MYXllciwgJ2hpdEdyYXBoRW5hYmxlZCcsIHRydWUpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IGhpdEdyYXBoRW5hYmxlZCBmbGFnLiAgRGlzYWJsaW5nIHRoZSBoaXQgZ3JhcGggd2lsbCBncmVhdGx5IGluY3JlYXNlXHJcbiAgICAgKiAgZHJhdyBwZXJmb3JtYW5jZSBiZWNhdXNlIHRoZSBoaXQgZ3JhcGggd2lsbCBub3QgYmUgcmVkcmF3biBlYWNoIHRpbWUgdGhlIGxheWVyIGlzXHJcbiAgICAgKiAgZHJhd24uICBUaGlzLCBob3dldmVyLCBhbHNvIGRpc2FibGVzIG1vdXNlL3RvdWNoIGV2ZW50IGRldGVjdGlvblxyXG4gICAgICogQG5hbWUgaGl0R3JhcGhFbmFibGVkXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTGF5ZXIucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWRcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBoaXRHcmFwaEVuYWJsZWQgZmxhZ1xyXG4gICAgICogdmFyIGhpdEdyYXBoRW5hYmxlZCA9IGxheWVyLmhpdEdyYXBoRW5hYmxlZCgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIGRpc2FibGUgaGl0IGdyYXBoXHJcbiAgICAgKiBsYXllci5oaXRHcmFwaEVuYWJsZWQoZmFsc2UpO1xyXG4gICAgICpcclxuICAgICAqIC8vIGVuYWJsZSBoaXQgZ3JhcGhcclxuICAgICAqIGxheWVyLmhpdEdyYXBoRW5hYmxlZCh0cnVlKTtcclxuICAgICAqL1xyXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLkxheWVyKTtcclxufSkoKTtcclxuXG4oZnVuY3Rpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICAvKipcclxuICAgICAqIEZhc3RMYXllciBjb25zdHJ1Y3Rvci4gTGF5ZXJzIGFyZSB0aWVkIHRvIHRoZWlyIG93biBjYW52YXMgZWxlbWVudCBhbmQgYXJlIHVzZWRcclxuICAgICAqIHRvIGNvbnRhaW4gc2hhcGVzIG9ubHkuICBJZiB5b3UgZG9uJ3QgbmVlZCBub2RlIG5lc3RpbmcsIG1vdXNlIGFuZCB0b3VjaCBpbnRlcmFjdGlvbnMsXHJcbiAgICAgKiBvciBldmVudCBwdWIvc3ViLCB5b3Ugc2hvdWxkIHVzZSBGYXN0TGF5ZXIgaW5zdGVhZCBvZiBMYXllciB0byBjcmVhdGUgeW91ciBsYXllcnMuXHJcbiAgICAgKiBJdCByZW5kZXJzIGFib3V0IDJ4IGZhc3RlciB0aGFuIG5vcm1hbCBsYXllcnMuXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxyXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLkJhc2VMYXllclxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmNsZWFyQmVmb3JlRHJhd10gc2V0IHRoaXMgcHJvcGVydHkgdG8gZmFsc2UgaWYgeW91IGRvbid0IHdhbnRcclxuICAgICAqIHRvIGNsZWFyIHRoZSBjYW52YXMgYmVmb3JlIGVhY2ggbGF5ZXIgZHJhdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWUuXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcclxuICAgICAqICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuY2xpcF0gc2V0IGNsaXBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWF0gc2V0IGNsaXAgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBZXSBzZXQgY2xpcCB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFdpZHRoXSBzZXQgY2xpcCB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBIZWlnaHRdIHNldCBjbGlwIGhlaWdodFxuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogdmFyIGxheWVyID0gbmV3IEtvbnZhLkZhc3RMYXllcigpO1xyXG4gICAgICovXHJcbiAgICBLb252YS5GYXN0TGF5ZXIgPSBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICB0aGlzLl9fX19pbml0KGNvbmZpZyk7XHJcbiAgICB9O1xyXG5cclxuICAgIEtvbnZhLlV0aWwuYWRkTWV0aG9kcyhLb252YS5GYXN0TGF5ZXIsIHtcclxuICAgICAgICBfX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZVR5cGUgPSAnTGF5ZXInO1xyXG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IG5ldyBLb252YS5TY2VuZUNhbnZhcygpO1xyXG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgIEtvbnZhLkJhc2VMYXllci5jYWxsKHRoaXMsIGNvbmZpZyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfdmFsaWRhdGVBZGQ6IGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gY2hpbGQuZ2V0VHlwZSgpO1xyXG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gJ1NoYXBlJykge1xyXG4gICAgICAgICAgICAgICAgS29udmEuVXRpbC50aHJvdygnWW91IG1heSBvbmx5IGFkZCBzaGFwZXMgdG8gYSBmYXN0IGxheWVyLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfc2V0Q2FudmFzU2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGl0R3JhcGhFbmFibGVkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0SW50ZXJzZWN0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkcmF3U2NlbmU6IGZ1bmN0aW9uKGNhbikge1xyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksXHJcbiAgICAgICAgICAgICAgICBjYW52YXMgPSBjYW4gfHwgKGxheWVyICYmIGxheWVyLmdldENhbnZhcygpKTtcclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMuZ2V0Q2xlYXJCZWZvcmVEcmF3KCkpIHtcclxuICAgICAgICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCkuY2xlYXIoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZS5kcmF3U2NlbmUuY2FsbCh0aGlzLCBjYW52YXMpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkcmF3OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5kcmF3U2NlbmUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBleHRlbmQgTm9kZS5wcm90b3R5cGUuc2V0VmlzaWJsZVxyXG4gICAgICAgIHNldFZpc2libGU6IGZ1bmN0aW9uKHZpc2libGUpIHtcclxuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0VmlzaWJsZS5jYWxsKHRoaXMsIHZpc2libGUpO1xyXG4gICAgICAgICAgICBpZih2aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdldENhbnZhcygpLl9jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdldENhbnZhcygpLl9jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkZhc3RMYXllciwgS29udmEuQmFzZUxheWVyKTtcclxuXHJcbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuRmFzdExheWVyKTtcclxufSkoKTtcclxuXG4oZnVuY3Rpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICAvKipcclxuICAgICAqIEdyb3VwIGNvbnN0cnVjdG9yLiAgR3JvdXBzIGFyZSB1c2VkIHRvIGNvbnRhaW4gc2hhcGVzIG9yIG90aGVyIGdyb3Vwcy5cclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXHJcbiAgICAgKiBAYXVnbWVudHMgS29udmEuQ29udGFpbmVyXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxyXG4gICAgICogKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5jbGlwXSBzZXQgY2xpcFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBYXSBzZXQgY2xpcCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFldIHNldCBjbGlwIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwV2lkdGhdIHNldCBjbGlwIHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcEhlaWdodF0gc2V0IGNsaXAgaGVpZ2h0XG5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiB2YXIgZ3JvdXAgPSBuZXcgS29udmEuR3JvdXAoKTtcclxuICAgICAqL1xyXG4gICAgS29udmEuR3JvdXAgPSBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcclxuICAgIH07XHJcblxyXG4gICAgS29udmEuVXRpbC5hZGRNZXRob2RzKEtvbnZhLkdyb3VwLCB7XHJcbiAgICAgICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZVR5cGUgPSAnR3JvdXAnO1xyXG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgIEtvbnZhLkNvbnRhaW5lci5jYWxsKHRoaXMsIGNvbmZpZyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfdmFsaWRhdGVBZGQ6IGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gY2hpbGQuZ2V0VHlwZSgpO1xyXG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gJ0dyb3VwJyAmJiB0eXBlICE9PSAnU2hhcGUnKSB7XHJcbiAgICAgICAgICAgICAgICBLb252YS5VdGlsLnRocm93KCdZb3UgbWF5IG9ubHkgYWRkIGdyb3VwcyBhbmQgc2hhcGVzIHRvIGdyb3Vwcy4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuR3JvdXAsIEtvbnZhLkNvbnRhaW5lcik7XHJcblxyXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLkdyb3VwKTtcclxufSkoKTtcclxuXG4oZnVuY3Rpb24oS29udmEpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHZhciBCQVRDSF9EUkFXX1NUT1BfVElNRV9ESUZGID0gNTAwO1xyXG5cclxuICAgIHZhciBub3cgPSAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKEtvbnZhLnJvb3QucGVyZm9ybWFuY2UgJiYgS29udmEucm9vdC5wZXJmb3JtYW5jZS5ub3cpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEtvbnZhLnJvb3QucGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcbiAgICBmdW5jdGlvbiBGUkFGKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgUkFGID0gKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuIEtvbnZhLnJvb3QucmVxdWVzdEFuaW1hdGlvbkZyYW1lXHJcbiAgICAgICAgICAgIHx8IEtvbnZhLnJvb3Qud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lXHJcbiAgICAgICAgICAgIHx8IEtvbnZhLnJvb3QubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXHJcbiAgICAgICAgICAgIHx8IEtvbnZhLnJvb3Qub1JlcXVlc3RBbmltYXRpb25GcmFtZVxyXG4gICAgICAgICAgICB8fCBLb252YS5yb290Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lXHJcbiAgICAgICAgICAgIHx8IEZSQUY7XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gUkFGLmFwcGx5KEtvbnZhLnJvb3QsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbmltYXRpb24gY29uc3RydWN0b3IuICBBIHN0YWdlIGlzIHVzZWQgdG8gY29udGFpbiBtdWx0aXBsZSBsYXllcnMgYW5kIGhhbmRsZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgZnVuY3Rpb24gZXhlY3V0ZWQgb24gZWFjaCBhbmltYXRpb24gZnJhbWUuICBUaGUgZnVuY3Rpb24gaXMgcGFzc2VkIGEgZnJhbWUgb2JqZWN0LCB3aGljaCBjb250YWluc1xyXG4gICAgICogIHRpbWVEaWZmLCBsYXN0VGltZSwgdGltZSwgYW5kIGZyYW1lUmF0ZSBwcm9wZXJ0aWVzLiAgVGhlIHRpbWVEaWZmIHByb3BlcnR5IGlzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBwYXNzZWRcclxuICAgICAqICBzaW5jZSB0aGUgbGFzdCBhbmltYXRpb24gZnJhbWUuICBUaGUgbGFzdFRpbWUgcHJvcGVydHkgaXMgdGltZSBpbiBtaWxsaXNlY29uZHMgdGhhdCBlbGFwc2VkIGZyb20gdGhlIG1vbWVudCB0aGUgYW5pbWF0aW9uIHN0YXJ0ZWRcclxuICAgICAqICB0byB0aGUgbGFzdCBhbmltYXRpb24gZnJhbWUuICBUaGUgdGltZSBwcm9wZXJ0eSBpcyB0aGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdGhhdCBlbGxhcHNlZCBmcm9tIHRoZSBtb21lbnQgdGhlIGFuaW1hdGlvbiBzdGFydGVkXHJcbiAgICAgKiAgdG8gdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGZyYW1lLiAgVGhlIGZyYW1lUmF0ZSBwcm9wZXJ0eSBpcyB0aGUgY3VycmVudCBmcmFtZSByYXRlIGluIGZyYW1lcyAvIHNlY29uZC4gUmV0dXJuIGZhbHNlIGZyb20gZnVuY3Rpb24sXHJcbiAgICAgKiAgaWYgeW91IGRvbid0IG5lZWQgdG8gcmVkcmF3IGxheWVyL2xheWVycyBvbiBzb21lIGZyYW1lcy5cclxuICAgICAqIEBwYXJhbSB7S29udmEuTGF5ZXJ8QXJyYXl9IFtsYXllcnNdIGxheWVyKHMpIHRvIGJlIHJlZHJhd24gb24gZWFjaCBhbmltYXRpb24gZnJhbWUuIENhbiBiZSBhIGxheWVyLCBhbiBhcnJheSBvZiBsYXllcnMsIG9yIG51bGwuXHJcbiAgICAgKiAgTm90IHNwZWNpZnlpbmcgYSBub2RlIHdpbGwgcmVzdWx0IGluIG5vIHJlZHJhdy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBtb3ZlIGEgbm9kZSB0byB0aGUgcmlnaHQgYXQgNTAgcGl4ZWxzIC8gc2Vjb25kXHJcbiAgICAgKiB2YXIgdmVsb2NpdHkgPSA1MDtcclxuICAgICAqXHJcbiAgICAgKiB2YXIgYW5pbSA9IG5ldyBLb252YS5BbmltYXRpb24oZnVuY3Rpb24oZnJhbWUpIHtcclxuICAgICAqICAgdmFyIGRpc3QgPSB2ZWxvY2l0eSAqIChmcmFtZS50aW1lRGlmZiAvIDEwMDApO1xyXG4gICAgICogICBub2RlLm1vdmUoZGlzdCwgMCk7XHJcbiAgICAgKiB9LCBsYXllcik7XHJcbiAgICAgKlxyXG4gICAgICogYW5pbS5zdGFydCgpO1xyXG4gICAgICovXHJcbiAgICBLb252YS5BbmltYXRpb24gPSBmdW5jdGlvbihmdW5jLCBsYXllcnMpIHtcclxuICAgICAgICB2YXIgQW5pbSA9IEtvbnZhLkFuaW1hdGlvbjtcclxuICAgICAgICB0aGlzLmZ1bmMgPSBmdW5jO1xyXG4gICAgICAgIHRoaXMuc2V0TGF5ZXJzKGxheWVycyk7XHJcbiAgICAgICAgdGhpcy5pZCA9IEFuaW0uYW5pbUlkQ291bnRlcisrO1xyXG4gICAgICAgIHRoaXMuZnJhbWUgPSB7XHJcbiAgICAgICAgICAgIHRpbWU6IDAsXHJcbiAgICAgICAgICAgIHRpbWVEaWZmOiAwLFxyXG4gICAgICAgICAgICBsYXN0VGltZTogbm93KClcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICAgKiBBbmltYXRpb24gbWV0aG9kc1xyXG4gICAgICovXHJcbiAgICBLb252YS5BbmltYXRpb24ucHJvdG90eXBlID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHNldCBsYXllcnMgdG8gYmUgcmVkcmF3biBvbiBlYWNoIGFuaW1hdGlvbiBmcmFtZVxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQW5pbWF0aW9uLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7S29udmEuTGF5ZXJ8QXJyYXl9IFtsYXllcnNdIGxheWVyKHMpIHRvIGJlIHJlZHJhd24uJm5ic3A7IENhbiBiZSBhIGxheWVyLCBhbiBhcnJheSBvZiBsYXllcnMsIG9yIG51bGwuICBOb3Qgc3BlY2lmeWluZyBhIG5vZGUgd2lsbCByZXN1bHQgaW4gbm8gcmVkcmF3LlxyXG4gICAgICAgICAqIEByZXR1cm4ge0tvbnZhLkFuaW1hdGlvbn0gdGhpc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldExheWVyczogZnVuY3Rpb24obGF5ZXJzKSB7XHJcbiAgICAgICAgICAgIHZhciBsYXlzID0gW107XHJcbiAgICAgICAgICAgIC8vIGlmIHBhc3NpbmcgaW4gbm8gbGF5ZXJzXHJcbiAgICAgICAgICAgIGlmICghbGF5ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBsYXlzID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgcGFzc2luZyBpbiBhbiBhcnJheSBvZiBMYXllcnNcclxuICAgICAgICAgICAgLy8gTk9URTogbGF5ZXJzIGNvdWxkIGJlIGFuIGFycmF5IG9yIEtvbnZhLkNvbGxlY3Rpb24uICBmb3Igc2ltcGxpY2l0eSwgSSdtIGp1c3QgaW5zcGVjdGluZ1xyXG4gICAgICAgICAgICAvLyB0aGUgbGVuZ3RoIHByb3BlcnR5IHRvIGNoZWNrIGZvciBib3RoIGNhc2VzXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxheWVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBsYXlzID0gbGF5ZXJzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIHBhc3NpbmcgaW4gYSBMYXllclxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxheXMgPSBbbGF5ZXJzXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5sYXllcnMgPSBsYXlzO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGdldCBsYXllcnNcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkFuaW1hdGlvbi5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgS29udmEuTGF5ZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRMYXllcnM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXllcnM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBhZGQgbGF5ZXIuICBSZXR1cm5zIHRydWUgaWYgdGhlIGxheWVyIHdhcyBhZGRlZCwgYW5kIGZhbHNlIGlmIGl0IHdhcyBub3RcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkFuaW1hdGlvbi5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge0tvbnZhLkxheWVyfSBsYXllciB0byBhZGRcclxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sfSB0cnVlIGlmIGxheWVyIGlzIGFkZGVkIHRvIGFuaW1hdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWRkTGF5ZXI6IGZ1bmN0aW9uKGxheWVyKSB7XHJcbiAgICAgICAgICAgIHZhciBsYXllcnMgPSB0aGlzLmxheWVycyxcclxuICAgICAgICAgICAgICAgIGxlbiA9IGxheWVycy5sZW5ndGgsIG47XHJcblxyXG4gICAgICAgICAgICAvLyBkb24ndCBhZGQgdGhlIGxheWVyIGlmIGl0IGFscmVhZHkgZXhpc3RzXHJcbiAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyc1tuXS5faWQgPT09IGxheWVyLl9pZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmxheWVycy5wdXNoKGxheWVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBkZXRlcm1pbmUgaWYgYW5pbWF0aW9uIGlzIHJ1bm5pbmcgb3Igbm90LiAgcmV0dXJucyB0cnVlIG9yIGZhbHNlXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5BbmltYXRpb24ucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybiB7Qm9vbH0gaXMgYW5pbWF0aW9uIHJ1bm5pbmc/XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNSdW5uaW5nOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBLb252YS5BbmltYXRpb24sXHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zID0gYS5hbmltYXRpb25zLFxyXG4gICAgICAgICAgICAgICAgbGVuID0gYW5pbWF0aW9ucy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBuO1xyXG5cclxuICAgICAgICAgICAgZm9yKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcclxuICAgICAgICAgICAgICAgIGlmKGFuaW1hdGlvbnNbbl0uaWQgPT09IHRoaXMuaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBzdGFydCBhbmltYXRpb25cclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkFuaW1hdGlvbi5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJuIHtLb252YS5BbmltYXRpb259IHRoaXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBzdGFydDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBBbmltID0gS29udmEuQW5pbWF0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcclxuICAgICAgICAgICAgdGhpcy5mcmFtZS50aW1lRGlmZiA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWUubGFzdFRpbWUgPSBub3coKTtcclxuICAgICAgICAgICAgQW5pbS5fYWRkQW5pbWF0aW9uKHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHN0b3AgYW5pbWF0aW9uXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5BbmltYXRpb24ucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybiB7S29udmEuQW5pbWF0aW9ufSB0aGlzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RvcDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIEtvbnZhLkFuaW1hdGlvbi5fcmVtb3ZlQW5pbWF0aW9uKHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIF91cGRhdGVGcmFtZU9iamVjdDogZnVuY3Rpb24odGltZSkge1xyXG4gICAgICAgICAgICB0aGlzLmZyYW1lLnRpbWVEaWZmID0gdGltZSAtIHRoaXMuZnJhbWUubGFzdFRpbWU7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWUubGFzdFRpbWUgPSB0aW1lO1xyXG4gICAgICAgICAgICB0aGlzLmZyYW1lLnRpbWUgKz0gdGhpcy5mcmFtZS50aW1lRGlmZjtcclxuICAgICAgICAgICAgdGhpcy5mcmFtZS5mcmFtZVJhdGUgPSAxMDAwIC8gdGhpcy5mcmFtZS50aW1lRGlmZjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgS29udmEuQW5pbWF0aW9uLmFuaW1hdGlvbnMgPSBbXTtcclxuICAgIEtvbnZhLkFuaW1hdGlvbi5hbmltSWRDb3VudGVyID0gMDtcclxuICAgIEtvbnZhLkFuaW1hdGlvbi5hbmltUnVubmluZyA9IGZhbHNlO1xyXG5cclxuICAgIEtvbnZhLkFuaW1hdGlvbi5fYWRkQW5pbWF0aW9uID0gZnVuY3Rpb24oYW5pbSkge1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucy5wdXNoKGFuaW0pO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZUFuaW1hdGlvbigpO1xyXG4gICAgfTtcclxuICAgIEtvbnZhLkFuaW1hdGlvbi5fcmVtb3ZlQW5pbWF0aW9uID0gZnVuY3Rpb24oYW5pbSkge1xyXG4gICAgICAgIHZhciBpZCA9IGFuaW0uaWQsXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnMgPSB0aGlzLmFuaW1hdGlvbnMsXHJcbiAgICAgICAgICAgIGxlbiA9IGFuaW1hdGlvbnMubGVuZ3RoLFxyXG4gICAgICAgICAgICBuO1xyXG5cclxuICAgICAgICBmb3IobiA9IDA7IG4gPCBsZW47IG4rKykge1xyXG4gICAgICAgICAgICBpZihhbmltYXRpb25zW25dLmlkID09PSBpZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zLnNwbGljZShuLCAxKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBLb252YS5BbmltYXRpb24uX3J1bkZyYW1lcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBsYXllckhhc2ggPSB7fSxcclxuICAgICAgICAgICAgYW5pbWF0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucyxcclxuICAgICAgICAgICAgYW5pbSwgbGF5ZXJzLCBmdW5jLCBuLCBpLCBsYXllcnNMZW4sIGxheWVyLCBrZXksIG5lZWRSZWRyYXc7XHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBsb29wIHRocm91Z2ggYWxsIGFuaW1hdGlvbnMgYW5kIGV4ZWN1dGUgYW5pbWF0aW9uXHJcbiAgICAgICAgICogIGZ1bmN0aW9uLiAgaWYgdGhlIGFuaW1hdGlvbiBvYmplY3QgaGFzIHNwZWNpZmllZCBub2RlLFxyXG4gICAgICAgICAqICB3ZSBjYW4gYWRkIHRoZSBub2RlIHRvIHRoZSBub2RlcyBoYXNoIHRvIGVsaW1pbmF0ZVxyXG4gICAgICAgICAqICBkcmF3aW5nIHRoZSBzYW1lIG5vZGUgbXVsdGlwbGUgdGltZXMuICBUaGUgbm9kZSBwcm9wZXJ0eVxyXG4gICAgICAgICAqICBjYW4gYmUgdGhlIHN0YWdlIGl0c2VsZiBvciBhIGxheWVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBXQVJOSU5HOiBkb24ndCBjYWNoZSBhbmltYXRpb25zLmxlbmd0aCBiZWNhdXNlIGl0IGNvdWxkIGNoYW5nZSB3aGlsZVxyXG4gICAgICAgICAqIHRoZSBmb3IgbG9vcCBpcyBydW5uaW5nLCBjYXVzaW5nIGEgSlMgZXJyb3JcclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgZm9yKG4gPSAwOyBuIDwgYW5pbWF0aW9ucy5sZW5ndGg7IG4rKykge1xyXG4gICAgICAgICAgICBhbmltID0gYW5pbWF0aW9uc1tuXTtcclxuICAgICAgICAgICAgbGF5ZXJzID0gYW5pbS5sYXllcnM7XHJcbiAgICAgICAgICAgIGZ1bmMgPSBhbmltLmZ1bmM7XHJcblxyXG5cclxuICAgICAgICAgICAgYW5pbS5fdXBkYXRlRnJhbWVPYmplY3Qobm93KCkpO1xyXG4gICAgICAgICAgICBsYXllcnNMZW4gPSBsYXllcnMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgYW5pbWF0aW9uIG9iamVjdCBoYXMgYSBmdW5jdGlvbiwgZXhlY3V0ZSBpdFxyXG4gICAgICAgICAgICBpZiAoZnVuYykge1xyXG4gICAgICAgICAgICAgICAgLy8gYWxsb3cgYW5pbSBieXBhc3NpbmcgZHJhd2luZ1xyXG4gICAgICAgICAgICAgICAgbmVlZFJlZHJhdyA9IChmdW5jLmNhbGwoYW5pbSwgYW5pbS5mcmFtZSkgIT09IGZhbHNlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5lZWRSZWRyYXcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbmVlZFJlZHJhdykge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxheWVyc0xlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsYXllciA9IGxheWVyc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIuX2lkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXllckhhc2hbbGF5ZXIuX2lkXSA9IGxheWVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGtleSBpbiBsYXllckhhc2gpIHtcclxuICAgICAgICAgICAgaWYgKCFsYXllckhhc2guaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGF5ZXJIYXNoW2tleV0uZHJhdygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBLb252YS5BbmltYXRpb24uX2FuaW1hdGlvbkxvb3AgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgQW5pbSA9IEtvbnZhLkFuaW1hdGlvbjtcclxuICAgICAgICBpZihBbmltLmFuaW1hdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RBbmltRnJhbWUoQW5pbS5fYW5pbWF0aW9uTG9vcCk7XHJcbiAgICAgICAgICAgIEFuaW0uX3J1bkZyYW1lcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgQW5pbS5hbmltUnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBLb252YS5BbmltYXRpb24uX2hhbmRsZUFuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmKCF0aGlzLmFuaW1SdW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbVJ1bm5pbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9hbmltYXRpb25Mb29wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgbW92ZVRvID0gS29udmEuTm9kZS5wcm90b3R5cGUubW92ZVRvO1xyXG4gICAgS29udmEuTm9kZS5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24oY29udGFpbmVyKSB7XHJcbiAgICAgICAgbW92ZVRvLmNhbGwodGhpcywgY29udGFpbmVyKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBiYXRjaCBkcmF3XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcmV0dXJuIHtLb252YS5MYXllcn0gdGhpc1xyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkJhc2UucHJvdG90eXBlXHJcbiAgICAgKi9cclxuICAgIEtvbnZhLkJhc2VMYXllci5wcm90b3R5cGUuYmF0Y2hEcmF3ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxyXG4gICAgICAgICAgICBBbmltID0gS29udmEuQW5pbWF0aW9uO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuYmF0Y2hBbmltKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hBbmltID0gbmV3IEFuaW0oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5sYXN0QmF0Y2hEcmF3VGltZSAmJiBub3coKSAtIHRoYXQubGFzdEJhdGNoRHJhd1RpbWUgPiBCQVRDSF9EUkFXX1NUT1BfVElNRV9ESUZGKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5iYXRjaEFuaW0uc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubGFzdEJhdGNoRHJhd1RpbWUgPSBub3coKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmJhdGNoQW5pbS5pc1J1bm5pbmcoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmRyYXcoKTtcclxuICAgICAgICAgICAgdGhpcy5iYXRjaEFuaW0uc3RhcnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogYmF0Y2ggZHJhd1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHJldHVybiB7S29udmEuU3RhZ2V9IHRoaXNcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcclxuICAgICAqL1xyXG4gICAgS29udmEuU3RhZ2UucHJvdG90eXBlLmJhdGNoRHJhdyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuZ2V0Q2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uKGxheWVyKSB7XHJcbiAgICAgICAgICAgIGxheWVyLmJhdGNoRHJhdygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxufSkoS29udmEpO1xyXG5cbihmdW5jdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHZhciBibGFja2xpc3QgPSB7XHJcbiAgICAgICAgbm9kZTogMSxcclxuICAgICAgICBkdXJhdGlvbjogMSxcclxuICAgICAgICBlYXNpbmc6IDEsXHJcbiAgICAgICAgb25GaW5pc2g6IDEsXHJcbiAgICAgICAgeW95bzogMVxyXG4gICAgfSxcclxuXHJcbiAgICBQQVVTRUQgPSAxLFxyXG4gICAgUExBWUlORyA9IDIsXHJcbiAgICBSRVZFUlNJTkcgPSAzLFxyXG5cclxuICAgIGlkQ291bnRlciA9IDAsXHJcbiAgICBjb2xvckF0dHJzID0gWydmaWxsJywgJ3N0cm9rZScsICdzaGFkb3dDb2xvciddO1xyXG5cclxuICAgIHZhciBUd2VlbiA9IGZ1bmN0aW9uKHByb3AsIHByb3BGdW5jLCBmdW5jLCBiZWdpbiwgZmluaXNoLCBkdXJhdGlvbiwgeW95bykge1xyXG4gICAgICAgIHRoaXMucHJvcCA9IHByb3A7XHJcbiAgICAgICAgdGhpcy5wcm9wRnVuYyA9IHByb3BGdW5jO1xyXG4gICAgICAgIHRoaXMuYmVnaW4gPSBiZWdpbjtcclxuICAgICAgICB0aGlzLl9wb3MgPSBiZWdpbjtcclxuICAgICAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgICAgICAgdGhpcy5fY2hhbmdlID0gMDtcclxuICAgICAgICB0aGlzLnByZXZQb3MgPSAwO1xyXG4gICAgICAgIHRoaXMueW95byA9IHlveW87XHJcbiAgICAgICAgdGhpcy5fdGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSAwO1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fZmluaXNoID0gMDtcclxuICAgICAgICB0aGlzLmZ1bmMgPSBmdW5jO1xyXG4gICAgICAgIHRoaXMuX2NoYW5nZSA9IGZpbmlzaCAtIHRoaXMuYmVnaW47XHJcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICAgKiBUd2VlbiBtZXRob2RzXHJcbiAgICAgKi9cclxuICAgIFR3ZWVuLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBmaXJlOiBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzW3N0cl07XHJcbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldFRpbWU6IGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICAgICAgaWYodCA+IHRoaXMuZHVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMueW95bykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbWUgPSB0aGlzLmR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLnlveW8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWUgPSB0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0VGltZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uKHApIHtcclxuICAgICAgICAgICAgdGhpcy5wcmV2UG9zID0gdGhpcy5fcG9zO1xyXG4gICAgICAgICAgICB0aGlzLnByb3BGdW5jKHApO1xyXG4gICAgICAgICAgICB0aGlzLl9wb3MgPSBwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0UG9zaXRpb246IGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICAgICAgaWYodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0ID0gdGhpcy5fdGltZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mdW5jKHQsIHRoaXMuYmVnaW4sIHRoaXMuX2NoYW5nZSwgdGhpcy5kdXJhdGlvbik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwbGF5OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFBMQVlJTkc7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IHRoaXMuZ2V0VGltZXIoKSAtIHRoaXMuX3RpbWU7XHJcbiAgICAgICAgICAgIHRoaXMub25FbnRlckZyYW1lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnb25QbGF5Jyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZXZlcnNlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFJFVkVSU0lORztcclxuICAgICAgICAgICAgdGhpcy5fdGltZSA9IHRoaXMuZHVyYXRpb24gLSB0aGlzLl90aW1lO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSB0aGlzLmdldFRpbWVyKCkgLSB0aGlzLl90aW1lO1xyXG4gICAgICAgICAgICB0aGlzLm9uRW50ZXJGcmFtZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmZpcmUoJ29uUmV2ZXJzZScpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2VlazogZnVuY3Rpb24odCkge1xyXG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWUgPSB0O1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmZpcmUoJ29uU2VlaycpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmZpcmUoJ29uUmVzZXQnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZpbmlzaDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcclxuICAgICAgICAgICAgdGhpcy5fdGltZSA9IHRoaXMuZHVyYXRpb247XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnb25GaW5pc2gnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24odGhpcy5nZXRQb3NpdGlvbih0aGlzLl90aW1lKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkVudGVyRnJhbWU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgdCA9IHRoaXMuZ2V0VGltZXIoKSAtIHRoaXMuX3N0YXJ0VGltZTtcclxuICAgICAgICAgICAgaWYodGhpcy5zdGF0ZSA9PT0gUExBWUlORykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUaW1lKHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFJFVkVSU0lORykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUaW1lKHRoaXMuZHVyYXRpb24gLSB0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGF1c2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gUEFVU0VEO1xyXG4gICAgICAgICAgICB0aGlzLmZpcmUoJ29uUGF1c2UnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFRpbWVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUd2VlbiBjb25zdHJ1Y3Rvci4gIFR3ZWVucyBlbmFibGUgeW91IHRvIGFuaW1hdGUgYSBub2RlIGJldHdlZW4gdGhlIGN1cnJlbnQgc3RhdGUgYW5kIGEgbmV3IHN0YXRlLlxyXG4gICAgICogIFlvdSBjYW4gcGxheSwgcGF1c2UsIHJldmVyc2UsIHNlZWssIHJlc2V0LCBhbmQgZmluaXNoIHR3ZWVucy4gIEJ5IGRlZmF1bHQsIHR3ZWVucyBhcmUgYW5pbWF0ZWQgdXNpbmdcclxuICAgICAqICBhIGxpbmVhciBlYXNpbmcuICBGb3IgbW9yZSB0d2VlbmluZyBvcHRpb25zLCBjaGVjayBvdXQge0BsaW5rIEtvbnZhLkVhc2luZ3N9XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGluc3RhbnRpYXRlIG5ldyB0d2VlbiB3aGljaCBmdWxseSByb3RhdGVzIGEgbm9kZSBpbiAxIHNlY29uZFxyXG4gICAgICogdmFyIHR3ZWVuID0gbmV3IEtvbnZhLlR3ZWVuKHtcclxuICAgICAqICAgbm9kZTogbm9kZSxcclxuICAgICAqICAgcm90YXRpb25EZWc6IDM2MCxcclxuICAgICAqICAgZHVyYXRpb246IDEsXHJcbiAgICAgKiAgIGVhc2luZzogS29udmEuRWFzaW5ncy5FYXNlSW5PdXRcclxuICAgICAqIH0pO1xyXG4gICAgICpcclxuICAgICAqIC8vIHBsYXkgdHdlZW5cclxuICAgICAqIHR3ZWVuLnBsYXkoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBwYXVzZSB0d2VlblxyXG4gICAgICogdHdlZW4ucGF1c2UoKTtcclxuICAgICAqL1xyXG4gICAgS29udmEuVHdlZW4gPSBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXHJcbiAgICAgICAgICAgIG5vZGUgPSBjb25maWcubm9kZSxcclxuICAgICAgICAgICAgbm9kZUlkID0gbm9kZS5faWQsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uLFxyXG4gICAgICAgICAgICBlYXNpbmcgPSBjb25maWcuZWFzaW5nIHx8IEtvbnZhLkVhc2luZ3MuTGluZWFyLFxyXG4gICAgICAgICAgICB5b3lvID0gISFjb25maWcueW95byxcclxuICAgICAgICAgICAga2V5O1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5kdXJhdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgZHVyYXRpb24gPSAxO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmR1cmF0aW9uID09PSAwKSB7ICAvLyB6ZXJvIGlzIGJhZCB2YWx1ZSBmb3IgZHVyYXRpb25cclxuICAgICAgICAgICAgZHVyYXRpb24gPSAwLjAwMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IGNvbmZpZy5kdXJhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgICAgICB0aGlzLl9pZCA9IGlkQ291bnRlcisrO1xyXG5cclxuICAgICAgICB0aGlzLmFuaW0gPSBuZXcgS29udmEuQW5pbWF0aW9uKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGF0LnR3ZWVuLm9uRW50ZXJGcmFtZSgpO1xyXG4gICAgICAgIH0sIG5vZGUuZ2V0TGF5ZXIoKSB8fCAoKG5vZGUgaW5zdGFuY2VvZiBLb252YS5TdGFnZSkgPyBub2RlLmdldExheWVycygpIDogbnVsbCkpO1xyXG5cclxuICAgICAgICB0aGlzLnR3ZWVuID0gbmV3IFR3ZWVuKGtleSwgZnVuY3Rpb24oaSkge1xyXG4gICAgICAgICAgICB0aGF0Ll90d2VlbkZ1bmMoaSk7XHJcbiAgICAgICAgfSwgZWFzaW5nLCAwLCAxLCBkdXJhdGlvbiAqIDEwMDAsIHlveW8pO1xyXG5cclxuICAgICAgICB0aGlzLl9hZGRMaXN0ZW5lcnMoKTtcclxuXHJcbiAgICAgICAgLy8gaW5pdCBhdHRycyBtYXBcclxuICAgICAgICBpZiAoIUtvbnZhLlR3ZWVuLmF0dHJzW25vZGVJZF0pIHtcclxuICAgICAgICAgICAgS29udmEuVHdlZW4uYXR0cnNbbm9kZUlkXSA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIUtvbnZhLlR3ZWVuLmF0dHJzW25vZGVJZF1bdGhpcy5faWRdKSB7XHJcbiAgICAgICAgICAgIEtvbnZhLlR3ZWVuLmF0dHJzW25vZGVJZF1bdGhpcy5faWRdID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluaXQgdHdlZW5zIG1hcFxyXG4gICAgICAgIGlmICghS29udmEuVHdlZW4udHdlZW5zW25vZGVJZF0pIHtcclxuICAgICAgICAgICAgS29udmEuVHdlZW4udHdlZW5zW25vZGVJZF0gPSB7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoa2V5IGluIGNvbmZpZykge1xyXG4gICAgICAgICAgICBpZiAoYmxhY2tsaXN0W2tleV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkQXR0cihrZXksIGNvbmZpZ1trZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG5cclxuICAgICAgICAvLyBjYWxsYmFja3NcclxuICAgICAgICB0aGlzLm9uRmluaXNoID0gY29uZmlnLm9uRmluaXNoO1xyXG4gICAgICAgIHRoaXMub25SZXNldCA9IGNvbmZpZy5vblJlc2V0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBzdGFydC9kaWZmIG9iamVjdCA9IGF0dHJzLm5vZGVJZC50d2VlbklkLmF0dHJcclxuICAgIEtvbnZhLlR3ZWVuLmF0dHJzID0ge307XHJcbiAgICAvLyB0d2VlbklkID0gdHdlZW5zLm5vZGVJZC5hdHRyXHJcbiAgICBLb252YS5Ud2Vlbi50d2VlbnMgPSB7fTtcclxuXHJcbiAgICBLb252YS5Ud2Vlbi5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgX2FkZEF0dHI6IGZ1bmN0aW9uKGtleSwgZW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlLFxyXG4gICAgICAgICAgICAgICAgbm9kZUlkID0gbm9kZS5faWQsXHJcbiAgICAgICAgICAgICAgICBzdGFydCwgZGlmZiwgdHdlZW5JZCwgbiwgbGVuLCB0cnVlRW5kLCB0cnVlU3RhcnQ7XHJcblxyXG4gICAgICAgICAgICAvLyByZW1vdmUgY29uZmxpY3QgZnJvbSB0d2VlbiBtYXAgaWYgaXQgZXhpc3RzXHJcbiAgICAgICAgICAgIHR3ZWVuSWQgPSBLb252YS5Ud2Vlbi50d2VlbnNbbm9kZUlkXVtrZXldO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR3ZWVuSWQpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBLb252YS5Ud2Vlbi5hdHRyc1tub2RlSWRdW3R3ZWVuSWRdW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGFkZCB0byB0d2VlbiBtYXBcclxuICAgICAgICAgICAgc3RhcnQgPSBub2RlLmdldEF0dHIoa2V5KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChLb252YS5VdGlsLl9pc0FycmF5KGVuZCkpIHtcclxuICAgICAgICAgICAgICAgIGRpZmYgPSBbXTtcclxuICAgICAgICAgICAgICAgIGxlbiA9IE1hdGgubWF4KGVuZC5sZW5ndGgsIHN0YXJ0Lmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3BvaW50cycgJiYgZW5kLmxlbmd0aCAhPT0gc3RhcnQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVmb3JlIHR3ZWVuaW5nIHBvaW50cyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IHN0YXJ0Lmxlbmd0aCA9PT0gZW5kLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEtvbnZhLlV0aWwuX3ByZXBhcmVBcnJheUZvclR3ZWVuIHRoaW5raW5nIHRoYXQgZW5kLmxlbmd0aCA+IHN0YXJ0Lmxlbmd0aFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kLmxlbmd0aCA+IHN0YXJ0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBpbiB0aGlzIGNhc2Ugd2Ugd2lsbCBpbmNyZWFzZSBudW1iZXIgb2Ygc3RhcnRpbmcgcG9pbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWVTdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IEtvbnZhLlV0aWwuX3ByZXBhcmVBcnJheUZvclR3ZWVuKHN0YXJ0LCBlbmQsIG5vZGUuY2xvc2VkKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3aWxsIGluY3JlYXNlIG51bWJlciBvZiBlZGluZyBwb2ludHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZUVuZCA9IGVuZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gS29udmEuVXRpbC5fcHJlcGFyZUFycmF5Rm9yVHdlZW4oZW5kLCBzdGFydCwgbm9kZS5jbG9zZWQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpZmYucHVzaCgoZW5kW25dKSAtIChzdGFydFtuXSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2xvckF0dHJzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gS29udmEuVXRpbC5jb2xvclRvUkdCQShzdGFydCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kUkdCQSA9IEtvbnZhLlV0aWwuY29sb3JUb1JHQkEoZW5kKTtcclxuICAgICAgICAgICAgICAgIGRpZmYgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcjogZW5kUkdCQS5yIC0gc3RhcnQucixcclxuICAgICAgICAgICAgICAgICAgICBnOiBlbmRSR0JBLmcgLSBzdGFydC5nLFxyXG4gICAgICAgICAgICAgICAgICAgIGI6IGVuZFJHQkEuYiAtIHN0YXJ0LmIsXHJcbiAgICAgICAgICAgICAgICAgICAgYTogZW5kUkdCQS5hIC0gc3RhcnQuYVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRpZmYgPSBlbmQgLSBzdGFydDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgS29udmEuVHdlZW4uYXR0cnNbbm9kZUlkXVt0aGlzLl9pZF1ba2V5XSA9IHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuICAgICAgICAgICAgICAgIGRpZmY6IGRpZmYsXHJcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZCxcclxuICAgICAgICAgICAgICAgIHRydWVFbmQ6IHRydWVFbmQsXHJcbiAgICAgICAgICAgICAgICB0cnVlU3RhcnQ6IHRydWVTdGFydFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBLb252YS5Ud2Vlbi50d2VlbnNbbm9kZUlkXVtrZXldID0gdGhpcy5faWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfdHdlZW5GdW5jOiBmdW5jdGlvbihpKSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlLFxyXG4gICAgICAgICAgICAgICAgYXR0cnMgPSBLb252YS5Ud2Vlbi5hdHRyc1tub2RlLl9pZF1bdGhpcy5faWRdLFxyXG4gICAgICAgICAgICAgICAga2V5LCBhdHRyLCBzdGFydCwgZGlmZiwgbmV3VmFsLCBuLCBsZW4sIGVuZDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoa2V5IGluIGF0dHJzKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRyID0gYXR0cnNba2V5XTtcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gYXR0ci5zdGFydDtcclxuICAgICAgICAgICAgICAgIGRpZmYgPSBhdHRyLmRpZmY7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBhdHRyLmVuZDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoS29udmEuVXRpbC5faXNBcnJheShzdGFydCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdWYWwgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBsZW4gPSBNYXRoLm1heChzdGFydC5sZW5ndGgsIGVuZC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWwucHVzaCgoc3RhcnRbbl0gfHwgMCkgKyAoZGlmZltuXSAqIGkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbG9yQXR0cnMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbCA9ICdyZ2JhKCcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZChzdGFydC5yICsgZGlmZi5yICogaSkgKyAnLCcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZChzdGFydC5nICsgZGlmZi5nICogaSkgKyAnLCcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZChzdGFydC5iICsgZGlmZi5iICogaSkgKyAnLCcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXJ0LmEgKyBkaWZmLmEgKiBpKSArICcpJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsID0gc3RhcnQgKyAoZGlmZiAqIGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cihrZXksIG5ld1ZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9hZGRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICAvLyBzdGFydCBsaXN0ZW5lcnNcclxuICAgICAgICAgICAgdGhpcy50d2Vlbi5vblBsYXkgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuYW5pbS5zdGFydCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnR3ZWVuLm9uUmV2ZXJzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5hbmltLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBzdG9wIGxpc3RlbmVyc1xyXG4gICAgICAgICAgICB0aGlzLnR3ZWVuLm9uUGF1c2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuYW5pbS5zdG9wKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMudHdlZW4ub25GaW5pc2ggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhhdC5ub2RlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGFmdGVyIHR3ZWVuaW5nICBwb2ludHMgb2YgbGluZSB3ZSBuZWVkIHRvIHNldCBvcmlnaW5hbCBlbmRcclxuICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IEtvbnZhLlR3ZWVuLmF0dHJzW25vZGUuX2lkXVt0aGF0Ll9pZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoYXR0cnMucG9pbnRzICYmIGF0dHJzLnBvaW50cy50cnVlRW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wb2ludHMoYXR0cnMucG9pbnRzLnRydWVFbmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGF0Lm9uRmluaXNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5vbkZpbmlzaC5jYWxsKHRoYXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnR3ZWVuLm9uUmVzZXQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhhdC5ub2RlO1xyXG4gICAgICAgICAgICAgICAgLy8gYWZ0ZXIgdHdlZW5pbmcgIHBvaW50cyBvZiBsaW5lIHdlIG5lZWQgdG8gc2V0IG9yaWdpbmFsIHN0YXJ0XHJcbiAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBLb252YS5Ud2Vlbi5hdHRyc1tub2RlLl9pZF1bdGhhdC5faWRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGF0dHJzLnBvaW50cyAmJiBhdHRycy5wb2ludHMudHJ1ZVN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wb2ludHMoYXR0cnMucG9pbnRzLnRydWVTdGFydCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoYXQub25SZXNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQub25SZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogcGxheVxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHdlZW4ucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge1R3ZWVufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHBsYXk6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnR3ZWVuLnBsYXkoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiByZXZlcnNlXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ud2Vlbi5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7VHdlZW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmV2ZXJzZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHdlZW4ucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHJlc2V0XHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ud2Vlbi5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7VHdlZW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnR3ZWVuLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogc2Vla1xyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHdlZW4ucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtJbnRlZ2VyfSB0IHRpbWUgaW4gc2Vjb25kcyBiZXR3ZWVuIDAgYW5kIHRoZSBkdXJhdGlvblxyXG4gICAgICAgICAqIEByZXR1cm5zIHtUd2Vlbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZWVrOiBmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgICAgIHRoaXMudHdlZW4uc2Vlayh0ICogMTAwMCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogcGF1c2VcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlR3ZWVuLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtUd2Vlbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBwYXVzZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHdlZW4ucGF1c2UoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBmaW5pc2hcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlR3ZWVuLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtUd2Vlbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmaW5pc2g6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnR3ZWVuLmZpbmlzaCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGRlc3Ryb3lcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlR3ZWVuLnByb3RvdHlwZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgbm9kZUlkID0gdGhpcy5ub2RlLl9pZCxcclxuICAgICAgICAgICAgICAgIHRoaXNJZCA9IHRoaXMuX2lkLFxyXG4gICAgICAgICAgICAgICAgYXR0cnMgPSBLb252YS5Ud2Vlbi50d2VlbnNbbm9kZUlkXSxcclxuICAgICAgICAgICAgICAgIGtleTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoa2V5IGluIGF0dHJzKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgS29udmEuVHdlZW4udHdlZW5zW25vZGVJZF1ba2V5XTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZGVsZXRlIEtvbnZhLlR3ZWVuLmF0dHJzW25vZGVJZF1bdGhpc0lkXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHdlZW4gbm9kZSBwcm9wZXJ0aWVzLiBTaG9ydGVyIHVzYWdlIG9mIHtAbGluayBLb252YS5Ud2Vlbn0gb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgS29udmEuTm9kZSN0b1xyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSB0d2VlbiBwYXJhbXNcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogY2lyY2xlLnRvKHtcclxuICAgICAqICB4IDogNTAsXHJcbiAgICAgKiAgZHVyYXRpb24gOiAwLjVcclxuICAgICAqIH0pO1xyXG4gICAgICovXHJcbiAgICBLb252YS5Ob2RlLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uKHBhcmFtcykge1xyXG4gICAgICAgIHZhciBvbkZpbmlzaCA9IHBhcmFtcy5vbkZpbmlzaDtcclxuICAgICAgICBwYXJhbXMubm9kZSA9IHRoaXM7XHJcbiAgICAgICAgcGFyYW1zLm9uRmluaXNoID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICBpZiAob25GaW5pc2gpIHtcclxuICAgICAgICAgICAgICAgIG9uRmluaXNoKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciB0d2VlbiA9IG5ldyBLb252YS5Ud2VlbihwYXJhbXMpO1xyXG4gICAgICAgIHR3ZWVuLnBsYXkoKTtcclxuICAgIH07XHJcblxyXG4gICAgLypcclxuICAgICogVGhlc2UgZWFzZXMgd2VyZSBwb3J0ZWQgZnJvbSBhbiBBZG9iZSBGbGFzaCB0d2VlbmluZyBsaWJyYXJ5IHRvIEphdmFTY3JpcHRcclxuICAgICogYnkgWGFyaWNcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZXNwYWNlIEVhc2luZ3NcclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxyXG4gICAgICovXHJcbiAgICBLb252YS5FYXNpbmdzID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogYmFjayBlYXNlIGluXHJcbiAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXHJcbiAgICAgICAgKi9cclxuICAgICAgICAnQmFja0Vhc2VJbic6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4O1xyXG4gICAgICAgICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqICgocyArIDEpICogdCAtIHMpICsgYjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogYmFjayBlYXNlIG91dFxyXG4gICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xyXG4gICAgICAgICovXHJcbiAgICAgICAgJ0JhY2tFYXNlT3V0JzogZnVuY3Rpb24odCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XHJcbiAgICAgICAgICAgIHJldHVybiBjICogKCggdCA9IHQgLyBkIC0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxKSArIGI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAqIGJhY2sgZWFzZSBpbiBvdXRcclxuICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcclxuICAgICAgICAqL1xyXG4gICAgICAgICdCYWNrRWFzZUluT3V0JzogZnVuY3Rpb24odCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XHJcbiAgICAgICAgICAgIGlmKCh0IC89IGQgLyAyKSA8IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjIC8gMiAqICh0ICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgLSBzKSkgKyBiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjIC8gMiAqICgodCAtPSAyKSAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0ICsgcykgKyAyKSArIGI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAqIGVsYXN0aWMgZWFzZSBpblxyXG4gICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xyXG4gICAgICAgICovXHJcbiAgICAgICAgJ0VsYXN0aWNFYXNlSW4nOiBmdW5jdGlvbih0LCBiLCBjLCBkLCBhLCBwKSB7XHJcbiAgICAgICAgICAgIC8vIGFkZGVkIHMgPSAwXHJcbiAgICAgICAgICAgIHZhciBzID0gMDtcclxuICAgICAgICAgICAgaWYodCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoKHQgLz0gZCkgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiICsgYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZighcCkge1xyXG4gICAgICAgICAgICAgICAgcCA9IGQgKiAwLjM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIWEgfHwgYSA8IE1hdGguYWJzKGMpKSB7XHJcbiAgICAgICAgICAgICAgICBhID0gYztcclxuICAgICAgICAgICAgICAgIHMgPSBwIC8gNDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbihjIC8gYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIC0oYSAqIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgKiBkIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpICsgYjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogZWxhc3RpYyBlYXNlIG91dFxyXG4gICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xyXG4gICAgICAgICovXHJcbiAgICAgICAgJ0VsYXN0aWNFYXNlT3V0JzogZnVuY3Rpb24odCwgYiwgYywgZCwgYSwgcCkge1xyXG4gICAgICAgICAgICAvLyBhZGRlZCBzID0gMFxyXG4gICAgICAgICAgICB2YXIgcyA9IDA7XHJcbiAgICAgICAgICAgIGlmKHQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCh0IC89IGQpID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYiArIGM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIXApIHtcclxuICAgICAgICAgICAgICAgIHAgPSBkICogMC4zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCFhIHx8IGEgPCBNYXRoLmFicyhjKSkge1xyXG4gICAgICAgICAgICAgICAgYSA9IGM7XHJcbiAgICAgICAgICAgICAgICBzID0gcCAvIDQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oYyAvIGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAoYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgKiBkIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKyBjICsgYik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAqIGVsYXN0aWMgZWFzZSBpbiBvdXRcclxuICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcclxuICAgICAgICAqL1xyXG4gICAgICAgICdFbGFzdGljRWFzZUluT3V0JzogZnVuY3Rpb24odCwgYiwgYywgZCwgYSwgcCkge1xyXG4gICAgICAgICAgICAvLyBhZGRlZCBzID0gMFxyXG4gICAgICAgICAgICB2YXIgcyA9IDA7XHJcbiAgICAgICAgICAgIGlmKHQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCh0IC89IGQgLyAyKSA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGIgKyBjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCFwKSB7XHJcbiAgICAgICAgICAgICAgICBwID0gZCAqICgwLjMgKiAxLjUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCFhIHx8IGEgPCBNYXRoLmFicyhjKSkge1xyXG4gICAgICAgICAgICAgICAgYSA9IGM7XHJcbiAgICAgICAgICAgICAgICBzID0gcCAvIDQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oYyAvIGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHQgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTAuNSAqIChhICogTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAqIGQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSkgKyBiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgKiBkIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKiAwLjUgKyBjICsgYjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogYm91bmNlIGVhc2Ugb3V0XHJcbiAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXHJcbiAgICAgICAgKi9cclxuICAgICAgICAnQm91bmNlRWFzZU91dCc6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgaWYoKHQgLz0gZCkgPCAoMSAvIDIuNzUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiB0ICogdCkgKyBiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYodCA8ICgyIC8gMi43NSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjICogKDcuNTYyNSAqICh0IC09ICgxLjUgLyAyLjc1KSkgKiB0ICsgMC43NSkgKyBiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYodCA8ICgyLjUgLyAyLjc1KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gKDIuMjUgLyAyLjc1KSkgKiB0ICsgMC45Mzc1KSArIGI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAoMi42MjUgLyAyLjc1KSkgKiB0ICsgMC45ODQzNzUpICsgYjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBib3VuY2UgZWFzZSBpblxyXG4gICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xyXG4gICAgICAgICovXHJcbiAgICAgICAgJ0JvdW5jZUVhc2VJbic6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGMgLSBLb252YS5FYXNpbmdzLkJvdW5jZUVhc2VPdXQoZCAtIHQsIDAsIGMsIGQpICsgYjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogYm91bmNlIGVhc2UgaW4gb3V0XHJcbiAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXHJcbiAgICAgICAgKi9cclxuICAgICAgICAnQm91bmNlRWFzZUluT3V0JzogZnVuY3Rpb24odCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICBpZih0IDwgZCAvIDIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBLb252YS5FYXNpbmdzLkJvdW5jZUVhc2VJbih0ICogMiwgMCwgYywgZCkgKiAwLjUgKyBiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEtvbnZhLkVhc2luZ3MuQm91bmNlRWFzZU91dCh0ICogMiAtIGQsIDAsIGMsIGQpICogMC41ICsgYyAqIDAuNSArIGI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogZWFzZSBpblxyXG4gICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xyXG4gICAgICAgICovXHJcbiAgICAgICAgJ0Vhc2VJbic6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKyBiO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBlYXNlIG91dFxyXG4gICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xyXG4gICAgICAgICovXHJcbiAgICAgICAgJ0Vhc2VPdXQnOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtYyAqICh0IC89IGQpICogKHQgLSAyKSArIGI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAqIGVhc2UgaW4gb3V0XHJcbiAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXHJcbiAgICAgICAgKi9cclxuICAgICAgICAnRWFzZUluT3V0JzogZnVuY3Rpb24odCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICBpZigodCAvPSBkIC8gMikgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYyAvIDIgKiB0ICogdCArIGI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIC1jIC8gMiAqICgoLS10KSAqICh0IC0gMikgLSAxKSArIGI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAqIHN0cm9uZyBlYXNlIGluXHJcbiAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXHJcbiAgICAgICAgKi9cclxuICAgICAgICAnU3Ryb25nRWFzZUluJzogZnVuY3Rpb24odCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqIHQgKiB0ICogdCArIGI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAqIHN0cm9uZyBlYXNlIG91dFxyXG4gICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xyXG4gICAgICAgICovXHJcbiAgICAgICAgJ1N0cm9uZ0Vhc2VPdXQnOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjICogKCggdCA9IHQgLyBkIC0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSkgKyBiO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBzdHJvbmcgZWFzZSBpbiBvdXRcclxuICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcclxuICAgICAgICAqL1xyXG4gICAgICAgICdTdHJvbmdFYXNlSW5PdXQnOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgIGlmKCh0IC89IGQgLyAyKSA8IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjIC8gMiAqIHQgKiB0ICogdCAqIHQgKiB0ICsgYjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMikgKyBiO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBsaW5lYXJcclxuICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcclxuICAgICAgICAqL1xyXG4gICAgICAgICdMaW5lYXInOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjICogdCAvIGQgKyBiO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0pKCk7XHJcblxuKGZ1bmN0aW9uKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgS29udmEuREQgPSB7XHJcbiAgICAgICAgLy8gcHJvcGVydGllc1xyXG4gICAgICAgIGFuaW06IG5ldyBLb252YS5BbmltYXRpb24oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5kaXJ0eTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gYjtcclxuICAgICAgICB9KSxcclxuICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcclxuICAgICAgICBqdXN0RHJhZ2dlZDogZmFsc2UsXHJcbiAgICAgICAgb2Zmc2V0OiB7XHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgIHk6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5vZGU6IG51bGwsXHJcblxyXG4gICAgICAgIC8vIG1ldGhvZHNcclxuICAgICAgICBfZHJhZzogZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgIHZhciBkZCA9IEtvbnZhLkRELFxyXG4gICAgICAgICAgICAgICAgbm9kZSA9IGRkLm5vZGU7XHJcblxyXG4gICAgICAgICAgICBpZihub2RlKSB7XHJcbiAgICAgICAgICAgICAgIGlmKCFkZC5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IG5vZGUuZ2V0U3RhZ2UoKS5nZXRQb2ludGVyUG9zaXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZHJhZ0Rpc3RhbmNlID0gbm9kZS5kcmFnRGlzdGFuY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLm1heChcclxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMocG9zLnggLSBkZC5zdGFydFBvaW50ZXJQb3MueCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKHBvcy55IC0gZGQuc3RhcnRQb2ludGVyUG9zLnkpXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBkcmFnRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgbm9kZS5nZXRTdGFnZSgpLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcclxuICAgICAgICAgICAgICAgIG5vZGUuX3NldERyYWdQb3NpdGlvbihldnQpO1xyXG4gICAgICAgICAgICAgICAgaWYoIWRkLmlzRHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZC5pc0RyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmZpcmUoJ2RyYWdzdGFydCcsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RyYWdzdGFydCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZ0OiBldnRcclxuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBleGVjdXRlIG9uZHJhZ21vdmUgaWYgZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgbm9kZS5maXJlKCdkcmFnbW92ZScsIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZHJhZ21vdmUnLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZSxcclxuICAgICAgICAgICAgICAgICAgICBldnQ6IGV2dFxyXG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9lbmREcmFnQmVmb3JlOiBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICAgICAgdmFyIGRkID0gS29udmEuREQsXHJcbiAgICAgICAgICAgICAgICBub2RlID0gZGQubm9kZSxcclxuICAgICAgICAgICAgICAgIGxheWVyO1xyXG5cclxuICAgICAgICAgICAgaWYobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgbGF5ZXIgPSBub2RlLmdldExheWVyKCk7XHJcbiAgICAgICAgICAgICAgICBkZC5hbmltLnN0b3AoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGZpcmUgZHJhZ2VuZCBldmVudCBpZiB0aGUgZHJhZyBhbmQgZHJvcFxyXG4gICAgICAgICAgICAgICAgLy8gb3BlcmF0aW9uIGFjdHVhbGx5IHN0YXJ0ZWQuXHJcbiAgICAgICAgICAgICAgICBpZihkZC5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGQuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRkLmp1c3REcmFnZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBLb252YS5saXN0ZW5DbGlja1RhcCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2dC5kcmFnRW5kTm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBkZC5ub2RlO1xyXG5cclxuICAgICAgICAgICAgICAgIChsYXllciB8fCBub2RlKS5kcmF3KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9lbmREcmFnQWZ0ZXI6IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgICAgICBldnQgPSBldnQgfHwge307XHJcbiAgICAgICAgICAgIHZhciBkcmFnRW5kTm9kZSA9IGV2dC5kcmFnRW5kTm9kZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChldnQgJiYgZHJhZ0VuZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGRyYWdFbmROb2RlLmZpcmUoJ2RyYWdlbmQnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RyYWdlbmQnLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogZHJhZ0VuZE5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZXZ0OiBldnRcclxuICAgICAgICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBOb2RlIGV4dGVuZGVyc1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogaW5pdGlhdGUgZHJhZyBhbmQgZHJvcFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgKi9cclxuICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnN0YXJ0RHJhZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBkZCA9IEtvbnZhLkRELFxyXG4gICAgICAgICAgICBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKSxcclxuICAgICAgICAgICAgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksXHJcbiAgICAgICAgICAgIHBvcyA9IHN0YWdlLmdldFBvaW50ZXJQb3NpdGlvbigpLFxyXG4gICAgICAgICAgICBhcCA9IHRoaXMuZ2V0QWJzb2x1dGVQb3NpdGlvbigpO1xyXG5cclxuICAgICAgICBpZihwb3MpIHtcclxuICAgICAgICAgICAgaWYgKGRkLm5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGRkLm5vZGUuc3RvcERyYWcoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZGQubm9kZSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGRkLnN0YXJ0UG9pbnRlclBvcyA9IHBvcztcclxuICAgICAgICAgICAgZGQub2Zmc2V0LnggPSBwb3MueCAtIGFwLng7XHJcbiAgICAgICAgICAgIGRkLm9mZnNldC55ID0gcG9zLnkgLSBhcC55O1xyXG4gICAgICAgICAgICBkZC5hbmltLnNldExheWVycyhsYXllciB8fCB0aGlzLmdldExheWVycygpKTtcclxuICAgICAgICAgICAgZGQuYW5pbS5zdGFydCgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fc2V0RHJhZ1Bvc2l0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5fc2V0RHJhZ1Bvc2l0aW9uID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgdmFyIGRkID0gS29udmEuREQsXHJcbiAgICAgICAgICAgIHBvcyA9IHRoaXMuZ2V0U3RhZ2UoKS5nZXRQb2ludGVyUG9zaXRpb24oKSxcclxuICAgICAgICAgICAgZGJmID0gdGhpcy5nZXREcmFnQm91bmRGdW5jKCk7XHJcbiAgICAgICAgaWYgKCFwb3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmV3Tm9kZVBvcyA9IHtcclxuICAgICAgICAgICAgeDogcG9zLnggLSBkZC5vZmZzZXQueCxcclxuICAgICAgICAgICAgeTogcG9zLnkgLSBkZC5vZmZzZXQueVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmKGRiZiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG5ld05vZGVQb3MgPSBkYmYuY2FsbCh0aGlzLCBuZXdOb2RlUG9zLCBldnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldEFic29sdXRlUG9zaXRpb24obmV3Tm9kZVBvcyk7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5fbGFzdFBvcyB8fCB0aGlzLl9sYXN0UG9zLnggIT09IG5ld05vZGVQb3MueCB8fFxyXG4gICAgICAgICAgICB0aGlzLl9sYXN0UG9zLnkgIT09IG5ld05vZGVQb3MueSkge1xyXG4gICAgICAgICAgICBkZC5hbmltLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2xhc3RQb3MgPSBuZXdOb2RlUG9zO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHN0b3AgZHJhZyBhbmQgZHJvcFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAgKi9cclxuICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnN0b3BEcmFnID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGRkID0gS29udmEuREQsXHJcbiAgICAgICAgICAgIGV2dCA9IHt9O1xyXG4gICAgICAgIGRkLl9lbmREcmFnQmVmb3JlKGV2dCk7XHJcbiAgICAgICAgZGQuX2VuZERyYWdBZnRlcihldnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXREcmFnZ2FibGUgPSBmdW5jdGlvbihkcmFnZ2FibGUpIHtcclxuICAgICAgICB0aGlzLl9zZXRBdHRyKCdkcmFnZ2FibGUnLCBkcmFnZ2FibGUpO1xyXG4gICAgICAgIHRoaXMuX2RyYWdDaGFuZ2UoKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIG9yaWdEZXN0cm95ID0gS29udmEuTm9kZS5wcm90b3R5cGUuZGVzdHJveTtcclxuXHJcbiAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGRkID0gS29udmEuREQ7XHJcblxyXG4gICAgICAgIC8vIHN0b3AgRERcclxuICAgICAgICBpZihkZC5ub2RlICYmIGRkLm5vZGUuX2lkID09PSB0aGlzLl9pZCkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zdG9wRHJhZygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3JpZ0Rlc3Ryb3kuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBkZXRlcm1pbmUgaWYgbm9kZSBpcyBjdXJyZW50bHkgaW4gZHJhZyBhbmQgZHJvcCBtb2RlXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAqL1xyXG4gICAgS29udmEuTm9kZS5wcm90b3R5cGUuaXNEcmFnZ2luZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBkZCA9IEtvbnZhLkREO1xyXG4gICAgICAgIHJldHVybiAhIShkZC5ub2RlICYmIGRkLm5vZGUuX2lkID09PSB0aGlzLl9pZCAmJiBkZC5pc0RyYWdnaW5nKTtcclxuICAgIH07XHJcblxyXG4gICAgS29udmEuTm9kZS5wcm90b3R5cGUuX2xpc3RlbkRyYWcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgIHRoaXMuX2RyYWdDbGVhbnVwKCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmdldENsYXNzTmFtZSgpID09PSAnU3RhZ2UnKSB7XHJcbiAgICAgICAgICAgIHRoaXMub24oJ2NvbnRlbnRNb3VzZWRvd24ua29udmEgY29udGVudFRvdWNoc3RhcnQua29udmEnLCBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICAgICAgICAgIGlmKCFLb252YS5ERC5ub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zdGFydERyYWcoZXZ0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm9uKCdtb3VzZWRvd24ua29udmEgdG91Y2hzdGFydC5rb252YScsIGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIHJpZ2h0IGFuZCBtaWRkbGUgYnV0dG9uc1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2dC5ldnQuYnV0dG9uID09PSAxIHx8IGV2dC5ldnQuYnV0dG9uID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoIUtvbnZhLkRELm5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnN0YXJ0RHJhZyhldnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGxpc3RlbmluZyBpcyByZXF1aXJlZCBmb3IgZHJhZyBhbmQgZHJvcFxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgdGhpcy5fbGlzdGVuaW5nRW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fY2xlYXJTZWxmQW5kQW5jZXN0b3JDYWNoZSgnbGlzdGVuaW5nRW5hYmxlZCcpO1xyXG4gICAgICAgICovXHJcbiAgICB9O1xyXG5cclxuICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLl9kcmFnQ2hhbmdlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYodGhpcy5hdHRycy5kcmFnZ2FibGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuRHJhZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgICAgICAgICB0aGlzLl9kcmFnQ2xlYW51cCgpO1xyXG5cclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICogZm9yY2UgZHJhZyBhbmQgZHJvcCB0byBlbmRcclxuICAgICAgICAgICAgICogaWYgdGhpcyBub2RlIGlzIGN1cnJlbnRseSBpblxyXG4gICAgICAgICAgICAgKiBkcmFnIGFuZCBkcm9wIG1vZGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKTtcclxuICAgICAgICAgICAgdmFyIGRkID0gS29udmEuREQ7XHJcbiAgICAgICAgICAgIGlmKHN0YWdlICYmIGRkLm5vZGUgJiYgZGQubm9kZS5faWQgPT09IHRoaXMuX2lkKSB7XHJcbiAgICAgICAgICAgICAgICBkZC5ub2RlLnN0b3BEcmFnKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLl9kcmFnQ2xlYW51cCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmdldENsYXNzTmFtZSgpID09PSAnU3RhZ2UnKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2ZmKCdjb250ZW50TW91c2Vkb3duLmtvbnZhJyk7XHJcbiAgICAgICAgICAgIHRoaXMub2ZmKCdjb250ZW50VG91Y2hzdGFydC5rb252YScpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub2ZmKCdtb3VzZWRvd24ua29udmEnKTtcclxuICAgICAgICAgICAgdGhpcy5vZmYoJ3RvdWNoc3RhcnQua29udmEnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdkcmFnQm91bmRGdW5jJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IGRyYWcgYm91bmQgZnVuY3Rpb24uICBUaGlzIGlzIHVzZWQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRcclxuICAgICAqICBkcmFnIGFuZCBkcm9wIHBvc2l0aW9uXHJcbiAgICAgKiBAbmFtZSBkcmFnQm91bmRGdW5jXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYWdCb3VuZEZ1bmNcclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgZHJhZyBib3VuZCBmdW5jdGlvblxyXG4gICAgICogdmFyIGRyYWdCb3VuZEZ1bmMgPSBub2RlLmRyYWdCb3VuZEZ1bmMoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBjcmVhdGUgdmVydGljYWwgZHJhZyBhbmQgZHJvcFxyXG4gICAgICogbm9kZS5kcmFnQm91bmRGdW5jKGZ1bmN0aW9uKHBvcyl7XHJcbiAgICAgKiAgIHJldHVybiB7XHJcbiAgICAgKiAgICAgeDogdGhpcy5nZXRBYnNvbHV0ZVBvc2l0aW9uKCkueCxcclxuICAgICAqICAgICB5OiBwb3MueVxyXG4gICAgICogICB9O1xyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlcihLb252YS5Ob2RlLCAnZHJhZ2dhYmxlJywgZmFsc2UpO1xyXG4gICAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdkcmFnZ2FibGUnKTtcclxuXHJcbiAgICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IGRyYWdnYWJsZSBmbGFnXHJcbiAgICAgKiBAbmFtZSBkcmFnZ2FibGVcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkcmFnZ2FibGVcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBkcmFnZ2FibGUgZmxhZ1xyXG4gICAgICogdmFyIGRyYWdnYWJsZSA9IG5vZGUuZHJhZ2dhYmxlKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gZW5hYmxlIGRyYWcgYW5kIGRyb3BcclxuICAgICAqIG5vZGUuZHJhZ2dhYmxlKHRydWUpO1xyXG4gICAgICpcclxuICAgICAqIC8vIGRpc2FibGUgZHJhZyBhbmQgZHJvcFxyXG4gICAgICogbm9kZS5kcmFnZ2FibGUoZmFsc2UpO1xyXG4gICAgICovXHJcblxyXG4gICAgdmFyIGh0bWwgPSBLb252YS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBLb252YS5ERC5fZW5kRHJhZ0JlZm9yZSwgdHJ1ZSk7XHJcbiAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgS29udmEuREQuX2VuZERyYWdCZWZvcmUsIHRydWUpO1xyXG5cclxuICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgS29udmEuREQuX2RyYWcpO1xyXG4gICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBLb252YS5ERC5fZHJhZyk7XHJcblxyXG4gICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgS29udmEuREQuX2VuZERyYWdBZnRlciwgZmFsc2UpO1xyXG4gICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIEtvbnZhLkRELl9lbmREcmFnQWZ0ZXIsIGZhbHNlKTtcclxuXHJcbn0pKCk7XHJcblxuKGZ1bmN0aW9uKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWN0IGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxyXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jb3JuZXJSYWRpdXNdXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogdmFyIHJlY3QgPSBuZXcgS29udmEuUmVjdCh7XHJcbiAgICAgKiAgIHdpZHRoOiAxMDAsXHJcbiAgICAgKiAgIGhlaWdodDogNTAsXHJcbiAgICAgKiAgIGZpbGw6ICdyZWQnLFxyXG4gICAgICogICBzdHJva2U6ICdibGFjaycsXHJcbiAgICAgKiAgIHN0cm9rZVdpZHRoOiA1XHJcbiAgICAgKiB9KTtcclxuICAgICAqL1xyXG4gICAgS29udmEuUmVjdCA9IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xyXG4gICAgfTtcclxuXHJcbiAgICBLb252YS5SZWN0LnByb3RvdHlwZSA9IHtcclxuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICdSZWN0JztcclxuICAgICAgICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIGNvcm5lclJhZGl1cyA9IHRoaXMuZ2V0Q29ybmVyUmFkaXVzKCksXHJcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XHJcblxyXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG5cclxuICAgICAgICAgICAgaWYoIWNvcm5lclJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgLy8gc2ltcGxlIHJlY3QgLSBkb24ndCBib3RoZXIgZG9pbmcgYWxsIHRoYXQgY29tcGxpY2F0ZWQgbWF0aHMgc3R1ZmYuXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhcmNUbyB3b3VsZCBiZSBuaWNlciwgYnV0IGJyb3dzZXIgc3VwcG9ydCBpcyBwYXRjaHkgKE9wZXJhKVxyXG4gICAgICAgICAgICAgICAgY29ybmVyUmFkaXVzID0gTWF0aC5taW4oY29ybmVyUmFkaXVzLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oY29ybmVyUmFkaXVzLCAwKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoIC0gY29ybmVyUmFkaXVzLCAwKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuYXJjKHdpZHRoIC0gY29ybmVyUmFkaXVzLCBjb3JuZXJSYWRpdXMsIGNvcm5lclJhZGl1cywgTWF0aC5QSSAqIDMgLyAyLCAwLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCwgaGVpZ2h0IC0gY29ybmVyUmFkaXVzKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuYXJjKHdpZHRoIC0gY29ybmVyUmFkaXVzLCBoZWlnaHQgLSBjb3JuZXJSYWRpdXMsIGNvcm5lclJhZGl1cywgMCwgTWF0aC5QSSAvIDIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGNvcm5lclJhZGl1cywgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuYXJjKGNvcm5lclJhZGl1cywgaGVpZ2h0IC0gY29ybmVyUmFkaXVzLCBjb3JuZXJSYWRpdXMsIE1hdGguUEkgLyAyLCBNYXRoLlBJLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbygwLCBjb3JuZXJSYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5hcmMoY29ybmVyUmFkaXVzLCBjb3JuZXJSYWRpdXMsIGNvcm5lclJhZGl1cywgTWF0aC5QSSwgTWF0aC5QSSAqIDMgLyAyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5SZWN0LCBLb252YS5TaGFwZSk7XHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuUmVjdCwgJ2Nvcm5lclJhZGl1cycsIDApO1xyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IGNvcm5lciByYWRpdXNcclxuICAgICAqIEBuYW1lIGNvcm5lclJhZGl1c1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlJlY3QucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29ybmVyUmFkaXVzXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBjb3JuZXIgcmFkaXVzXHJcbiAgICAgKiB2YXIgY29ybmVyUmFkaXVzID0gcmVjdC5jb3JuZXJSYWRpdXMoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgY29ybmVyIHJhZGl1c1xyXG4gICAgICogcmVjdC5jb3JuZXJSYWRpdXMoMTApO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLlJlY3QpO1xyXG59KSgpO1xyXG5cbihmdW5jdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8vIHRoZSAwLjAwMDEgb2Zmc2V0IGZpeGVzIGEgYnVnIGluIENocm9tZSAyN1xyXG4gICAgdmFyIFBJeDIgPSAoTWF0aC5QSSAqIDIpIC0gMC4wMDAxLFxyXG4gICAgICAgIENJUkNMRSA9ICdDaXJjbGUnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2lyY2xlIGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxyXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnJhZGl1c1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGNyZWF0ZSBjaXJjbGVcclxuICAgICAqIHZhciBjaXJjbGUgPSBuZXcgS29udmEuQ2lyY2xlKHtcclxuICAgICAqICAgcmFkaXVzOiA0MCxcclxuICAgICAqICAgZmlsbDogJ3JlZCcsXHJcbiAgICAgKiAgIHN0cm9rZTogJ2JsYWNrJ1xyXG4gICAgICogICBzdHJva2VXaWR0aDogNVxyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuICAgIEtvbnZhLkNpcmNsZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xyXG4gICAgfTtcclxuXHJcbiAgICBLb252YS5DaXJjbGUucHJvdG90eXBlID0ge1xyXG4gICAgICAgIF9jZW50cm9pZDogdHJ1ZSxcclxuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gQ0lSQ0xFO1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCB0aGlzLmdldFJhZGl1cygpLCAwLCBQSXgyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0V2lkdGgoKVxyXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFkaXVzKCkgKiAyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0SGVpZ2h0KClcclxuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSYWRpdXMoKSAqIDI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRXaWR0aCgpXHJcbiAgICAgICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XHJcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFdpZHRoLmNhbGwodGhpcywgd2lkdGgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yYWRpdXMoKSAhPT0gd2lkdGggLyAyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJhZGl1cyh3aWR0aCAvIDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRIZWlnaHQoKVxyXG4gICAgICAgIHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldEhlaWdodC5jYWxsKHRoaXMsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJhZGl1cygpICE9PSBoZWlnaHQgLyAyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJhZGl1cyhoZWlnaHQgLyAyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5DaXJjbGUsIEtvbnZhLlNoYXBlKTtcclxuXHJcbiAgICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5DaXJjbGUsICdyYWRpdXMnLCAwKTtcclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5DaXJjbGUsICdyYWRpdXMnKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgcmFkaXVzXHJcbiAgICAgKiBAbmFtZSByYWRpdXNcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5DaXJjbGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCByYWRpdXNcclxuICAgICAqIHZhciByYWRpdXMgPSBjaXJjbGUucmFkaXVzKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IHJhZGl1c1xyXG4gICAgICogY2lyY2xlLnJhZGl1cygxMCk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuQ2lyY2xlKTtcclxufSkoKTtcclxuXG4oZnVuY3Rpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICAvLyB0aGUgMC4wMDAxIG9mZnNldCBmaXhlcyBhIGJ1ZyBpbiBDaHJvbWUgMjdcclxuICAgIHZhciBQSXgyID0gKE1hdGguUEkgKiAyKSAtIDAuMDAwMSxcclxuICAgICAgICBFTExJUFNFID0gJ0VsbGlwc2UnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRWxsaXBzZSBjb25zdHJ1Y3RvclxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcucmFkaXVzIGRlZmluZXMgeCBhbmQgeSByYWRpdXNcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiB2YXIgZWxsaXBzZSA9IG5ldyBLb252YS5FbGxpcHNlKHtcclxuICAgICAqICAgcmFkaXVzIDoge1xyXG4gICAgICogICAgIHggOiA1MCxcclxuICAgICAqICAgICB5IDogNTBcclxuICAgICAqICAgfSxcclxuICAgICAqICAgZmlsbDogJ3JlZCdcclxuICAgICAqIH0pO1xyXG4gICAgICovXHJcbiAgICBLb252YS5FbGxpcHNlID0gZnVuY3Rpb24oY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XHJcbiAgICB9O1xyXG5cclxuICAgIEtvbnZhLkVsbGlwc2UucHJvdG90eXBlID0ge1xyXG4gICAgICAgIF9jZW50cm9pZDogdHJ1ZSxcclxuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gRUxMSVBTRTtcclxuICAgICAgICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIHJ4ID0gdGhpcy5nZXRSYWRpdXNYKCksXHJcbiAgICAgICAgICAgICAgICByeSA9IHRoaXMuZ2V0UmFkaXVzWSgpO1xyXG5cclxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGlmKHJ4ICE9PSByeSkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zY2FsZSgxLCByeSAvIHJ4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByeCwgMCwgUEl4MiwgZmFsc2UpO1xyXG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRXaWR0aCgpXHJcbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSYWRpdXNYKCkgKiAyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0SGVpZ2h0KClcclxuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSYWRpdXNZKCkgKiAyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0V2lkdGgoKVxyXG4gICAgICAgIHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xyXG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRXaWR0aC5jYWxsKHRoaXMsIHdpZHRoKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRSYWRpdXMoe1xyXG4gICAgICAgICAgICAgICAgeDogd2lkdGggLyAyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0SGVpZ2h0KClcclxuICAgICAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xyXG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRIZWlnaHQuY2FsbCh0aGlzLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLnNldFJhZGl1cyh7XHJcbiAgICAgICAgICAgICAgICB5OiBoZWlnaHQgLyAyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5FbGxpcHNlLCBLb252YS5TaGFwZSk7XHJcblxyXG4gICAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xyXG4gICAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLkVsbGlwc2UsICdyYWRpdXMnLCBbJ3gnLCAneSddKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgcmFkaXVzXHJcbiAgICAgKiBAbmFtZSByYWRpdXNcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5FbGxpcHNlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJhZGl1c1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cy54XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzLnlcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IHJhZGl1c1xyXG4gICAgICogdmFyIHJhZGl1cyA9IGVsbGlwc2UucmFkaXVzKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IHJhZGl1c1xyXG4gICAgICogZWxsaXBzZS5yYWRpdXMoe1xyXG4gICAgICogICB4OiAyMDAsXHJcbiAgICAgKiAgIHk6IDEwMFxyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5FbGxpcHNlLCAncmFkaXVzWCcsIDApO1xyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IHJhZGl1cyB4XHJcbiAgICAgKiBAbmFtZSByYWRpdXNYXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRWxsaXBzZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCByYWRpdXMgeFxyXG4gICAgICogdmFyIHJhZGl1c1ggPSBlbGxpcHNlLnJhZGl1c1goKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgcmFkaXVzIHhcclxuICAgICAqIGVsbGlwc2UucmFkaXVzWCgyMDApO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuRWxsaXBzZSwgJ3JhZGl1c1knLCAwKTtcclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCByYWRpdXMgeVxyXG4gICAgICogQG5hbWUgcmFkaXVzWVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkVsbGlwc2UucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgcmFkaXVzIHlcclxuICAgICAqIHZhciByYWRpdXNZID0gZWxsaXBzZS5yYWRpdXNZKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IHJhZGl1cyB5XHJcbiAgICAgKiBlbGxpcHNlLnJhZGl1c1koMjAwKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5FbGxpcHNlKTtcclxuXHJcbn0pKCk7XHJcblxuKGZ1bmN0aW9uKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgLy8gdGhlIDAuMDAwMSBvZmZzZXQgZml4ZXMgYSBidWcgaW4gQ2hyb21lIDI3XHJcbiAgICB2YXIgUEl4MiA9IChNYXRoLlBJICogMikgLSAwLjAwMDE7XHJcbiAgICAvKipcclxuICAgICAqIFJpbmcgY29uc3RydWN0b3JcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLmlubmVyUmFkaXVzXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLm91dGVyUmFkaXVzXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuY2xvY2t3aXNlXVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHZhciByaW5nID0gbmV3IEtvbnZhLlJpbmcoe1xyXG4gICAgICogICBpbm5lclJhZGl1czogNDAsXHJcbiAgICAgKiAgIG91dGVyUmFkaXVzOiA4MCxcclxuICAgICAqICAgZmlsbDogJ3JlZCcsXHJcbiAgICAgKiAgIHN0cm9rZTogJ2JsYWNrJyxcclxuICAgICAqICAgc3Ryb2tlV2lkdGg6IDVcclxuICAgICAqIH0pO1xyXG4gICAgICovXHJcbiAgICBLb252YS5SaW5nID0gZnVuY3Rpb24oY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XHJcbiAgICB9O1xyXG5cclxuICAgIEtvbnZhLlJpbmcucHJvdG90eXBlID0ge1xyXG4gICAgICAgIF9jZW50cm9pZDogdHJ1ZSxcclxuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1JpbmcnO1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCB0aGlzLmdldElubmVyUmFkaXVzKCksIDAsIFBJeDIsIGZhbHNlKTtcclxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odGhpcy5nZXRPdXRlclJhZGl1cygpLCAwKTtcclxuICAgICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgdGhpcy5nZXRPdXRlclJhZGl1cygpLCBQSXgyLCAwLCB0cnVlKTtcclxuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRXaWR0aCgpXHJcbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPdXRlclJhZGl1cygpICogMjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldEhlaWdodCgpXHJcbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAqIDI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRXaWR0aCgpXHJcbiAgICAgICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XHJcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFdpZHRoLmNhbGwodGhpcywgd2lkdGgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vdXRlclJhZGl1cygpICE9PSB3aWR0aCAvIDIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0T3V0ZXJSYWRpdXMod2lkdGggLyAyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0SGVpZ2h0KClcclxuICAgICAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xyXG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRIZWlnaHQuY2FsbCh0aGlzLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vdXRlclJhZGl1cygpICE9PSBoZWlnaHQgLyAyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE91dGVyUmFkaXVzKGhlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRPdXRlclJhZGl1czogZnVuY3Rpb24odmFsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldEF0dHIoJ291dGVyUmFkaXVzJywgdmFsKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRXaWR0aCh2YWwgKiAyKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQodmFsICogMik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlJpbmcsIEtvbnZhLlNoYXBlKTtcclxuXHJcbiAgICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5SaW5nLCAnaW5uZXJSYWRpdXMnLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgaW5uZXJSYWRpdXNcclxuICAgICAqIEBuYW1lIGlubmVyUmFkaXVzXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuUmluZy5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbm5lclJhZGl1c1xyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgaW5uZXIgcmFkaXVzXHJcbiAgICAgKiB2YXIgaW5uZXJSYWRpdXMgPSByaW5nLmlubmVyUmFkaXVzKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IGlubmVyIHJhZGl1c1xyXG4gICAgICogcmluZy5pbm5lclJhZGl1cygyMCk7XHJcbiAgICAgKi9cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyKEtvbnZhLlJpbmcsICdvdXRlclJhZGl1cycsIDApO1xyXG4gICAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLlJpbmcsICdvdXRlclJhZGl1cycpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBvdXRlclJhZGl1c1xyXG4gICAgICogQG5hbWUgb3V0ZXJSYWRpdXNcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5SaW5nLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG91dGVyUmFkaXVzXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBvdXRlciByYWRpdXNcclxuICAgICAqIHZhciBvdXRlclJhZGl1cyA9IHJpbmcub3V0ZXJSYWRpdXMoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgb3V0ZXIgcmFkaXVzXHJcbiAgICAgKiByaW5nLm91dGVyUmFkaXVzKDIwKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5SaW5nKTtcclxufSkoKTtcclxuXG4oZnVuY3Rpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICAvKipcclxuICAgICAqIFdlZGdlIGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5hbmdsZSBpbiBkZWdyZWVzXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnJhZGl1c1xyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmNsb2Nrd2lzZV1cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBkcmF3IGEgd2VkZ2UgdGhhdCdzIHBvaW50aW5nIGRvd253YXJkc1xyXG4gICAgICogdmFyIHdlZGdlID0gbmV3IEtvbnZhLldlZGdlKHtcclxuICAgICAqICAgcmFkaXVzOiA0MCxcclxuICAgICAqICAgZmlsbDogJ3JlZCcsXHJcbiAgICAgKiAgIHN0cm9rZTogJ2JsYWNrJ1xyXG4gICAgICogICBzdHJva2VXaWR0aDogNSxcclxuICAgICAqICAgYW5nbGVEZWc6IDYwLFxyXG4gICAgICogICByb3RhdGlvbkRlZzogLTEyMFxyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuICAgIEtvbnZhLldlZGdlID0gZnVuY3Rpb24oY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XHJcbiAgICB9O1xyXG5cclxuICAgIEtvbnZhLldlZGdlLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBfY2VudHJvaWQ6IHRydWUsXHJcbiAgICAgICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XHJcbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcclxuICAgICAgICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICdXZWRnZSc7XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHRoaXMuZ2V0UmFkaXVzKCksIDAsIEtvbnZhLmdldEFuZ2xlKHRoaXMuZ2V0QW5nbGUoKSksIHRoaXMuZ2V0Q2xvY2t3aXNlKCkpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygwLCAwKTtcclxuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRXaWR0aCgpXHJcbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSYWRpdXMoKSAqIDI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRIZWlnaHQoKVxyXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJhZGl1cygpICogMjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldFdpZHRoKClcclxuICAgICAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcclxuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0V2lkdGguY2FsbCh0aGlzLCB3aWR0aCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJhZGl1cygpICE9PSB3aWR0aCAvIDIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmFkaXVzKHdpZHRoIC8gMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldEhlaWdodCgpXHJcbiAgICAgICAgc2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcclxuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0LmNhbGwodGhpcywgaGVpZ2h0KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmFkaXVzKCkgIT09IGhlaWdodCAvIDIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmFkaXVzKGhlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLldlZGdlLCBLb252YS5TaGFwZSk7XHJcblxyXG4gICAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuV2VkZ2UsICdyYWRpdXMnLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgcmFkaXVzXHJcbiAgICAgKiBAbmFtZSByYWRpdXNcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5XZWRnZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IHJhZGl1c1xyXG4gICAgICogdmFyIHJhZGl1cyA9IHdlZGdlLnJhZGl1cygpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCByYWRpdXNcclxuICAgICAqIHdlZGdlLnJhZGl1cygxMCk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5XZWRnZSwgJ2FuZ2xlJywgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IGFuZ2xlIGluIGRlZ3JlZXNcclxuICAgICAqIEBuYW1lIGFuZ2xlXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuV2VkZ2UucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGVcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGFuZ2xlXHJcbiAgICAgKiB2YXIgYW5nbGUgPSB3ZWRnZS5hbmdsZSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBhbmdsZVxyXG4gICAgICogd2VkZ2UuYW5nbGUoMjApO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuV2VkZ2UsICdjbG9ja3dpc2UnLCBmYWxzZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IGNsb2Nrd2lzZSBmbGFnXHJcbiAgICAgKiBAbmFtZSBjbG9ja3dpc2VcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5XZWRnZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjbG9ja3dpc2VcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGNsb2Nrd2lzZSBmbGFnXHJcbiAgICAgKiB2YXIgY2xvY2t3aXNlID0gd2VkZ2UuY2xvY2t3aXNlKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gZHJhdyB3ZWRnZSBjb3VudGVyLWNsb2Nrd2lzZVxyXG4gICAgICogd2VkZ2UuY2xvY2t3aXNlKGZhbHNlKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBkcmF3IHdlZGdlIGNsb2Nrd2lzZVxyXG4gICAgICogd2VkZ2UuY2xvY2t3aXNlKHRydWUpO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5iYWNrQ29tcGF0KEtvbnZhLldlZGdlLCB7XHJcbiAgICAgICAgYW5nbGVEZWc6ICdhbmdsZScsXHJcbiAgICAgICAgZ2V0QW5nbGVEZWc6ICdnZXRBbmdsZScsXHJcbiAgICAgICAgc2V0QW5nbGVEZWc6ICdzZXRBbmdsZSdcclxuICAgIH0pO1xyXG5cclxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5XZWRnZSk7XHJcbn0pKCk7XHJcblxuKGZ1bmN0aW9uKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcmMgY29uc3RydWN0b3JcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLmFuZ2xlIGluIGRlZ3JlZXNcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuaW5uZXJSYWRpdXNcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcub3V0ZXJSYWRpdXNcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5jbG9ja3dpc2VdXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZHJhdyBhIEFyYyB0aGF0J3MgcG9pbnRpbmcgZG93bndhcmRzXHJcbiAgICAgKiB2YXIgYXJjID0gbmV3IEtvbnZhLkFyYyh7XHJcbiAgICAgKiAgIGlubmVyUmFkaXVzOiA0MCxcclxuICAgICAqICAgb3V0ZXJSYWRpdXM6IDgwLFxyXG4gICAgICogICBmaWxsOiAncmVkJyxcclxuICAgICAqICAgc3Ryb2tlOiAnYmxhY2snXHJcbiAgICAgKiAgIHN0cm9rZVdpZHRoOiA1LFxyXG4gICAgICogICBhbmdsZTogNjAsXHJcbiAgICAgKiAgIHJvdGF0aW9uRGVnOiAtMTIwXHJcbiAgICAgKiB9KTtcclxuICAgICAqL1xyXG4gICAgS29udmEuQXJjID0gZnVuY3Rpb24oY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XHJcbiAgICB9O1xyXG5cclxuICAgIEtvbnZhLkFyYy5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgX2NlbnRyb2lkOiB0cnVlLFxyXG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAnQXJjJztcclxuICAgICAgICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gS29udmEuZ2V0QW5nbGUodGhpcy5hbmdsZSgpKSxcclxuICAgICAgICAgICAgICAgIGNsb2Nrd2lzZSA9IHRoaXMuY2xvY2t3aXNlKCk7XHJcblxyXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCB0aGlzLmdldE91dGVyUmFkaXVzKCksIDAsIGFuZ2xlLCBjbG9ja3dpc2UpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCB0aGlzLmdldElubmVyUmFkaXVzKCksIGFuZ2xlLCAwLCAhY2xvY2t3aXNlKTtcclxuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRXaWR0aCgpXHJcbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPdXRlclJhZGl1cygpICogMjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldEhlaWdodCgpXHJcbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAqIDI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRXaWR0aCgpXHJcbiAgICAgICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XHJcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFdpZHRoLmNhbGwodGhpcywgd2lkdGgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRPdXRlclJhZGl1cygpICE9PSB3aWR0aCAvIDIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0T3V0ZXJSYWRpdXMod2lkdGggLyAyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0SGVpZ2h0KClcclxuICAgICAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xyXG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRIZWlnaHQuY2FsbCh0aGlzLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRPdXRlclJhZGl1cygpICE9PSBoZWlnaHQgLyAyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE91dGVyUmFkaXVzKGhlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkFyYywgS29udmEuU2hhcGUpO1xyXG5cclxuICAgIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkFyYywgJ2lubmVyUmFkaXVzJywgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IGlubmVyUmFkaXVzXHJcbiAgICAgKiBAbmFtZSBpbm5lclJhZGl1c1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkFyYy5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbm5lclJhZGl1c1xyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgaW5uZXIgcmFkaXVzXHJcbiAgICAgKiB2YXIgaW5uZXJSYWRpdXMgPSBhcmMuaW5uZXJSYWRpdXMoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgaW5uZXIgcmFkaXVzXHJcbiAgICAgKiBhcmMuaW5uZXJSYWRpdXMoMjApO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuQXJjLCAnb3V0ZXJSYWRpdXMnLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgb3V0ZXJSYWRpdXNcclxuICAgICAqIEBuYW1lIG91dGVyUmFkaXVzXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQXJjLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG91dGVyUmFkaXVzXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBvdXRlciByYWRpdXNcclxuICAgICAqIHZhciBvdXRlclJhZGl1cyA9IGFyYy5vdXRlclJhZGl1cygpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBvdXRlciByYWRpdXNcclxuICAgICAqIGFyYy5vdXRlclJhZGl1cygyMCk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5BcmMsICdhbmdsZScsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBhbmdsZSBpbiBkZWdyZWVzXHJcbiAgICAgKiBAbmFtZSBhbmdsZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkFyYy5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZVxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgYW5nbGVcclxuICAgICAqIHZhciBhbmdsZSA9IGFyYy5hbmdsZSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBhbmdsZVxyXG4gICAgICogYXJjLmFuZ2xlKDIwKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkFyYywgJ2Nsb2Nrd2lzZScsIGZhbHNlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgY2xvY2t3aXNlIGZsYWdcclxuICAgICAqIEBuYW1lIGNsb2Nrd2lzZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkFyYy5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xvY2t3aXNlXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgY2xvY2t3aXNlIGZsYWdcclxuICAgICAqIHZhciBjbG9ja3dpc2UgPSBhcmMuY2xvY2t3aXNlKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gZHJhdyBhcmMgY291bnRlci1jbG9ja3dpc2VcclxuICAgICAqIGFyYy5jbG9ja3dpc2UoZmFsc2UpO1xyXG4gICAgICpcclxuICAgICAqIC8vIGRyYXcgYXJjIGNsb2Nrd2lzZVxyXG4gICAgICogYXJjLmNsb2Nrd2lzZSh0cnVlKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5BcmMpO1xyXG59KSgpO1xyXG5cbihmdW5jdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8vIENPTlNUQU5UU1xyXG4gICAgdmFyIElNQUdFID0gJ0ltYWdlJztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEltYWdlIGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxyXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXHJcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBjb25maWcuaW1hZ2VcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmNyb3BdXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogdmFyIGltYWdlT2JqID0gbmV3IEltYWdlKCk7XHJcbiAgICAgKiBpbWFnZU9iai5vbmxvYWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAqICAgdmFyIGltYWdlID0gbmV3IEtvbnZhLkltYWdlKHtcclxuICAgICAqICAgICB4OiAyMDAsXHJcbiAgICAgKiAgICAgeTogNTAsXHJcbiAgICAgKiAgICAgaW1hZ2U6IGltYWdlT2JqLFxyXG4gICAgICogICAgIHdpZHRoOiAxMDAsXHJcbiAgICAgKiAgICAgaGVpZ2h0OiAxMDBcclxuICAgICAqICAgfSk7XHJcbiAgICAgKiB9O1xyXG4gICAgICogaW1hZ2VPYmouc3JjID0gJy9wYXRoL3RvL2ltYWdlLmpwZydcclxuICAgICAqL1xyXG4gICAgS29udmEuSW1hZ2UgPSBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcclxuICAgIH07XHJcblxyXG4gICAgS29udmEuSW1hZ2UucHJvdG90eXBlID0ge1xyXG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBJTUFHRTtcclxuICAgICAgICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcclxuICAgICAgICAgICAgdGhpcy5oaXRGdW5jKHRoaXMuX2hpdEZ1bmMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3VzZUJ1ZmZlckNhbnZhczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5oYXNTaGFkb3coKSB8fCB0aGlzLmdldEFic29sdXRlT3BhY2l0eSgpICE9PSAxKSAmJiB0aGlzLmhhc1N0cm9rZSgpICYmIHRoaXMuZ2V0U3RhZ2UoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKSxcclxuICAgICAgICAgICAgICAgIGltYWdlID0gdGhpcy5nZXRJbWFnZSgpLFxyXG4gICAgICAgICAgICAgICAgY3JvcFdpZHRoLCBjcm9wSGVpZ2h0LCBwYXJhbXM7XHJcblxyXG4gICAgICAgICAgICBpZiAoaW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgIGNyb3BXaWR0aCA9IHRoaXMuZ2V0Q3JvcFdpZHRoKCk7XHJcbiAgICAgICAgICAgICAgICBjcm9wSGVpZ2h0ID0gdGhpcy5nZXRDcm9wSGVpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3JvcFdpZHRoICYmIGNyb3BIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBbaW1hZ2UsIHRoaXMuZ2V0Q3JvcFgoKSwgdGhpcy5nZXRDcm9wWSgpLCBjcm9wV2lkdGgsIGNyb3BIZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHRdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBbaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNGaWxsKCkgfHwgdGhpcy5oYXNTdHJva2UoKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGltYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZS5hcHBseShjb250ZXh0LCBwYXJhbXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfaGl0RnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZHRoKCksXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xyXG5cclxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY29udGV4dC5yZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGltYWdlID0gdGhpcy5nZXRJbWFnZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRycy53aWR0aCB8fCAoaW1hZ2UgPyBpbWFnZS53aWR0aCA6IDApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGltYWdlID0gdGhpcy5nZXRJbWFnZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRycy5oZWlnaHQgfHwgKGltYWdlID8gaW1hZ2UuaGVpZ2h0IDogMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkltYWdlLCBLb252YS5TaGFwZSk7XHJcblxyXG4gICAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuSW1hZ2UsICdpbWFnZScpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2V0IGltYWdlXHJcbiAgICAgKiBAbmFtZSBzZXRJbWFnZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0IGltYWdlXHJcbiAgICAgKiBAbmFtZSBnZXRJbWFnZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlLnByb3RvdHlwZVxyXG4gICAgICogQHJldHVybnMge0ltYWdlfVxyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLkltYWdlLCAnY3JvcCcsIFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCddKTtcclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBjcm9wXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbmFtZSBjcm9wXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuSW1hZ2UucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY3JvcFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNyb3AueFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNyb3AueVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNyb3Aud2lkdGhcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjcm9wLmhlaWdodFxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgY3JvcFxyXG4gICAgICogdmFyIGNyb3AgPSBpbWFnZS5jcm9wKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IGNyb3BcclxuICAgICAqIGltYWdlLmNyb3Aoe1xyXG4gICAgICogICB4OiAyMCxcclxuICAgICAqICAgeTogMjAsXHJcbiAgICAgKiAgIHdpZHRoOiAyMCxcclxuICAgICAqICAgaGVpZ2h0OiAyMFxyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5JbWFnZSwgJ2Nyb3BYJywgMCk7XHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgY3JvcCB4XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbmFtZSBjcm9wWFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGNyb3AgeFxyXG4gICAgICogdmFyIGNyb3BYID0gaW1hZ2UuY3JvcFgoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgY3JvcCB4XHJcbiAgICAgKiBpbWFnZS5jcm9wWCgyMCk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5JbWFnZSwgJ2Nyb3BZJywgMCk7XHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgY3JvcCB5XHJcbiAgICAgKiBAbmFtZSBjcm9wWVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGNyb3AgeVxyXG4gICAgICogdmFyIGNyb3BZID0gaW1hZ2UuY3JvcFkoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgY3JvcCB5XHJcbiAgICAgKiBpbWFnZS5jcm9wWSgyMCk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5JbWFnZSwgJ2Nyb3BXaWR0aCcsIDApO1xyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IGNyb3Agd2lkdGhcclxuICAgICAqIEBuYW1lIGNyb3BXaWR0aFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBjcm9wIHdpZHRoXHJcbiAgICAgKiB2YXIgY3JvcFdpZHRoID0gaW1hZ2UuY3JvcFdpZHRoKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IGNyb3Agd2lkdGhcclxuICAgICAqIGltYWdlLmNyb3BXaWR0aCgyMCk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5JbWFnZSwgJ2Nyb3BIZWlnaHQnLCAwKTtcclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBjcm9wIGhlaWdodFxyXG4gICAgICogQG5hbWUgY3JvcEhlaWdodFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgY3JvcCBoZWlnaHRcclxuICAgICAqIHZhciBjcm9wSGVpZ2h0ID0gaW1hZ2UuY3JvcEhlaWdodCgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBjcm9wIGhlaWdodFxyXG4gICAgICogaW1hZ2UuY3JvcEhlaWdodCgyMCk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuSW1hZ2UpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogbG9hZCBpbWFnZSBmcm9tIGdpdmVuIHVybCBhbmQgY3JlYXRlIGBLb252YS5JbWFnZWAgaW5zdGFuY2VcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5JbWFnZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBpbWFnZSBzb3VyY2VcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHdpdGggS29udmEuSW1hZ2UgaW5zdGFuY2UgYXMgZmlyc3QgYXJndW1lbnRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgS29udmEuSW1hZ2UuZnJvbVVSTChpbWFnZVVSTCwgZnVuY3Rpb24oaW1hZ2Upe1xyXG4gICAgICogICAgLy8gaW1hZ2UgaXMgS29udmEuSW1hZ2UgaW5zdGFuY2VcclxuICAgICAqICAgIGxheWVyLmFkZChpbWFnZSk7XHJcbiAgICAgKiAgICBsYXllci5kcmF3KCk7XHJcbiAgICAgKiAgfSk7XHJcbiAgICAgKi9cclxuICAgIEtvbnZhLkltYWdlLmZyb21VUkwgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciBpbWFnZSA9IG5ldyBLb252YS5JbWFnZSh7XHJcbiAgICAgICAgICAgIGltYWdlOiBpbWdcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgY2FsbGJhY2soaW1hZ2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaW1nLnNyYyA9IHVybDtcclxuICAgIH07XHJcbn0pKCk7XHJcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtZGVwdGggKi9cclxuKGZ1bmN0aW9uKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgLy8gY29uc3RhbnRzXHJcbiAgICB2YXIgQVVUTyA9ICdhdXRvJyxcclxuICAgICAgICAvL0NBTlZBUyA9ICdjYW52YXMnLFxyXG4gICAgICAgIENFTlRFUiA9ICdjZW50ZXInLFxyXG4gICAgICAgIENIQU5HRV9LT05WQSA9ICdDaGFuZ2Uua29udmEnLFxyXG4gICAgICAgIENPTlRFWFRfMkQgPSAnMmQnLFxyXG4gICAgICAgIERBU0ggPSAnLScsXHJcbiAgICAgICAgRU1QVFlfU1RSSU5HID0gJycsXHJcbiAgICAgICAgTEVGVCA9ICdsZWZ0JyxcclxuICAgICAgICBURVhUID0gJ3RleHQnLFxyXG4gICAgICAgIFRFWFRfVVBQRVIgPSAnVGV4dCcsXHJcbiAgICAgICAgTUlERExFID0gJ21pZGRsZScsXHJcbiAgICAgICAgTk9STUFMID0gJ25vcm1hbCcsXHJcbiAgICAgICAgUFhfU1BBQ0UgPSAncHggJyxcclxuICAgICAgICBTUEFDRSA9ICcgJyxcclxuICAgICAgICBSSUdIVCA9ICdyaWdodCcsXHJcbiAgICAgICAgV09SRCA9ICd3b3JkJyxcclxuICAgICAgICBDSEFSID0gJ2NoYXInLFxyXG4gICAgICAgIE5PTkUgPSAnbm9uZScsXHJcbiAgICAgICAgQVRUUl9DSEFOR0VfTElTVCA9IFsnZm9udEZhbWlseScsICdmb250U2l6ZScsICdmb250U3R5bGUnLCAnZm9udFZhcmlhbnQnLCAncGFkZGluZycsICdhbGlnbicsICdsaW5lSGVpZ2h0JywgJ3RleHQnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ3dyYXAnXSxcclxuXHJcbiAgICAgICAgLy8gY2FjaGVkIHZhcmlhYmxlc1xyXG4gICAgICAgIGF0dHJDaGFuZ2VMaXN0TGVuID0gQVRUUl9DSEFOR0VfTElTVC5sZW5ndGgsXHJcbiAgICAgICAgZHVtbXlDb250ZXh0ID0gS29udmEuVXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCkuZ2V0Q29udGV4dChDT05URVhUXzJEKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRleHQgY29uc3RydWN0b3JcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXHJcbiAgICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZvbnRGYW1pbHldIGRlZmF1bHQgaXMgQXJpYWxcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZvbnRTaXplXSBpbiBwaXhlbHMuICBEZWZhdWx0IGlzIDEyXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5mb250U3R5bGVdIGNhbiBiZSBub3JtYWwsIGJvbGQsIG9yIGl0YWxpYy4gIERlZmF1bHQgaXMgbm9ybWFsXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5mb250VmFyaWFudF0gY2FuIGJlIG5vcm1hbCBvciBzbWFsbC1jYXBzLiAgRGVmYXVsdCBpcyBub3JtYWxcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcudGV4dFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuYWxpZ25dIGNhbiBiZSBsZWZ0LCBjZW50ZXIsIG9yIHJpZ2h0XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5wYWRkaW5nXVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdIGRlZmF1bHQgaXMgYXV0b1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XSBkZWZhdWx0IGlzIGF1dG9cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmxpbmVIZWlnaHRdIGRlZmF1bHQgaXMgMVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcud3JhcF0gY2FuIGJlIHdvcmQsIGNoYXIsIG9yIG5vbmUuIERlZmF1bHQgaXMgd29yZFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHZhciB0ZXh0ID0gbmV3IEtvbnZhLlRleHQoe1xyXG4gICAgICogICB4OiAxMCxcclxuICAgICAqICAgeTogMTUsXHJcbiAgICAgKiAgIHRleHQ6ICdTaW1wbGUgVGV4dCcsXHJcbiAgICAgKiAgIGZvbnRTaXplOiAzMCxcclxuICAgICAqICAgZm9udEZhbWlseTogJ0NhbGlicmknLFxyXG4gICAgICogICBmaWxsOiAnZ3JlZW4nXHJcbiAgICAgKiB9KTtcclxuICAgICAqL1xyXG4gICAgS29udmEuVGV4dCA9IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIF9maWxsRnVuYyhjb250ZXh0KSB7XHJcbiAgICAgICAgY29udGV4dC5maWxsVGV4dCh0aGlzLnBhcnRpYWxUZXh0LCAwLCAwKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIF9zdHJva2VGdW5jKGNvbnRleHQpIHtcclxuICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQodGhpcy5wYXJ0aWFsVGV4dCwgMCwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgS29udmEuVGV4dC5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuXHJcbiAgICAgICAgICAgIC8vIHNldCBkZWZhdWx0IGNvbG9yIHRvIGJsYWNrXHJcbiAgICAgICAgICAgIGlmICghY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMgJiYgIWNvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWcuZmlsbCA9IGNvbmZpZy5maWxsIHx8ICdibGFjayc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb25maWcud2lkdGggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgY29uZmlnLndpZHRoID0gQVVUTztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWcuaGVpZ2h0ID0gQVVUTztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9maWxsRnVuYyA9IF9maWxsRnVuYztcclxuICAgICAgICAgICAgdGhpcy5fc3Ryb2tlRnVuYyA9IF9zdHJva2VGdW5jO1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFRFWFRfVVBQRVI7XHJcblxyXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGV4dCBkYXRhIGZvciBjZXJ0YWluIGF0dHIgY2hhbmdlc1xyXG4gICAgICAgICAgICBmb3IodmFyIG4gPSAwOyBuIDwgYXR0ckNoYW5nZUxpc3RMZW47IG4rKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbihBVFRSX0NIQU5HRV9MSVNUW25dICsgQ0hBTkdFX0tPTlZBLCB0aGlzLl9zZXRUZXh0RGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3NldFRleHREYXRhKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XHJcbiAgICAgICAgICAgIHRoaXMuaGl0RnVuYyh0aGlzLl9oaXRGdW5jKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIHAgPSB0aGlzLmdldFBhZGRpbmcoKSxcclxuICAgICAgICAgICAgICAgIHRleHRIZWlnaHQgPSB0aGlzLmdldFRleHRIZWlnaHQoKSxcclxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHRQeCA9IHRoaXMuZ2V0TGluZUhlaWdodCgpICogdGV4dEhlaWdodCxcclxuICAgICAgICAgICAgICAgIHRleHRBcnIgPSB0aGlzLnRleHRBcnIsXHJcbiAgICAgICAgICAgICAgICB0ZXh0QXJyTGVuID0gdGV4dEFyci5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICB0b3RhbFdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgbjtcclxuXHJcbiAgICAgICAgICAgIGNvbnRleHQuc2V0QXR0cignZm9udCcsIHRoaXMuX2dldENvbnRleHRGb250KCkpO1xyXG5cclxuICAgICAgICAgICAgY29udGV4dC5zZXRBdHRyKCd0ZXh0QmFzZWxpbmUnLCBNSURETEUpO1xyXG4gICAgICAgICAgICBjb250ZXh0LnNldEF0dHIoJ3RleHRBbGlnbicsIExFRlQpO1xyXG4gICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcclxuICAgICAgICAgICAgaWYgKHApIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKHAsIDApO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoMCwgcCArIHRleHRIZWlnaHQgLyAyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKDAsIHRleHRIZWlnaHQgLyAyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIGRyYXcgdGV4dCBsaW5lc1xyXG4gICAgICAgICAgICBmb3IobiA9IDA7IG4gPCB0ZXh0QXJyTGVuOyBuKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBvYmogPSB0ZXh0QXJyW25dLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSBvYmoudGV4dCxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IG9iai53aWR0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBob3Jpem9udGFsIGFsaWdubWVudFxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmdldEFsaWduKCkgPT09IFJJR0hUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUodG90YWxXaWR0aCAtIHdpZHRoIC0gcCAqIDIsIDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZih0aGlzLmdldEFsaWduKCkgPT09IENFTlRFUikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKCh0b3RhbFdpZHRoIC0gd2lkdGggLSBwICogMikgLyAyLCAwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpYWxUZXh0ID0gdGV4dDtcclxuXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoMCwgbGluZUhlaWdodFB4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9oaXRGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XHJcblxyXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjb250ZXh0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0VGV4dDogZnVuY3Rpb24odGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgc3RyID0gS29udmEuVXRpbC5faXNTdHJpbmcodGV4dCkgPyB0ZXh0IDogdGV4dC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRBdHRyKFRFWFQsIHN0cik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogZ2V0IHdpZHRoIG9mIHRleHQgYXJlYSwgd2hpY2ggaW5jbHVkZXMgcGFkZGluZ1xyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cnMud2lkdGggPT09IEFVVE8gPyB0aGlzLmdldFRleHRXaWR0aCgpICsgdGhpcy5nZXRQYWRkaW5nKCkgKiAyIDogdGhpcy5hdHRycy53aWR0aDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGdldCB0aGUgaGVpZ2h0IG9mIHRoZSB0ZXh0IGFyZWEsIHdoaWNoIHRha2VzIGludG8gYWNjb3VudCBtdWx0aS1saW5lIHRleHQsIGxpbmUgaGVpZ2h0cywgYW5kIHBhZGRpbmdcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRycy5oZWlnaHQgPT09IEFVVE8gPyAodGhpcy5nZXRUZXh0SGVpZ2h0KCkgKiB0aGlzLnRleHRBcnIubGVuZ3RoICogdGhpcy5nZXRMaW5lSGVpZ2h0KCkpICsgdGhpcy5nZXRQYWRkaW5nKCkgKiAyIDogdGhpcy5hdHRycy5oZWlnaHQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBnZXQgdGV4dCB3aWR0aFxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFRleHRXaWR0aDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHRXaWR0aDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGdldCB0ZXh0IGhlaWdodFxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFRleHRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0SGVpZ2h0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldFRleHRTaXplOiBmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBfY29udGV4dCA9IGR1bW15Q29udGV4dCxcclxuICAgICAgICAgICAgICAgIGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpLFxyXG4gICAgICAgICAgICAgICAgbWV0cmljcztcclxuXHJcbiAgICAgICAgICAgIF9jb250ZXh0LnNhdmUoKTtcclxuICAgICAgICAgICAgX2NvbnRleHQuZm9udCA9IHRoaXMuX2dldENvbnRleHRGb250KCk7XHJcblxyXG4gICAgICAgICAgICBtZXRyaWNzID0gX2NvbnRleHQubWVhc3VyZVRleHQodGV4dCk7XHJcbiAgICAgICAgICAgIF9jb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBtZXRyaWNzLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBwYXJzZUludChmb250U2l6ZSwgMTApXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0Q29udGV4dEZvbnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGb250U3R5bGUoKSArIFNQQUNFICsgdGhpcy5nZXRGb250VmFyaWFudCgpICsgU1BBQ0UgKyB0aGlzLmdldEZvbnRTaXplKCkgKyBQWF9TUEFDRSArIHRoaXMuZ2V0Rm9udEZhbWlseSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2FkZFRleHRMaW5lOiBmdW5jdGlvbiAobGluZSwgd2lkdGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dEFyci5wdXNoKHt0ZXh0OiBsaW5lLCB3aWR0aDogd2lkdGh9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRUZXh0V2lkdGg6IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkdW1teUNvbnRleHQubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfc2V0VGV4dERhdGE6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGxpbmVzID0gdGhpcy5nZXRUZXh0KCkuc3BsaXQoJ1xcbicpLFxyXG4gICAgICAgICAgICAgICAgZm9udFNpemUgPSArdGhpcy5nZXRGb250U2l6ZSgpLFxyXG4gICAgICAgICAgICAgICAgdGV4dFdpZHRoID0gMCxcclxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHRQeCA9IHRoaXMuZ2V0TGluZUhlaWdodCgpICogZm9udFNpemUsXHJcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHRoaXMuYXR0cnMud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmF0dHJzLmhlaWdodCxcclxuICAgICAgICAgICAgICAgIGZpeGVkV2lkdGggPSB3aWR0aCAhPT0gQVVUTyxcclxuICAgICAgICAgICAgICAgIGZpeGVkSGVpZ2h0ID0gaGVpZ2h0ICE9PSBBVVRPLFxyXG4gICAgICAgICAgICAgICAgcGFkZGluZyA9IHRoaXMuZ2V0UGFkZGluZygpLFxyXG4gICAgICAgICAgICAgICAgbWF4V2lkdGggPSB3aWR0aCAtIHBhZGRpbmcgKiAyLFxyXG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0UHggPSBoZWlnaHQgLSBwYWRkaW5nICogMixcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRIZWlnaHRQeCA9IDAsXHJcbiAgICAgICAgICAgICAgICB3cmFwID0gdGhpcy5nZXRXcmFwKCksXHJcbiAgICAgICAgICAgICAgICBzaG91bGRXcmFwID0gd3JhcCAhPT0gTk9ORSxcclxuICAgICAgICAgICAgICAgIHdyYXBBdFdvcmQgPSB3cmFwICE9PSBDSEFSICYmIHNob3VsZFdyYXA7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRleHRBcnIgPSBbXTtcclxuICAgICAgICAgICAgZHVtbXlDb250ZXh0LnNhdmUoKTtcclxuICAgICAgICAgICAgZHVtbXlDb250ZXh0LmZvbnQgPSB0aGlzLl9nZXRDb250ZXh0Rm9udCgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbWF4ID0gbGluZXMubGVuZ3RoOyBpIDwgbWF4OyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gbGluZXNbaV0sXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoID0gdGhpcy5fZ2V0VGV4dFdpZHRoKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpeGVkV2lkdGggJiYgbGluZVdpZHRoID4gbWF4V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIGlmIHdpZHRoIGlzIGZpeGVkIGFuZCBsaW5lIGRvZXMgbm90IGZpdCBlbnRpcmVseVxyXG4gICAgICAgICAgICAgICAgICAgICAqIGJyZWFrIHRoZSBsaW5lIGludG8gbXVsdGlwbGUgZml0dGluZyBsaW5lc1xyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChsaW5lLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogdXNlIGJpbmFyeSBzZWFyY2ggdG8gZmluZCB0aGUgbG9uZ2VzdCBzdWJzdHJpbmcgdGhhdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGF0IHdvdWxkIGZpdCBpbiB0aGUgc3BlY2lmaWVkIHdpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGxpbmUubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSAnJywgbWF0Y2hXaWR0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0ciA9IGxpbmUuc2xpY2UoMCwgbWlkICsgMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RyV2lkdGggPSB0aGlzLl9nZXRUZXh0V2lkdGgoc3Vic3RyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJzdHJXaWR0aCA8PSBtYXhXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBzdWJzdHI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hXaWR0aCA9IHN1YnN0cldpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoID0gbWlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqICdsb3cnIGlzIG5vdyB0aGUgaW5kZXggb2YgdGhlIHN1YnN0cmluZyBlbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogJ21hdGNoJyBpcyB0aGUgc3Vic3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqICdtYXRjaFdpZHRoJyBpcyB0aGUgc3Vic3RyaW5nIHdpZHRoIGluIHB4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgZml0dGluZyBzdWJzdHJpbmcgd2FzIGZvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod3JhcEF0V29yZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0byBmaW5kIGEgc3BhY2Ugb3IgZGFzaCB3aGVyZSB3cmFwcGluZyBjb3VsZCBiZSBkb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXBJbmRleCA9IE1hdGgubWF4KG1hdGNoLmxhc3RJbmRleE9mKFNQQUNFKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoLmxhc3RJbmRleE9mKERBU0gpKSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdyYXBJbmRleCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmUtY3V0IHRoZSBzdWJzdHJpbmcgZm91bmQgYXQgdGhlIHNwYWNlL2Rhc2ggcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ID0gd3JhcEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoLnNsaWNlKDAsIGxvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoV2lkdGggPSB0aGlzLl9nZXRUZXh0V2lkdGgobWF0Y2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRleHRMaW5lKG1hdGNoLCBtYXRjaFdpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRXaWR0aCA9IE1hdGgubWF4KHRleHRXaWR0aCwgbWF0Y2hXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50SGVpZ2h0UHggKz0gbGluZUhlaWdodFB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG91bGRXcmFwIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZpeGVkSGVpZ2h0ICYmIGN1cnJlbnRIZWlnaHRQeCArIGxpbmVIZWlnaHRQeCA+IG1heEhlaWdodFB4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogc3RvcCB3cmFwcGluZyBpZiB3cmFwcGluZyBpcyBkaXNhYmxlZCBvciBpZiBhZGRpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBvbmUgbW9yZSBsaW5lIHdvdWxkIG92ZXJmbG93IHRoZSBmaXhlZCBoZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKGxvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJlbWFpbmluZyB0ZXh0IHdvdWxkIGZpdCBvbiBvbmUgbGluZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCA9IHRoaXMuX2dldFRleHRXaWR0aChsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZVdpZHRoIDw9IG1heFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0IGRvZXMsIGFkZCB0aGUgbGluZSBhbmQgYnJlYWsgb3V0IG9mIHRoZSBsb29wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRleHRMaW5lKGxpbmUsIGxpbmVXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRIZWlnaHRQeCArPSBsaW5lSGVpZ2h0UHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRXaWR0aCA9IE1hdGgubWF4KHRleHRXaWR0aCwgbGluZVdpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IGV2ZW4gb25lIGNoYXJhY3RlciBjb3VsZCBmaXQgaW4gdGhlIGVsZW1lbnQsIGFib3J0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxlbWVudCB3aWR0aCBpcyBhdXRvbWF0aWNhbGx5IGFkanVzdGVkIHRvIG1heCBsaW5lIHdpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVGV4dExpbmUobGluZSwgbGluZVdpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50SGVpZ2h0UHggKz0gbGluZUhlaWdodFB4O1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRXaWR0aCA9IE1hdGgubWF4KHRleHRXaWR0aCwgbGluZVdpZHRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGlmIGVsZW1lbnQgaGVpZ2h0IGlzIGZpeGVkLCBhYm9ydCBpZiBhZGRpbmcgb25lIG1vcmUgbGluZSB3b3VsZCBvdmVyZmxvd1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpeGVkSGVpZ2h0ICYmIGN1cnJlbnRIZWlnaHRQeCArIGxpbmVIZWlnaHRQeCA+IG1heEhlaWdodFB4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZHVtbXlDb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgdGhpcy50ZXh0SGVpZ2h0ID0gZm9udFNpemU7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dFdpZHRoID0gdGV4dFdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5UZXh0LCBLb252YS5TaGFwZSk7XHJcblxyXG4gICAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dCwgJ2ZvbnRGYW1pbHknLCAnQXJpYWwnKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgZm9udCBmYW1pbHlcclxuICAgICAqIEBuYW1lIGZvbnRGYW1pbHlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvbnRGYW1pbHlcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGZvbnQgZmFtaWx5XHJcbiAgICAgKiB2YXIgZm9udEZhbWlseSA9IHRleHQuZm9udEZhbWlseSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBmb250IGZhbWlseVxyXG4gICAgICogdGV4dC5mb250RmFtaWx5KCdBcmlhbCcpO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dCwgJ2ZvbnRTaXplJywgMTIpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBmb250IHNpemUgaW4gcGl4ZWxzXHJcbiAgICAgKiBAbmFtZSBmb250U2l6ZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZm9udFNpemVcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGZvbnQgc2l6ZVxyXG4gICAgICogdmFyIGZvbnRTaXplID0gdGV4dC5mb250U2l6ZSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBmb250IHNpemUgdG8gMjJweFxyXG4gICAgICogdGV4dC5mb250U2l6ZSgyMik7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0LCAnZm9udFN0eWxlJywgTk9STUFMKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHNldCBmb250IHN0eWxlLiAgQ2FuIGJlICdub3JtYWwnLCAnaXRhbGljJywgb3IgJ2JvbGQnLiAgJ25vcm1hbCcgaXMgdGhlIGRlZmF1bHQuXHJcbiAgICAgKiBAbmFtZSBmb250U3R5bGVcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvbnRTdHlsZVxyXG4gICAgICogQHJldHVybnMge1N0cmluZ31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgZm9udCBzdHlsZVxyXG4gICAgICogdmFyIGZvbnRTdHlsZSA9IHRleHQuZm9udFN0eWxlKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IGZvbnQgc3R5bGVcclxuICAgICAqIHRleHQuZm9udFN0eWxlKCdib2xkJyk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0LCAnZm9udFZhcmlhbnQnLCBOT1JNQUwpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2V0IGZvbnQgdmFyaWFudC4gIENhbiBiZSAnbm9ybWFsJyBvciAnc21hbGwtY2FwcycuICAnbm9ybWFsJyBpcyB0aGUgZGVmYXVsdC5cclxuICAgICAqIEBuYW1lIGZvbnRWYXJpYW50XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb250VmFyaWFudFxyXG4gICAgICogQHJldHVybnMge1N0cmluZ31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgZm9udCB2YXJpYW50XHJcbiAgICAgKiB2YXIgZm9udFZhcmlhbnQgPSB0ZXh0LmZvbnRWYXJpYW50KCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IGZvbnQgdmFyaWFudFxyXG4gICAgICogdGV4dC5mb250VmFyaWFudCgnc21hbGwtY2FwcycpO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dCwgJ3BhZGRpbmcnLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHNldCBwYWRkaW5nXHJcbiAgICAgKiBAbmFtZSBwYWRkaW5nXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwYWRkaW5nXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBwYWRkaW5nXHJcbiAgICAgKiB2YXIgcGFkZGluZyA9IHRleHQucGFkZGluZygpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBwYWRkaW5nIHRvIDEwIHBpeGVsc1xyXG4gICAgICogdGV4dC5wYWRkaW5nKDEwKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICdhbGlnbicsIExFRlQpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBob3Jpem9udGFsIGFsaWduIG9mIHRleHQuICBDYW4gYmUgJ2xlZnQnLCAnY2VudGVyJywgb3IgJ3JpZ2h0J1xyXG4gICAgICogQG5hbWUgYWxpZ25cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFsaWduXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCB0ZXh0IGFsaWduXHJcbiAgICAgKiB2YXIgYWxpZ24gPSB0ZXh0LmFsaWduKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gY2VudGVyIHRleHRcclxuICAgICAqIHRleHQuYWxpZ24oJ2NlbnRlcicpO1xyXG4gICAgICpcclxuICAgICAqIC8vIGFsaWduIHRleHQgdG8gcmlnaHRcclxuICAgICAqIHRleHQuYWxpZ24oJ3JpZ2h0Jyk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0LCAnbGluZUhlaWdodCcsIDEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBsaW5lIGhlaWdodC4gIFRoZSBkZWZhdWx0IGlzIDEuXHJcbiAgICAgKiBAbmFtZSBsaW5lSGVpZ2h0XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSGVpZ2h0XHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBsaW5lIGhlaWdodFxyXG4gICAgICogdmFyIGxpbmVIZWlnaHQgPSB0ZXh0LmxpbmVIZWlnaHQoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgdGhlIGxpbmUgaGVpZ2h0XHJcbiAgICAgKiB0ZXh0LmxpbmVIZWlnaHQoMik7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0LCAnd3JhcCcsIFdPUkQpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCB3cmFwLiAgQ2FuIGJlIHdvcmQsIGNoYXIsIG9yIG5vbmUuIERlZmF1bHQgaXMgd29yZC5cclxuICAgICAqIEBuYW1lIHdyYXBcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHdyYXBcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IHdyYXBcclxuICAgICAqIHZhciB3cmFwID0gdGV4dC53cmFwKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IHdyYXBcclxuICAgICAqIHRleHQud3JhcCgnd29yZCcpO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXIoS29udmEuVGV4dCwgJ3RleHQnLCBFTVBUWV9TVFJJTkcpO1xyXG4gICAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICd0ZXh0Jyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IHRleHRcclxuICAgICAqIEBuYW1lIGdldFRleHRcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IHRleHRcclxuICAgICAqIHZhciB0ZXh0ID0gdGV4dC50ZXh0KCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IHRleHRcclxuICAgICAqIHRleHQudGV4dCgnSGVsbG8gd29ybGQhJyk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuVGV4dCk7XHJcbn0pKCk7XHJcblxuKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8qKlxyXG4gICAgICogTGluZSBjb25zdHJ1Y3Rvci4mbmJzcDsgTGluZXMgYXJlIGRlZmluZWQgYnkgYW4gYXJyYXkgb2YgcG9pbnRzIGFuZFxyXG4gICAgICogIGEgdGVuc2lvblxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcclxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xyXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29uZmlnLnBvaW50c1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcudGVuc2lvbl0gSGlnaGVyIHZhbHVlcyB3aWxsIHJlc3VsdCBpbiBhIG1vcmUgY3VydnkgbGluZS4gIEEgdmFsdWUgb2YgMCB3aWxsIHJlc3VsdCBpbiBubyBpbnRlcnBvbGF0aW9uLlxyXG4gICAgICogICBUaGUgZGVmYXVsdCBpcyAwXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuY2xvc2VkXSBkZWZpbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBsaW5lIHNoYXBlIGlzIGNsb3NlZCwgY3JlYXRpbmcgYSBwb2x5Z29uIG9yIGJsb2JcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiB2YXIgbGluZSA9IG5ldyBLb252YS5MaW5lKHtcclxuICAgICAqICAgeDogMTAwLFxyXG4gICAgICogICB5OiA1MCxcclxuICAgICAqICAgcG9pbnRzOiBbNzMsIDcwLCAzNDAsIDIzLCA0NTAsIDYwLCA1MDAsIDIwXSxcclxuICAgICAqICAgc3Ryb2tlOiAncmVkJyxcclxuICAgICAqICAgdGVuc2lvbjogMVxyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuICAgIEtvbnZhLkxpbmUgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XHJcbiAgICB9O1xyXG5cclxuICAgIEtvbnZhLkxpbmUucHJvdG90eXBlID0ge1xyXG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ0xpbmUnO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5vbigncG9pbnRzQ2hhbmdlLmtvbnZhIHRlbnNpb25DaGFuZ2Uua29udmEgY2xvc2VkQ2hhbmdlLmtvbnZhJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJDYWNoZSgndGVuc2lvblBvaW50cycpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5nZXRQb2ludHMoKSxcclxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHBvaW50cy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICB0ZW5zaW9uID0gdGhpcy5nZXRUZW5zaW9uKCksXHJcbiAgICAgICAgICAgICAgICBjbG9zZWQgPSB0aGlzLmdldENsb3NlZCgpLFxyXG4gICAgICAgICAgICAgICAgdHAsIGxlbiwgbjtcclxuXHJcbiAgICAgICAgICAgIGlmICghbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHRlbnNpb25cclxuICAgICAgICAgICAgaWYgKHRlbnNpb24gIT09IDAgJiYgbGVuZ3RoID4gNCkge1xyXG4gICAgICAgICAgICAgICAgdHAgPSB0aGlzLmdldFRlbnNpb25Qb2ludHMoKTtcclxuICAgICAgICAgICAgICAgIGxlbiA9IHRwLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIG4gPSBjbG9zZWQgPyAwIDogNDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNsb3NlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh0cFswXSwgdHBbMV0sIHRwWzJdLCB0cFszXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPCBsZW4gLSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHRwW24rK10sIHRwW24rK10sIHRwW24rK10sIHRwW24rK10sIHRwW24rK10sIHRwW24rK10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghY2xvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHRwW2xlbiAtIDJdLCB0cFtsZW4gLSAxXSwgcG9pbnRzW2xlbmd0aCAtIDJdLCBwb2ludHNbbGVuZ3RoIC0gMV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG5vIHRlbnNpb25cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKG4gPSAyOyBuIDwgbGVuZ3RoOyBuICs9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwb2ludHNbbl0sIHBvaW50c1tuICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBjbG9zZWQgZS5nLiBwb2x5Z29ucyBhbmQgYmxvYnNcclxuICAgICAgICAgICAgaWYgKGNsb3NlZCkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG9wZW4gZS5nLiBsaW5lcyBhbmQgc3BsaW5lc1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU2hhcGUodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFRlbnNpb25Qb2ludHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKCd0ZW5zaW9uUG9pbnRzJywgdGhpcy5fZ2V0VGVuc2lvblBvaW50cyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0VGVuc2lvblBvaW50czogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRDbG9zZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRlbnNpb25Qb2ludHNDbG9zZWQoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBLb252YS5VdGlsLl9leHBhbmRQb2ludHModGhpcy5nZXRQb2ludHMoKSwgdGhpcy5nZXRUZW5zaW9uKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0VGVuc2lvblBvaW50c0Nsb3NlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMuZ2V0UG9pbnRzKCksXHJcbiAgICAgICAgICAgICAgICBsZW4gPSBwLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIHRlbnNpb24gPSB0aGlzLmdldFRlbnNpb24oKSxcclxuICAgICAgICAgICAgICAgIHV0aWwgPSBLb252YS5VdGlsLFxyXG4gICAgICAgICAgICAgICAgZmlyc3RDb250cm9sUG9pbnRzID0gdXRpbC5fZ2V0Q29udHJvbFBvaW50cyhcclxuICAgICAgICAgICAgICAgICAgICBwW2xlbiAtIDJdLFxyXG4gICAgICAgICAgICAgICAgICAgIHBbbGVuIC0gMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgcFswXSxcclxuICAgICAgICAgICAgICAgICAgICBwWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIHBbMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgcFszXSxcclxuICAgICAgICAgICAgICAgICAgICB0ZW5zaW9uXHJcbiAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgbGFzdENvbnRyb2xQb2ludHMgPSB1dGlsLl9nZXRDb250cm9sUG9pbnRzKFxyXG4gICAgICAgICAgICAgICAgICAgIHBbbGVuIC0gNF0sXHJcbiAgICAgICAgICAgICAgICAgICAgcFtsZW4gLSAzXSxcclxuICAgICAgICAgICAgICAgICAgICBwW2xlbiAtIDJdLFxyXG4gICAgICAgICAgICAgICAgICAgIHBbbGVuIC0gMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgcFswXSxcclxuICAgICAgICAgICAgICAgICAgICBwWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIHRlbnNpb25cclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICBtaWRkbGUgPSBLb252YS5VdGlsLl9leHBhbmRQb2ludHMocCwgdGVuc2lvbiksXHJcbiAgICAgICAgICAgICAgICB0cCA9IFtcclxuICAgICAgICAgICAgICAgICAgICBmaXJzdENvbnRyb2xQb2ludHNbMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RDb250cm9sUG9pbnRzWzNdXHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICAuY29uY2F0KG1pZGRsZSlcclxuICAgICAgICAgICAgICAgIC5jb25jYXQoW1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250cm9sUG9pbnRzWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250cm9sUG9pbnRzWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIHBbbGVuIC0gMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgcFtsZW4gLSAxXSxcclxuICAgICAgICAgICAgICAgICAgICBsYXN0Q29udHJvbFBvaW50c1syXSxcclxuICAgICAgICAgICAgICAgICAgICBsYXN0Q29udHJvbFBvaW50c1szXSxcclxuICAgICAgICAgICAgICAgICAgICBmaXJzdENvbnRyb2xQb2ludHNbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RDb250cm9sUG9pbnRzWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIHBbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgcFsxXVxyXG4gICAgICAgICAgICAgICAgXSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWxmUmVjdCgpLndpZHRoO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNlbGZSZWN0KCkuaGVpZ2h0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gb3ZlcmxvYWQgc2l6ZSBkZXRlY3Rpb25cclxuICAgICAgICBnZXRTZWxmUmVjdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRUZW5zaW9uKCkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHBvaW50cyA9IHRoaXMuX2dldFRlbnNpb25Qb2ludHMoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG1pblggPSBwb2ludHNbMF07XHJcbiAgICAgICAgICAgIHZhciBtYXhYID0gcG9pbnRzWzBdO1xyXG4gICAgICAgICAgICB2YXIgbWluWSA9IHBvaW50c1sxXTtcclxuICAgICAgICAgICAgdmFyIG1heFkgPSBwb2ludHNbMV07XHJcbiAgICAgICAgICAgIHZhciB4LCB5O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHggPSBwb2ludHNbaSAqIDJdO1xyXG4gICAgICAgICAgICAgICAgeSA9IHBvaW50c1tpICogMiArIDFdO1xyXG4gICAgICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHgpO1xyXG4gICAgICAgICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xyXG4gICAgICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xyXG4gICAgICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiBNYXRoLnJvdW5kKG1pblgpLFxyXG4gICAgICAgICAgICAgICAgeTogTWF0aC5yb3VuZChtaW5ZKSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKG1heFggLSBtaW5YKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogTWF0aC5yb3VuZChtYXhZIC0gbWluWSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuTGluZSwgS29udmEuU2hhcGUpO1xyXG5cclxuICAgIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkxpbmUsICdjbG9zZWQnLCBmYWxzZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IGNsb3NlZCBmbGFnLiAgVGhlIGRlZmF1bHQgaXMgZmFsc2VcclxuICAgICAqIEBuYW1lIGNsb3NlZFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkxpbmUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNsb3NlZFxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IGNsb3NlZCBmbGFnXHJcbiAgICAgKiB2YXIgY2xvc2VkID0gbGluZS5jbG9zZWQoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBjbG9zZSB0aGUgc2hhcGVcclxuICAgICAqIGxpbmUuY2xvc2VkKHRydWUpO1xyXG4gICAgICpcclxuICAgICAqIC8vIG9wZW4gdGhlIHNoYXBlXHJcbiAgICAgKiBsaW5lLmNsb3NlZChmYWxzZSk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5MaW5lLCAndGVuc2lvbicsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCB0ZW5zaW9uXHJcbiAgICAgKiBAbmFtZSB0ZW5zaW9uXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTGluZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBIaWdoZXIgdmFsdWVzIHdpbGwgcmVzdWx0IGluIGEgbW9yZSBjdXJ2eSBsaW5lLiAgQSB2YWx1ZSBvZiAwIHdpbGwgcmVzdWx0IGluIG5vIGludGVycG9sYXRpb24uXHJcbiAgICAgKiAgIFRoZSBkZWZhdWx0IGlzIDBcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IHRlbnNpb25cclxuICAgICAqIHZhciB0ZW5zaW9uID0gbGluZS50ZW5zaW9uKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IHRlbnNpb25cclxuICAgICAqIGxpbmUudGVuc2lvbigzKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkxpbmUsICdwb2ludHMnLCBbXSk7XHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgcG9pbnRzIGFycmF5XHJcbiAgICAgKiBAbmFtZSBwb2ludHNcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5MaW5lLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZ2V0IHBvaW50c1xyXG4gICAgICogdmFyIHBvaW50cyA9IGxpbmUucG9pbnRzKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IHBvaW50c1xyXG4gICAgICogbGluZS5wb2ludHMoWzEwLCAyMCwgMzAsIDQwLCA1MCwgNjBdKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBwdXNoIGEgbmV3IHBvaW50XHJcbiAgICAgKiBsaW5lLnBvaW50cyhsaW5lLnBvaW50cygpLmNvbmNhdChbNzAsIDgwXSkpO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLkxpbmUpO1xyXG59KSgpO1xyXG5cbihmdW5jdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8qKlxyXG4gICAgICogU3ByaXRlIGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxyXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmFuaW1hdGlvbiBhbmltYXRpb24ga2V5XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnLmFuaW1hdGlvbnMgYW5pbWF0aW9uIG1hcFxyXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBbY29uZmlnLmZyYW1lSW5kZXhdIGFuaW1hdGlvbiBmcmFtZSBpbmRleFxyXG4gICAgICogQHBhcmFtIHtJbWFnZX0gY29uZmlnLmltYWdlIGltYWdlIG9iamVjdFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHZhciBpbWFnZU9iaiA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICogaW1hZ2VPYmoub25sb2FkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgKiAgIHZhciBzcHJpdGUgPSBuZXcgS29udmEuU3ByaXRlKHtcclxuICAgICAqICAgICB4OiAyMDAsXHJcbiAgICAgKiAgICAgeTogMTAwLFxyXG4gICAgICogICAgIGltYWdlOiBpbWFnZU9iaixcclxuICAgICAqICAgICBhbmltYXRpb246ICdzdGFuZGluZycsXHJcbiAgICAgKiAgICAgYW5pbWF0aW9uczoge1xyXG4gICAgICogICAgICAgc3RhbmRpbmc6IFtcclxuICAgICAqICAgICAgICAgLy8geCwgeSwgd2lkdGgsIGhlaWdodCAoNiBmcmFtZXMpXHJcbiAgICAgKiAgICAgICAgIDAsIDAsIDQ5LCAxMDksXHJcbiAgICAgKiAgICAgICAgIDUyLCAwLCA0OSwgMTA5LFxyXG4gICAgICogICAgICAgICAxMDUsIDAsIDQ5LCAxMDksXHJcbiAgICAgKiAgICAgICAgIDE1OCwgMCwgNDksIDEwOSxcclxuICAgICAqICAgICAgICAgMjEwLCAwLCA0OSwgMTA5LFxyXG4gICAgICogICAgICAgICAyNjIsIDAsIDQ5LCAxMDlcclxuICAgICAqICAgICAgIF0sXHJcbiAgICAgKiAgICAgICBraWNraW5nOiBbXHJcbiAgICAgKiAgICAgICAgIC8vIHgsIHksIHdpZHRoLCBoZWlnaHQgKDYgZnJhbWVzKVxyXG4gICAgICogICAgICAgICAwLCAxMDksIDQ1LCA5OCxcclxuICAgICAqICAgICAgICAgNDUsIDEwOSwgNDUsIDk4LFxyXG4gICAgICogICAgICAgICA5NSwgMTA5LCA2MywgOTgsXHJcbiAgICAgKiAgICAgICAgIDE1NiwgMTA5LCA3MCwgOTgsXHJcbiAgICAgKiAgICAgICAgIDIyOSwgMTA5LCA2MCwgOTgsXHJcbiAgICAgKiAgICAgICAgIDI4NywgMTA5LCA0MSwgOThcclxuICAgICAqICAgICAgIF1cclxuICAgICAqICAgICB9LFxyXG4gICAgICogICAgIGZyYW1lUmF0ZTogNyxcclxuICAgICAqICAgICBmcmFtZUluZGV4OiAwXHJcbiAgICAgKiAgIH0pO1xyXG4gICAgICogfTtcclxuICAgICAqIGltYWdlT2JqLnNyYyA9ICcvcGF0aC90by9pbWFnZS5qcGcnXHJcbiAgICAgKi9cclxuICAgIEtvbnZhLlNwcml0ZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xyXG4gICAgfTtcclxuXHJcbiAgICBLb252YS5TcHJpdGUucHJvdG90eXBlID0ge1xyXG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAnU3ByaXRlJztcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbSA9IG5ldyBLb252YS5BbmltYXRpb24oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBkb24ndCBuZWVkIHRvIHJlZHJhdyBsYXllciB3ZSBzaG91bGQgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlZCA9IHRoYXQuX3VwZGF0ZWQ7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll91cGRhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlZDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMub24oJ2FuaW1hdGlvbkNoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgaW5kZXggd2hlbiBhbmltYXRpb24gY2hhbmdlc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZUluZGV4KDApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5vbignZnJhbWVJbmRleENoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBzbW9vdGggY2hhbmdlIGZvciBmcmFtZVJhdGVcclxuICAgICAgICAgICAgdGhpcy5vbignZnJhbWVSYXRlQ2hhbmdlLmtvbnZhJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYW5pbS5pc1J1bm5pbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRJbnRlcnZhbCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XHJcbiAgICAgICAgICAgIHRoaXMuaGl0RnVuYyh0aGlzLl9oaXRGdW5jKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIGFuaW0gPSB0aGlzLmdldEFuaW1hdGlvbigpLFxyXG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLmZyYW1lSW5kZXgoKSxcclxuICAgICAgICAgICAgICAgIGl4NCA9IGluZGV4ICogNCxcclxuICAgICAgICAgICAgICAgIHNldCA9IHRoaXMuZ2V0QW5pbWF0aW9ucygpW2FuaW1dLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0cyA9IHRoaXMuZnJhbWVPZmZzZXRzKCksXHJcbiAgICAgICAgICAgICAgICB4ID0gc2V0W2l4NCArIDBdLFxyXG4gICAgICAgICAgICAgICAgeSA9IHNldFtpeDQgKyAxXSxcclxuICAgICAgICAgICAgICAgIHdpZHRoID0gc2V0W2l4NCArIDJdLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gc2V0W2l4NCArIDNdLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2UgPSB0aGlzLmdldEltYWdlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNGaWxsKCkgfHwgdGhpcy5oYXNTdHJva2UoKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoaW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldHNbYW5pbV0sXHJcbiAgICAgICAgICAgICAgICAgICAgaXgyID0gaW5kZXggKiAyO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvZmZzZXRbaXgyICsgMF0sIG9mZnNldFtpeDIgKyAxXSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2hpdEZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIGFuaW0gPSB0aGlzLmdldEFuaW1hdGlvbigpLFxyXG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLmZyYW1lSW5kZXgoKSxcclxuICAgICAgICAgICAgICAgIGl4NCA9IGluZGV4ICogNCxcclxuICAgICAgICAgICAgICAgIHNldCA9IHRoaXMuZ2V0QW5pbWF0aW9ucygpW2FuaW1dLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0cyA9IHRoaXMuZnJhbWVPZmZzZXRzKCksXHJcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHNldFtpeDQgKyAyXSxcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHNldFtpeDQgKyAzXTtcclxuXHJcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGlmIChvZmZzZXRzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0c1thbmltXTtcclxuICAgICAgICAgICAgICAgIHZhciBpeDIgPSBpbmRleCAqIDI7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlY3Qob2Zmc2V0W2l4MiArIDBdLCBvZmZzZXRbaXgyICsgMV0sIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5yZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFNoYXBlKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3VzZUJ1ZmZlckNhbnZhczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5oYXNTaGFkb3coKSB8fCB0aGlzLmdldEFic29sdXRlT3BhY2l0eSgpICE9PSAxKSAmJiB0aGlzLmhhc1N0cm9rZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3NldEludGVydmFsOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll91cGRhdGVJbmRleCgpO1xyXG4gICAgICAgICAgICB9LCAxMDAwIC8gdGhpcy5nZXRGcmFtZVJhdGUoKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBzdGFydCBzcHJpdGUgYW5pbWF0aW9uXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TcHJpdGUucHJvdG90eXBlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiBhbmltYXRpb24gb2JqZWN0IGhhcyBubyBleGVjdXRhYmxlIGZ1bmN0aW9uIGJlY2F1c2VcclxuICAgICAgICAgICAgICogIHRoZSB1cGRhdGVzIGFyZSBkb25lIHdpdGggYSBmaXhlZCBGUFMgd2l0aCB0aGUgc2V0SW50ZXJ2YWxcclxuICAgICAgICAgICAgICogIGJlbG93LiAgVGhlIGFuaW0gb2JqZWN0IG9ubHkgbmVlZHMgdGhlIGxheWVyIHJlZmVyZW5jZSBmb3JcclxuICAgICAgICAgICAgICogIHJlZHJhd1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5hbmltLnNldExheWVycyhsYXllcik7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldEludGVydmFsKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbS5zdGFydCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogc3RvcCBzcHJpdGUgYW5pbWF0aW9uXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TcHJpdGUucHJvdG90eXBlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RvcDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbS5zdG9wKCk7XHJcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBkZXRlcm1pbmUgaWYgYW5pbWF0aW9uIG9mIHNwcml0ZSBpcyBydW5uaW5nIG9yIG5vdC4gIHJldHVybnMgdHJ1ZSBvciBmYWxzZVxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQW5pbWF0aW9uLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzUnVubmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW0uaXNSdW5uaW5nKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfdXBkYXRlSW5kZXg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmZyYW1lSW5kZXgoKSxcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbiA9IHRoaXMuZ2V0QW5pbWF0aW9uKCksXHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zID0gdGhpcy5nZXRBbmltYXRpb25zKCksXHJcbiAgICAgICAgICAgICAgICBhbmltID0gYW5pbWF0aW9uc1thbmltYXRpb25dLFxyXG4gICAgICAgICAgICAgICAgbGVuID0gYW5pbS5sZW5ndGggLyA0O1xyXG5cclxuICAgICAgICAgICAgaWYoaW5kZXggPCBsZW4gLSAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lSW5kZXgoaW5kZXggKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVJbmRleCgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5TcHJpdGUsIEtvbnZhLlNoYXBlKTtcclxuXHJcbiAgICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TcHJpdGUsICdhbmltYXRpb24nKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgYW5pbWF0aW9uIGtleVxyXG4gICAgICogQG5hbWUgYW5pbWF0aW9uXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3ByaXRlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFuaW0gYW5pbWF0aW9uIGtleVxyXG4gICAgICogQHJldHVybnMge1N0cmluZ31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgYW5pbWF0aW9uIGtleVxyXG4gICAgICogdmFyIGFuaW1hdGlvbiA9IHNwcml0ZS5hbmltYXRpb24oKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgYW5pbWF0aW9uIGtleVxyXG4gICAgICogc3ByaXRlLmFuaW1hdGlvbigna2lja2luZycpO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3ByaXRlLCAnYW5pbWF0aW9ucycpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBhbmltYXRpb25zIG1hcFxyXG4gICAgICogQG5hbWUgYW5pbWF0aW9uc1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNwcml0ZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhbmltYXRpb25zXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBhbmltYXRpb25zIG1hcFxyXG4gICAgICogdmFyIGFuaW1hdGlvbnMgPSBzcHJpdGUuYW5pbWF0aW9ucygpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBhbmltYXRpb25zIG1hcFxyXG4gICAgICogc3ByaXRlLmFuaW1hdGlvbnMoe1xyXG4gICAgICogICBzdGFuZGluZzogW1xyXG4gICAgICogICAgIC8vIHgsIHksIHdpZHRoLCBoZWlnaHQgKDYgZnJhbWVzKVxyXG4gICAgICogICAgIDAsIDAsIDQ5LCAxMDksXHJcbiAgICAgKiAgICAgNTIsIDAsIDQ5LCAxMDksXHJcbiAgICAgKiAgICAgMTA1LCAwLCA0OSwgMTA5LFxyXG4gICAgICogICAgIDE1OCwgMCwgNDksIDEwOSxcclxuICAgICAqICAgICAyMTAsIDAsIDQ5LCAxMDksXHJcbiAgICAgKiAgICAgMjYyLCAwLCA0OSwgMTA5XHJcbiAgICAgKiAgIF0sXHJcbiAgICAgKiAgIGtpY2tpbmc6IFtcclxuICAgICAqICAgICAvLyB4LCB5LCB3aWR0aCwgaGVpZ2h0ICg2IGZyYW1lcylcclxuICAgICAqICAgICAwLCAxMDksIDQ1LCA5OCxcclxuICAgICAqICAgICA0NSwgMTA5LCA0NSwgOTgsXHJcbiAgICAgKiAgICAgOTUsIDEwOSwgNjMsIDk4LFxyXG4gICAgICogICAgIDE1NiwgMTA5LCA3MCwgOTgsXHJcbiAgICAgKiAgICAgMjI5LCAxMDksIDYwLCA5OCxcclxuICAgICAqICAgICAyODcsIDEwOSwgNDEsIDk4XHJcbiAgICAgKiAgIF1cclxuICAgICAqIH0pO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3ByaXRlLCAnZnJhbWVPZmZzZXRzJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIGdldC9zZXQgb2Zmc2V0cyBtYXBcclxuICAgICogQG5hbWUgb2Zmc2V0c1xyXG4gICAgKiBAbWV0aG9kXHJcbiAgICAqIEBtZW1iZXJvZiBLb252YS5TcHJpdGUucHJvdG90eXBlXHJcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvZmZzZXRzXHJcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAqIEBleGFtcGxlXHJcbiAgICAqIC8vIGdldCBvZmZzZXRzIG1hcFxyXG4gICAgKiB2YXIgb2Zmc2V0cyA9IHNwcml0ZS5vZmZzZXRzKCk7XHJcbiAgICAqXHJcbiAgICAqIC8vIHNldCBvZmZzZXRzIG1hcFxyXG4gICAgKiBzcHJpdGUub2Zmc2V0cyh7XHJcbiAgICAqICAgc3RhbmRpbmc6IFtcclxuICAgICogICAgIC8vIHgsIHkgKDYgZnJhbWVzKVxyXG4gICAgKiAgICAgMCwgMCxcclxuICAgICogICAgIDAsIDAsXHJcbiAgICAqICAgICA1LCAwLFxyXG4gICAgKiAgICAgMCwgMCxcclxuICAgICogICAgIDAsIDMsXHJcbiAgICAqICAgICAyLCAwXHJcbiAgICAqICAgXSxcclxuICAgICogICBraWNraW5nOiBbXHJcbiAgICAqICAgICAvLyB4LCB5ICg2IGZyYW1lcylcclxuICAgICogICAgIDAsIDUsXHJcbiAgICAqICAgICA1LCAwLFxyXG4gICAgKiAgICAgMTAsIDAsXHJcbiAgICAqICAgICAwLCAwLFxyXG4gICAgKiAgICAgMiwgMSxcclxuICAgICogICAgIDAsIDBcclxuICAgICogICBdXHJcbiAgICAqIH0pO1xyXG4gICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TcHJpdGUsICdpbWFnZScpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBpbWFnZVxyXG4gICAgICogQG5hbWUgaW1hZ2VcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TcHJpdGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVxyXG4gICAgICogQHJldHVybnMge0ltYWdlfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBpbWFnZVxyXG4gICAgICogdmFyIGltYWdlID0gc3ByaXRlLmltYWdlKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IGltYWdlXHJcbiAgICAgKiBzcHJpdGUuaW1hZ2UoaW1hZ2VPYmopO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3ByaXRlLCAnZnJhbWVJbmRleCcsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2V0L3NldCBhbmltYXRpb24gZnJhbWUgaW5kZXhcclxuICAgICAqIEBuYW1lIGZyYW1lSW5kZXhcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TcHJpdGUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGZyYW1lSW5kZXhcclxuICAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBhbmltYXRpb24gZnJhbWUgaW5kZXhcclxuICAgICAqIHZhciBmcmFtZUluZGV4ID0gc3ByaXRlLmZyYW1lSW5kZXgoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgYW5pbWF0aW9uIGZyYW1lIGluZGV4XHJcbiAgICAgKiBzcHJpdGUuZnJhbWVJbmRleCgzKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNwcml0ZSwgJ2ZyYW1lUmF0ZScsIDE3KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldC9zZXQgZnJhbWUgcmF0ZSBpbiBmcmFtZXMgcGVyIHNlY29uZC4gIEluY3JlYXNlIHRoaXMgbnVtYmVyIHRvIG1ha2UgdGhlIHNwcml0ZVxyXG4gICAgICogIGFuaW1hdGlvbiBydW4gZmFzdGVyLCBhbmQgZGVjcmVhc2UgdGhlIG51bWJlciB0byBtYWtlIHRoZSBzcHJpdGUgYW5pbWF0aW9uIHJ1biBzbG93ZXJcclxuICAgICAqICBUaGUgZGVmYXVsdCBpcyAxNyBmcmFtZXMgcGVyIHNlY29uZFxyXG4gICAgICogQG5hbWUgZnJhbWVSYXRlXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3ByaXRlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBmcmFtZVJhdGVcclxuICAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGdldCBmcmFtZSByYXRlXHJcbiAgICAgKiB2YXIgZnJhbWVSYXRlID0gc3ByaXRlLmZyYW1lUmF0ZSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBmcmFtZSByYXRlIHRvIDIgZnJhbWVzIHBlciBzZWNvbmRcclxuICAgICAqIHNwcml0ZS5mcmFtZVJhdGUoMik7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmJhY2tDb21wYXQoS29udmEuU3ByaXRlLCB7XHJcbiAgICAgICAgaW5kZXg6ICdmcmFtZUluZGV4JyxcclxuICAgICAgICBnZXRJbmRleDogJ2dldEZyYW1lSW5kZXgnLFxyXG4gICAgICAgIHNldEluZGV4OiAnc2V0RnJhbWVJbmRleCdcclxuICAgIH0pO1xyXG5cclxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5TcHJpdGUpO1xyXG59KSgpO1xyXG5cbi8qZXNsaW50LWRpc2FibGUgIG5vLXNoYWRvdywgbWF4LWxlbiwgbWF4LWRlcHRoICovXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICAvKipcclxuICAgICAqIFBhdGggY29uc3RydWN0b3IuXHJcbiAgICAgKiBAYXV0aG9yIEphc29uIEZvbGxhc1xyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcclxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5kYXRhIFNWRyBkYXRhIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHZhciBwYXRoID0gbmV3IEtvbnZhLlBhdGgoe1xyXG4gICAgICogICB4OiAyNDAsXHJcbiAgICAgKiAgIHk6IDQwLFxyXG4gICAgICogICBkYXRhOiAnTTEyLjU4Miw5LjU1MUMzLjI1MSwxNi4yMzcsMC45MjEsMjkuMDIxLDcuMDgsMzguNTY0bC0yLjM2LDEuNjg5bDQuODkzLDIuMjYybDQuODkzLDIuMjYybC0wLjU2OC01LjM2bC0wLjU2Ny01LjM1OWwtMi4zNjUsMS42OTRjLTQuNjU3LTcuMzc1LTIuODMtMTcuMTg1LDQuMzUyLTIyLjMzYzcuNDUxLTUuMzM4LDE3LjgxNy0zLjYyNSwyMy4xNTYsMy44MjRjNS4zMzcsNy40NDksMy42MjUsMTcuODEzLTMuODIxLDIzLjE1MmwyLjg1NywzLjk4OGM5LjYxNy02Ljg5MywxMS44MjctMjAuMjc3LDQuOTM1LTI5Ljg5NkMzNS41OTEsNC44NywyMi4yMDQsMi42NTgsMTIuNTgyLDkuNTUxeicsXHJcbiAgICAgKiAgIGZpbGw6ICdncmVlbicsXHJcbiAgICAgKiAgIHNjYWxlOiAyXHJcbiAgICAgKiB9KTtcclxuICAgICAqL1xyXG4gICAgS29udmEuUGF0aCA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgICAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcclxuICAgIH07XHJcblxyXG4gICAgS29udmEuUGF0aC5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgX19faW5pdDogZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFBcnJheSA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAnUGF0aCc7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRhdGFBcnJheSA9IEtvbnZhLlBhdGgucGFyc2VQYXRoRGF0YSh0aGlzLmdldERhdGEoKSk7XHJcbiAgICAgICAgICAgIHRoaXMub24oJ2RhdGFDaGFuZ2Uua29udmEnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmRhdGFBcnJheSA9IEtvbnZhLlBhdGgucGFyc2VQYXRoRGF0YSh0aGlzLmdldERhdGEoKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIGNhID0gdGhpcy5kYXRhQXJyYXksXHJcbiAgICAgICAgICAgICAgICBjbG9zZWRQYXRoID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAvLyBjb250ZXh0IHBvc2l0aW9uXHJcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgY2EubGVuZ3RoOyBuKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjID0gY2Fbbl0uY29tbWFuZDtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gY2Fbbl0ucG9pbnRzO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHBbMF0sIHBbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdNJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocFswXSwgcFsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0MnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8ocFswXSwgcFsxXSwgcFsyXSwgcFszXSwgcFs0XSwgcFs1XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1EnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocFswXSwgcFsxXSwgcFsyXSwgcFszXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0EnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3ggPSBwWzBdLCBjeSA9IHBbMV0sIHJ4ID0gcFsyXSwgcnkgPSBwWzNdLCB0aGV0YSA9IHBbNF0sIGRUaGV0YSA9IHBbNV0sIHBzaSA9IHBbNl0sIGZzID0gcFs3XTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gKHJ4ID4gcnkpID8gcnggOiByeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlWCA9IChyeCA+IHJ5KSA/IDEgOiByeCAvIHJ5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVZID0gKHJ4ID4gcnkpID8gcnkgLyByeCA6IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShjeCwgY3kpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJvdGF0ZShwc2kpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgciwgdGhldGEsIHRoZXRhICsgZFRoZXRhLCAxIC0gZnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNjYWxlKDEgLyBzY2FsZVgsIDEgLyBzY2FsZVkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJvdGF0ZSgtcHNpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoLWN4LCAtY3kpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAneic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlZFBhdGggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNsb3NlZFBhdGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTaGFwZSh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0U2VsZlJlY3Q6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YUFycmF5LmZvckVhY2goZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzID0gcG9pbnRzLmNvbmNhdChkYXRhLnBvaW50cyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgbWluWCA9IHBvaW50c1swXTtcclxuICAgICAgICAgICAgdmFyIG1heFggPSBwb2ludHNbMF07XHJcbiAgICAgICAgICAgIHZhciBtaW5ZID0gcG9pbnRzWzBdO1xyXG4gICAgICAgICAgICB2YXIgbWF4WSA9IHBvaW50c1swXTtcclxuICAgICAgICAgICAgdmFyIHgsIHk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgeCA9IHBvaW50c1tpICogMl07IHkgPSBwb2ludHNbaSAqIDIgKyAxXTtcclxuICAgICAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcclxuICAgICAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4KTtcclxuICAgICAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcclxuICAgICAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgeDogTWF0aC5yb3VuZChtaW5YKSxcclxuICAgICAgICAgICAgICAgIHk6IE1hdGgucm91bmQobWluWSksXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogTWF0aC5yb3VuZChtYXhYIC0gbWluWCksXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQobWF4WSAtIG1pblkpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlBhdGgsIEtvbnZhLlNoYXBlKTtcclxuXHJcbiAgICBLb252YS5QYXRoLmdldExpbmVMZW5ndGggPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpKTtcclxuICAgIH07XHJcbiAgICBLb252YS5QYXRoLmdldFBvaW50T25MaW5lID0gZnVuY3Rpb24oZGlzdCwgUDF4LCBQMXksIFAyeCwgUDJ5LCBmcm9tWCwgZnJvbVkpIHtcclxuICAgICAgICBpZihmcm9tWCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGZyb21YID0gUDF4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihmcm9tWSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGZyb21ZID0gUDF5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG0gPSAoUDJ5IC0gUDF5KSAvICgoUDJ4IC0gUDF4KSArIDAuMDAwMDAwMDEpO1xyXG4gICAgICAgIHZhciBydW4gPSBNYXRoLnNxcnQoZGlzdCAqIGRpc3QgLyAoMSArIG0gKiBtKSk7XHJcbiAgICAgICAgaWYoUDJ4IDwgUDF4KSB7XHJcbiAgICAgICAgICAgIHJ1biAqPSAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJpc2UgPSBtICogcnVuO1xyXG4gICAgICAgIHZhciBwdDtcclxuXHJcbiAgICAgICAgaWYgKFAyeCA9PT0gUDF4KSB7IC8vIHZlcnRpY2FsIGxpbmVcclxuICAgICAgICAgICAgcHQgPSB7XHJcbiAgICAgICAgICAgICAgICB4OiBmcm9tWCxcclxuICAgICAgICAgICAgICAgIHk6IGZyb21ZICsgcmlzZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSBpZigoZnJvbVkgLSBQMXkpIC8gKChmcm9tWCAtIFAxeCkgKyAwLjAwMDAwMDAxKSA9PT0gbSkge1xyXG4gICAgICAgICAgICBwdCA9IHtcclxuICAgICAgICAgICAgICAgIHg6IGZyb21YICsgcnVuLFxyXG4gICAgICAgICAgICAgICAgeTogZnJvbVkgKyByaXNlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgaXgsIGl5O1xyXG5cclxuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMuZ2V0TGluZUxlbmd0aChQMXgsIFAxeSwgUDJ4LCBQMnkpO1xyXG4gICAgICAgICAgICBpZihsZW4gPCAwLjAwMDAwMDAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB1ID0gKCgoZnJvbVggLSBQMXgpICogKFAyeCAtIFAxeCkpICsgKChmcm9tWSAtIFAxeSkgKiAoUDJ5IC0gUDF5KSkpO1xyXG4gICAgICAgICAgICB1ID0gdSAvIChsZW4gKiBsZW4pO1xyXG4gICAgICAgICAgICBpeCA9IFAxeCArIHUgKiAoUDJ4IC0gUDF4KTtcclxuICAgICAgICAgICAgaXkgPSBQMXkgKyB1ICogKFAyeSAtIFAxeSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcFJpc2UgPSB0aGlzLmdldExpbmVMZW5ndGgoZnJvbVgsIGZyb21ZLCBpeCwgaXkpO1xyXG4gICAgICAgICAgICB2YXIgcFJ1biA9IE1hdGguc3FydChkaXN0ICogZGlzdCAtIHBSaXNlICogcFJpc2UpO1xyXG4gICAgICAgICAgICBydW4gPSBNYXRoLnNxcnQocFJ1biAqIHBSdW4gLyAoMSArIG0gKiBtKSk7XHJcbiAgICAgICAgICAgIGlmKFAyeCA8IFAxeCkge1xyXG4gICAgICAgICAgICAgICAgcnVuICo9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJpc2UgPSBtICogcnVuO1xyXG4gICAgICAgICAgICBwdCA9IHtcclxuICAgICAgICAgICAgICAgIHg6IGl4ICsgcnVuLFxyXG4gICAgICAgICAgICAgICAgeTogaXkgKyByaXNlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIEtvbnZhLlBhdGguZ2V0UG9pbnRPbkN1YmljQmV6aWVyID0gZnVuY3Rpb24ocGN0LCBQMXgsIFAxeSwgUDJ4LCBQMnksIFAzeCwgUDN5LCBQNHgsIFA0eSkge1xyXG4gICAgICAgIGZ1bmN0aW9uIENCMSh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0ICogdCAqIHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIENCMih0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAzICogdCAqIHQgKiAoMSAtIHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBDQjModCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMyAqIHQgKiAoMSAtIHQpICogKDEgLSB0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gQ0I0KHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICgxIC0gdCkgKiAoMSAtIHQpICogKDEgLSB0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHggPSBQNHggKiBDQjEocGN0KSArIFAzeCAqIENCMihwY3QpICsgUDJ4ICogQ0IzKHBjdCkgKyBQMXggKiBDQjQocGN0KTtcclxuICAgICAgICB2YXIgeSA9IFA0eSAqIENCMShwY3QpICsgUDN5ICogQ0IyKHBjdCkgKyBQMnkgKiBDQjMocGN0KSArIFAxeSAqIENCNChwY3QpO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICB5OiB5XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBLb252YS5QYXRoLmdldFBvaW50T25RdWFkcmF0aWNCZXppZXIgPSBmdW5jdGlvbihwY3QsIFAxeCwgUDF5LCBQMngsIFAyeSwgUDN4LCBQM3kpIHtcclxuICAgICAgICBmdW5jdGlvbiBRQjEodCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdCAqIHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIFFCMih0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAyICogdCAqICgxIC0gdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIFFCMyh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoMSAtIHQpICogKDEgLSB0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHggPSBQM3ggKiBRQjEocGN0KSArIFAyeCAqIFFCMihwY3QpICsgUDF4ICogUUIzKHBjdCk7XHJcbiAgICAgICAgdmFyIHkgPSBQM3kgKiBRQjEocGN0KSArIFAyeSAqIFFCMihwY3QpICsgUDF5ICogUUIzKHBjdCk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgIHk6IHlcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIEtvbnZhLlBhdGguZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMgPSBmdW5jdGlvbihjeCwgY3ksIHJ4LCByeSwgdGhldGEsIHBzaSkge1xyXG4gICAgICAgIHZhciBjb3NQc2kgPSBNYXRoLmNvcyhwc2kpLCBzaW5Qc2kgPSBNYXRoLnNpbihwc2kpO1xyXG4gICAgICAgIHZhciBwdCA9IHtcclxuICAgICAgICAgICAgeDogcnggKiBNYXRoLmNvcyh0aGV0YSksXHJcbiAgICAgICAgICAgIHk6IHJ5ICogTWF0aC5zaW4odGhldGEpXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiBjeCArIChwdC54ICogY29zUHNpIC0gcHQueSAqIHNpblBzaSksXHJcbiAgICAgICAgICAgIHk6IGN5ICsgKHB0LnggKiBzaW5Qc2kgKyBwdC55ICogY29zUHNpKVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgICAqIGdldCBwYXJzZWQgZGF0YSBhcnJheSBmcm9tIHRoZSBkYXRhXHJcbiAgICAgKiAgc3RyaW5nLiAgViwgdiwgSCwgaCwgYW5kIGwgZGF0YSBhcmUgY29udmVydGVkIHRvXHJcbiAgICAgKiAgTCBkYXRhIGZvciB0aGUgcHVycG9zZSBvZiBoaWdoIHBlcmZvcm1hbmNlIFBhdGhcclxuICAgICAqICByZW5kZXJpbmdcclxuICAgICAqL1xyXG4gICAgS29udmEuUGF0aC5wYXJzZVBhdGhEYXRhID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgIC8vIFBhdGggRGF0YSBTZWdtZW50IG11c3QgYmVnaW4gd2l0aCBhIG1vdmVUb1xyXG4gICAgICAgIC8vbSAoeCB5KSsgIFJlbGF0aXZlIG1vdmVUbyAoc3Vic2VxdWVudCBwb2ludHMgYXJlIHRyZWF0ZWQgYXMgbGluZVRvKVxyXG4gICAgICAgIC8vTSAoeCB5KSsgIEFic29sdXRlIG1vdmVUbyAoc3Vic2VxdWVudCBwb2ludHMgYXJlIHRyZWF0ZWQgYXMgbGluZVRvKVxyXG4gICAgICAgIC8vbCAoeCB5KSsgIFJlbGF0aXZlIGxpbmVUb1xyXG4gICAgICAgIC8vTCAoeCB5KSsgIEFic29sdXRlIExpbmVUb1xyXG4gICAgICAgIC8vaCAoeCkrICAgIFJlbGF0aXZlIGhvcml6b250YWwgbGluZVRvXHJcbiAgICAgICAgLy9IICh4KSsgICAgQWJzb2x1dGUgaG9yaXpvbnRhbCBsaW5lVG9cclxuICAgICAgICAvL3YgKHkpKyAgICBSZWxhdGl2ZSB2ZXJ0aWNhbCBsaW5lVG9cclxuICAgICAgICAvL1YgKHkpKyAgICBBYnNvbHV0ZSB2ZXJ0aWNhbCBsaW5lVG9cclxuICAgICAgICAvL3ogKGNsb3NlcGF0aClcclxuICAgICAgICAvL1ogKGNsb3NlcGF0aClcclxuICAgICAgICAvL2MgKHgxIHkxIHgyIHkyIHggeSkrIFJlbGF0aXZlIEJlemllciBjdXJ2ZVxyXG4gICAgICAgIC8vQyAoeDEgeTEgeDIgeTIgeCB5KSsgQWJzb2x1dGUgQmV6aWVyIGN1cnZlXHJcbiAgICAgICAgLy9xICh4MSB5MSB4IHkpKyAgICAgICBSZWxhdGl2ZSBRdWFkcmF0aWMgQmV6aWVyXHJcbiAgICAgICAgLy9RICh4MSB5MSB4IHkpKyAgICAgICBBYnNvbHV0ZSBRdWFkcmF0aWMgQmV6aWVyXHJcbiAgICAgICAgLy90ICh4IHkpKyAgICBTaG9ydGhhbmQvU21vb3RoIFJlbGF0aXZlIFF1YWRyYXRpYyBCZXppZXJcclxuICAgICAgICAvL1QgKHggeSkrICAgIFNob3J0aGFuZC9TbW9vdGggQWJzb2x1dGUgUXVhZHJhdGljIEJlemllclxyXG4gICAgICAgIC8vcyAoeDIgeTIgeCB5KSsgICAgICAgU2hvcnRoYW5kL1Ntb290aCBSZWxhdGl2ZSBCZXppZXIgY3VydmVcclxuICAgICAgICAvL1MgKHgyIHkyIHggeSkrICAgICAgIFNob3J0aGFuZC9TbW9vdGggQWJzb2x1dGUgQmV6aWVyIGN1cnZlXHJcbiAgICAgICAgLy9hIChyeCByeSB4LWF4aXMtcm90YXRpb24gbGFyZ2UtYXJjLWZsYWcgc3dlZXAtZmxhZyB4IHkpKyAgICAgUmVsYXRpdmUgRWxsaXB0aWNhbCBBcmNcclxuICAgICAgICAvL0EgKHJ4IHJ5IHgtYXhpcy1yb3RhdGlvbiBsYXJnZS1hcmMtZmxhZyBzd2VlcC1mbGFnIHggeSkrICBBYnNvbHV0ZSBFbGxpcHRpY2FsIEFyY1xyXG5cclxuICAgICAgICAvLyByZXR1cm4gZWFybHkgaWYgZGF0YSBpcyBub3QgZGVmaW5lZFxyXG4gICAgICAgIGlmKCFkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbW1hbmQgc3RyaW5nXHJcbiAgICAgICAgdmFyIGNzID0gZGF0YTtcclxuXHJcbiAgICAgICAgLy8gY29tbWFuZCBjaGFyc1xyXG4gICAgICAgIHZhciBjYyA9IFsnbScsICdNJywgJ2wnLCAnTCcsICd2JywgJ1YnLCAnaCcsICdIJywgJ3onLCAnWicsICdjJywgJ0MnLCAncScsICdRJywgJ3QnLCAnVCcsICdzJywgJ1MnLCAnYScsICdBJ107XHJcbiAgICAgICAgLy8gY29udmVydCB3aGl0ZSBzcGFjZXMgdG8gY29tbWFzXHJcbiAgICAgICAgY3MgPSBjcy5yZXBsYWNlKG5ldyBSZWdFeHAoJyAnLCAnZycpLCAnLCcpO1xyXG4gICAgICAgIC8vIGNyZWF0ZSBwaXBlcyBzbyB0aGF0IHdlIGNhbiBzcGxpdCB0aGUgZGF0YVxyXG4gICAgICAgIGZvcih2YXIgbiA9IDA7IG4gPCBjYy5sZW5ndGg7IG4rKykge1xyXG4gICAgICAgICAgICBjcyA9IGNzLnJlcGxhY2UobmV3IFJlZ0V4cChjY1tuXSwgJ2cnKSwgJ3wnICsgY2Nbbl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjcmVhdGUgYXJyYXlcclxuICAgICAgICB2YXIgYXJyID0gY3Muc3BsaXQoJ3wnKTtcclxuICAgICAgICB2YXIgY2EgPSBbXTtcclxuICAgICAgICAvLyBpbml0IGNvbnRleHQgcG9pbnRcclxuICAgICAgICB2YXIgY3B4ID0gMDtcclxuICAgICAgICB2YXIgY3B5ID0gMDtcclxuICAgICAgICBmb3IoIG4gPSAxOyBuIDwgYXJyLmxlbmd0aDsgbisrKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHIgPSBhcnJbbl07XHJcbiAgICAgICAgICAgIHZhciBjID0gc3RyLmNoYXJBdCgwKTtcclxuICAgICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgLC0gZm9yIGNvbnNpc3RlbmN5XHJcbiAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoJywtJywgJ2cnKSwgJy0nKTtcclxuICAgICAgICAgICAgLy8gYWRkIGNvbW1hcyBzbyB0aGF0IGl0J3MgZWFzeSB0byBzcGxpdFxyXG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShuZXcgUmVnRXhwKCctJywgJ2cnKSwgJywtJyk7XHJcbiAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoJ2UsLScsICdnJyksICdlLScpO1xyXG4gICAgICAgICAgICB2YXIgcCA9IHN0ci5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICBpZihwLmxlbmd0aCA+IDAgJiYgcFswXSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjb252ZXJ0IHN0cmluZ3MgdG8gZmxvYXRzXHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBwW2ldID0gcGFyc2VGbG9hdChwW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZShwLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGlmKGlzTmFOKHBbMF0pKSB7Ly8gY2FzZSBmb3IgYSB0cmFpbGluZyBjb21tYSBiZWZvcmUgbmV4dCBjb21tYW5kXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGNtZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gW107XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRYID0gY3B4LCBzdGFydFkgPSBjcHk7XHJcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHZhciBmcm9tIHdpdGhpbiB0aGUgc3dpdGNoIHRvIHVwIGhlcmUgKGpzaGludClcclxuICAgICAgICAgICAgICAgIHZhciBwcmV2Q21kLCBjdGxQdHgsIGN0bFB0eTsgICAgIC8vIFNzLCBUdFxyXG4gICAgICAgICAgICAgICAgdmFyIHJ4LCByeSwgcHNpLCBmYSwgZnMsIHgxLCB5MTsgLy8gQWFcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY29udmVydCBsLCBILCBoLCBWLCBhbmQgdiB0byBMXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogS2VlcCB0aGUgbGluZVRvJ3MgYWJvdmUgdGhlIG1vdmVUbydzIGluIHRoaXMgc3dpdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdMJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdMJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IGxpbmVUbyBoYW5kbGVycyBuZWVkIHRvIGJlIGFib3ZlIHRoaXMgcG9pbnRcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHkgPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBkeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IGR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnTSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFmdGVyIGNsb3NpbmcgdGhlIHBhdGggbW92ZSB0aGUgY3VycmVudCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byB0aGUgdGhlIGZpcnN0IHBvaW50IG9mIHRoZSBwYXRoIChpZiBhbnkpLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjYS5sZW5ndGggPiAyICYmIGNhW2NhLmxlbmd0aCAtIDFdLmNvbW1hbmQgPT09ICd6Jyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGlkeCA9IGNhLmxlbmd0aCAtIDI7IGlkeCA+PSAwOyBpZHgtLSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2FbaWR4XS5jb21tYW5kID09PSAnTScpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBjYVtpZHhdLnBvaW50c1swXSArIGR4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBjYVtpZHhdLnBvaW50c1sxXSArIGR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gJ2wnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdWJzZXF1ZW50IHBvaW50cyBhcmUgdHJlYXRlZCBhcyByZWxhdGl2ZSBsaW5lVG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnTSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICdMJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Vic2VxdWVudCBwb2ludHMgYXJlIHRyZWF0ZWQgYXMgYWJzb2x1dGUgbGluZVRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdoJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ0wnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0gnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdMJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd2JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ0wnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1YnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdMJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdDJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocC5zaGlmdCgpLCBwLnNoaWZ0KCksIHAuc2hpZnQoKSwgcC5zaGlmdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCArIHAuc2hpZnQoKSwgY3B5ICsgcC5zaGlmdCgpLCBjcHggKyBwLnNoaWZ0KCksIGNweSArIHAuc2hpZnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdDJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdTJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZDbWQgPSBjYVtjYS5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYocHJldkNtZC5jb21tYW5kID09PSAnQycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweCArIChjcHggLSBwcmV2Q21kLnBvaW50c1syXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHkgKyAoY3B5IC0gcHJldkNtZC5wb2ludHNbM10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGN0bFB0eCwgY3RsUHR5LCBwLnNoaWZ0KCksIHAuc2hpZnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnQyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Q21kID0gY2FbY2EubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHByZXZDbWQuY29tbWFuZCA9PT0gJ0MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHggKyAoY3B4IC0gcHJldkNtZC5wb2ludHNbMl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5ICsgKGNweSAtIHByZXZDbWQucG9pbnRzWzNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjdGxQdHgsIGN0bFB0eSwgY3B4ICsgcC5zaGlmdCgpLCBjcHkgKyBwLnNoaWZ0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnQyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHAuc2hpZnQoKSwgcC5zaGlmdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCArIHAuc2hpZnQoKSwgY3B5ICsgcC5zaGlmdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ1EnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1QnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkNtZCA9IGNhW2NhLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwcmV2Q21kLmNvbW1hbmQgPT09ICdRJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4ICsgKGNweCAtIHByZXZDbWQucG9pbnRzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweSArIChjcHkgLSBwcmV2Q21kLnBvaW50c1sxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdRJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3RsUHR4LCBjdGxQdHksIGNweCwgY3B5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Q21kID0gY2FbY2EubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHByZXZDbWQuY29tbWFuZCA9PT0gJ1EnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHggKyAoY3B4IC0gcHJldkNtZC5wb2ludHNbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5ICsgKGNweSAtIHByZXZDbWQucG9pbnRzWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnUSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGN0bFB0eCwgY3RsUHR5LCBjcHgsIGNweSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0EnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByeCA9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnkgPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBzaSA9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmEgPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzID0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IGNweDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSBjcHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnQSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IHRoaXMuY29udmVydEVuZHBvaW50VG9DZW50ZXJQYXJhbWV0ZXJpemF0aW9uKHgxLCB5MSwgY3B4LCBjcHksIGZhLCBmcywgcngsIHJ5LCBwc2kpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnggPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ5ID0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwc2kgPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhID0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcyA9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBjcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxID0gY3B5OyBjcHggKz0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnQSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IHRoaXMuY29udmVydEVuZHBvaW50VG9DZW50ZXJQYXJhbWV0ZXJpemF0aW9uKHgxLCB5MSwgY3B4LCBjcHksIGZhLCBmcywgcngsIHJ5LCBwc2kpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjYS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBjbWQgfHwgYyxcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcclxuICAgICAgICAgICAgICAgICAgICBzdGFydDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBzdGFydFgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHN0YXJ0WVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aExlbmd0aDogdGhpcy5jYWxjTGVuZ3RoKHN0YXJ0WCwgc3RhcnRZLCBjbWQgfHwgYywgcG9pbnRzKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGMgPT09ICd6JyB8fCBjID09PSAnWicpIHtcclxuICAgICAgICAgICAgICAgIGNhLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICd6JyxcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aExlbmd0aDogMFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjYTtcclxuICAgIH07XHJcbiAgICBLb252YS5QYXRoLmNhbGNMZW5ndGggPSBmdW5jdGlvbih4LCB5LCBjbWQsIHBvaW50cykge1xyXG4gICAgICAgIHZhciBsZW4sIHAxLCBwMiwgdDtcclxuICAgICAgICB2YXIgcGF0aCA9IEtvbnZhLlBhdGg7XHJcblxyXG4gICAgICAgIHN3aXRjaCAoY21kKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ0wnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGguZ2V0TGluZUxlbmd0aCh4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSk7XHJcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxyXG4gICAgICAgICAgICAgICAgLy8gQXBwcm94aW1hdGVzIGJ5IGJyZWFraW5nIGN1cnZlIGludG8gMTAwIGxpbmUgc2VnbWVudHNcclxuICAgICAgICAgICAgICAgIGxlbiA9IDAuMDtcclxuICAgICAgICAgICAgICAgIHAxID0gcGF0aC5nZXRQb2ludE9uQ3ViaWNCZXppZXIoMCwgeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBwb2ludHNbNF0sIHBvaW50c1s1XSk7XHJcbiAgICAgICAgICAgICAgICBmb3IoIHQgPSAwLjAxOyB0IDw9IDE7IHQgKz0gMC4wMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHAyID0gcGF0aC5nZXRQb2ludE9uQ3ViaWNCZXppZXIodCwgeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBwb2ludHNbNF0sIHBvaW50c1s1XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVuICs9IHBhdGguZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcclxuICAgICAgICAgICAgICAgICAgICBwMSA9IHAyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbjtcclxuICAgICAgICAgICAgY2FzZSAnUSc6XHJcbiAgICAgICAgICAgICAgICAvLyBBcHByb3hpbWF0ZXMgYnkgYnJlYWtpbmcgY3VydmUgaW50byAxMDAgbGluZSBzZWdtZW50c1xyXG4gICAgICAgICAgICAgICAgbGVuID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgcDEgPSBwYXRoLmdldFBvaW50T25RdWFkcmF0aWNCZXppZXIoMCwgeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdKTtcclxuICAgICAgICAgICAgICAgIGZvciggdCA9IDAuMDE7IHQgPD0gMTsgdCArPSAwLjAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcDIgPSBwYXRoLmdldFBvaW50T25RdWFkcmF0aWNCZXppZXIodCwgeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdKTtcclxuICAgICAgICAgICAgICAgICAgICBsZW4gKz0gcGF0aC5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHAxID0gcDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuO1xyXG4gICAgICAgICAgICBjYXNlICdBJzpcclxuICAgICAgICAgICAgICAgIC8vIEFwcHJveGltYXRlcyBieSBicmVha2luZyBjdXJ2ZSBpbnRvIGxpbmUgc2VnbWVudHNcclxuICAgICAgICAgICAgICAgIGxlbiA9IDAuMDtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHBvaW50c1s0XTtcclxuICAgICAgICAgICAgICAgIC8vIDQgPSB0aGV0YVxyXG4gICAgICAgICAgICAgICAgdmFyIGRUaGV0YSA9IHBvaW50c1s1XTtcclxuICAgICAgICAgICAgICAgIC8vIDUgPSBkVGhldGFcclxuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBwb2ludHNbNF0gKyBkVGhldGE7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5jID0gTWF0aC5QSSAvIDE4MC4wO1xyXG4gICAgICAgICAgICAgICAgLy8gMSBkZWdyZWUgcmVzb2x1dGlvblxyXG4gICAgICAgICAgICAgICAgaWYoTWF0aC5hYnMoc3RhcnQgLSBlbmQpIDwgaW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5jID0gTWF0aC5hYnMoc3RhcnQgLSBlbmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogZm9yIHB1cnBvc2Ugb2YgY2FsY3VsYXRpbmcgYXJjIGxlbmd0aCwgbm90IGdvaW5nIHRvIHdvcnJ5IGFib3V0IHJvdGF0aW5nIFgtYXhpcyBieSBhbmdsZSBwc2lcclxuICAgICAgICAgICAgICAgIHAxID0gcGF0aC5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHN0YXJ0LCAwKTtcclxuICAgICAgICAgICAgICAgIGlmKGRUaGV0YSA8IDApIHsvLyBjbG9ja3dpc2VcclxuICAgICAgICAgICAgICAgICAgICBmb3IoIHQgPSBzdGFydCAtIGluYzsgdCA+IGVuZDsgdCAtPSBpbmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcDIgPSBwYXRoLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgdCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbiArPSBwYXRoLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAxID0gcDI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7Ly8gY291bnRlci1jbG9ja3dpc2VcclxuICAgICAgICAgICAgICAgICAgICBmb3IoIHQgPSBzdGFydCArIGluYzsgdCA8IGVuZDsgdCArPSBpbmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcDIgPSBwYXRoLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgdCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbiArPSBwYXRoLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAxID0gcDI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcDIgPSBwYXRoLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgZW5kLCAwKTtcclxuICAgICAgICAgICAgICAgIGxlbiArPSBwYXRoLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfTtcclxuICAgIEtvbnZhLlBhdGguY29udmVydEVuZHBvaW50VG9DZW50ZXJQYXJhbWV0ZXJpemF0aW9uID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIGZhLCBmcywgcngsIHJ5LCBwc2lEZWcpIHtcclxuICAgICAgICAvLyBEZXJpdmVkIGZyb206IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9pbXBsbm90ZS5odG1sI0FyY0ltcGxlbWVudGF0aW9uTm90ZXNcclxuICAgICAgICB2YXIgcHNpID0gcHNpRGVnICogKE1hdGguUEkgLyAxODAuMCk7XHJcbiAgICAgICAgdmFyIHhwID0gTWF0aC5jb3MocHNpKSAqICh4MSAtIHgyKSAvIDIuMCArIE1hdGguc2luKHBzaSkgKiAoeTEgLSB5MikgLyAyLjA7XHJcbiAgICAgICAgdmFyIHlwID0gLTEgKiBNYXRoLnNpbihwc2kpICogKHgxIC0geDIpIC8gMi4wICsgTWF0aC5jb3MocHNpKSAqICh5MSAtIHkyKSAvIDIuMDtcclxuXHJcbiAgICAgICAgdmFyIGxhbWJkYSA9ICh4cCAqIHhwKSAvIChyeCAqIHJ4KSArICh5cCAqIHlwKSAvIChyeSAqIHJ5KTtcclxuXHJcbiAgICAgICAgaWYobGFtYmRhID4gMSkge1xyXG4gICAgICAgICAgICByeCAqPSBNYXRoLnNxcnQobGFtYmRhKTtcclxuICAgICAgICAgICAgcnkgKj0gTWF0aC5zcXJ0KGxhbWJkYSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZiA9IE1hdGguc3FydCgoKChyeCAqIHJ4KSAqIChyeSAqIHJ5KSkgLSAoKHJ4ICogcngpICogKHlwICogeXApKSAtICgocnkgKiByeSkgKiAoeHAgKiB4cCkpKSAvICgocnggKiByeCkgKiAoeXAgKiB5cCkgKyAocnkgKiByeSkgKiAoeHAgKiB4cCkpKTtcclxuXHJcbiAgICAgICAgaWYoZmEgPT09IGZzKSB7XHJcbiAgICAgICAgICAgIGYgKj0gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGlzTmFOKGYpKSB7XHJcbiAgICAgICAgICAgIGYgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGN4cCA9IGYgKiByeCAqIHlwIC8gcnk7XHJcbiAgICAgICAgdmFyIGN5cCA9IGYgKiAtcnkgKiB4cCAvIHJ4O1xyXG5cclxuICAgICAgICB2YXIgY3ggPSAoeDEgKyB4MikgLyAyLjAgKyBNYXRoLmNvcyhwc2kpICogY3hwIC0gTWF0aC5zaW4ocHNpKSAqIGN5cDtcclxuICAgICAgICB2YXIgY3kgPSAoeTEgKyB5MikgLyAyLjAgKyBNYXRoLnNpbihwc2kpICogY3hwICsgTWF0aC5jb3MocHNpKSAqIGN5cDtcclxuXHJcbiAgICAgICAgdmFyIHZNYWcgPSBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQodlswXSAqIHZbMF0gKyB2WzFdICogdlsxXSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgdlJhdGlvID0gZnVuY3Rpb24odSwgdikge1xyXG4gICAgICAgICAgICByZXR1cm4gKHVbMF0gKiB2WzBdICsgdVsxXSAqIHZbMV0pIC8gKHZNYWcodSkgKiB2TWFnKHYpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciB2QW5nbGUgPSBmdW5jdGlvbih1LCB2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodVswXSAqIHZbMV0gPCB1WzFdICogdlswXSA/IC0xIDogMSkgKiBNYXRoLmFjb3ModlJhdGlvKHUsIHYpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciB0aGV0YSA9IHZBbmdsZShbMSwgMF0sIFsoeHAgLSBjeHApIC8gcngsICh5cCAtIGN5cCkgLyByeV0pO1xyXG4gICAgICAgIHZhciB1ID0gWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XTtcclxuICAgICAgICB2YXIgdiA9IFsoLTEgKiB4cCAtIGN4cCkgLyByeCwgKC0xICogeXAgLSBjeXApIC8gcnldO1xyXG4gICAgICAgIHZhciBkVGhldGEgPSB2QW5nbGUodSwgdik7XHJcblxyXG4gICAgICAgIGlmKHZSYXRpbyh1LCB2KSA8PSAtMSkge1xyXG4gICAgICAgICAgICBkVGhldGEgPSBNYXRoLlBJO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih2UmF0aW8odSwgdikgPj0gMSkge1xyXG4gICAgICAgICAgICBkVGhldGEgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihmcyA9PT0gMCAmJiBkVGhldGEgPiAwKSB7XHJcbiAgICAgICAgICAgIGRUaGV0YSA9IGRUaGV0YSAtIDIgKiBNYXRoLlBJO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihmcyA9PT0gMSAmJiBkVGhldGEgPCAwKSB7XHJcbiAgICAgICAgICAgIGRUaGV0YSA9IGRUaGV0YSArIDIgKiBNYXRoLlBJO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW2N4LCBjeSwgcngsIHJ5LCB0aGV0YSwgZFRoZXRhLCBwc2ksIGZzXTtcclxuICAgIH07XHJcbiAgICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5QYXRoLCAnZGF0YScpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2V0IFNWRyBwYXRoIGRhdGEgc3RyaW5nLiAgVGhpcyBtZXRob2RcclxuICAgICAqICBhbHNvIGF1dG9tYXRpY2FsbHkgcGFyc2VzIHRoZSBkYXRhIHN0cmluZ1xyXG4gICAgICogIGludG8gYSBkYXRhIGFycmF5LiAgQ3VycmVudGx5IHN1cHBvcnRlZCBTVkcgZGF0YTpcclxuICAgICAqICBNLCBtLCBMLCBsLCBILCBoLCBWLCB2LCBRLCBxLCBULCB0LCBDLCBjLCBTLCBzLCBBLCBhLCBaLCB6XHJcbiAgICAgKiBAbmFtZSBzZXREYXRhXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuUGF0aC5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBTVkcgcGF0aCBjb21tYW5kIHN0cmluZ1xyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQgU1ZHIHBhdGggZGF0YSBzdHJpbmdcclxuICAgICAqIEBuYW1lIGdldERhdGFcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5QYXRoLnByb3RvdHlwZVxyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLlBhdGgpO1xyXG59KSgpO1xyXG5cbihmdW5jdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHZhciBFTVBUWV9TVFJJTkcgPSAnJyxcclxuICAgICAgICAvL0NBTElCUkkgPSAnQ2FsaWJyaScsXHJcbiAgICAgICAgTk9STUFMID0gJ25vcm1hbCc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXRoIGNvbnN0cnVjdG9yLlxyXG4gICAgICogQGF1dGhvciBKYXNvbiBGb2xsYXNcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXHJcbiAgICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZvbnRGYW1pbHldIGRlZmF1bHQgaXMgQ2FsaWJyaVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZm9udFNpemVdIGRlZmF1bHQgaXMgMTJcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZvbnRTdHlsZV0gY2FuIGJlIG5vcm1hbCwgYm9sZCwgb3IgaXRhbGljLiAgRGVmYXVsdCBpcyBub3JtYWxcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZvbnRWYXJpYW50XSBjYW4gYmUgbm9ybWFsIG9yIHNtYWxsLWNhcHMuICBEZWZhdWx0IGlzIG5vcm1hbFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy50ZXh0XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmRhdGEgU1ZHIGRhdGEgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogdmFyIHRleHRwYXRoID0gbmV3IEtvbnZhLlRleHRQYXRoKHtcclxuICAgICAqICAgeDogMTAwLFxyXG4gICAgICogICB5OiA1MCxcclxuICAgICAqICAgZmlsbDogJyMzMzMnLFxyXG4gICAgICogICBmb250U2l6ZTogJzI0JyxcclxuICAgICAqICAgZm9udEZhbWlseTogJ0FyaWFsJyxcclxuICAgICAqICAgdGV4dDogJ0FsbCB0aGUgd29ybGRcXCdzIGEgc3RhZ2UsIGFuZCBhbGwgdGhlIG1lbiBhbmQgd29tZW4gbWVyZWx5IHBsYXllcnMuJyxcclxuICAgICAqICAgZGF0YTogJ00xMCwxMCBDMCwwIDEwLDE1MCAxMDAsMTAwIFMzMDAsMTUwIDQwMCw1MCdcclxuICAgICAqIH0pO1xyXG4gICAgICovXHJcbiAgICBLb252YS5UZXh0UGF0aCA9IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBfZmlsbEZ1bmMoY29udGV4dCkge1xyXG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQodGhpcy5wYXJ0aWFsVGV4dCwgMCwgMCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBfc3Ryb2tlRnVuYyhjb250ZXh0KSB7XHJcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KHRoaXMucGFydGlhbFRleHQsIDAsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLmR1bW15Q2FudmFzID0gS29udmEuVXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YUFycmF5ID0gW107XHJcblxyXG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlc1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBzaG91bGRuJ3QgdGhpcyBiZSBvbiB0aGUgcHJvdG90eXBlP1xyXG4gICAgICAgICAgICB0aGlzLl9maWxsRnVuYyA9IF9maWxsRnVuYztcclxuICAgICAgICAgICAgdGhpcy5fc3Ryb2tlRnVuYyA9IF9zdHJva2VGdW5jO1xyXG4gICAgICAgICAgICB0aGlzLl9maWxsRnVuY0hpdCA9IF9maWxsRnVuYztcclxuICAgICAgICAgICAgdGhpcy5fc3Ryb2tlRnVuY0hpdCA9IF9zdHJva2VGdW5jO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAnVGV4dFBhdGgnO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kYXRhQXJyYXkgPSBLb252YS5QYXRoLnBhcnNlUGF0aERhdGEodGhpcy5hdHRycy5kYXRhKTtcclxuICAgICAgICAgICAgdGhpcy5vbignZGF0YUNoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5kYXRhQXJyYXkgPSBLb252YS5QYXRoLnBhcnNlUGF0aERhdGEodGhpcy5hdHRycy5kYXRhKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGV4dCBkYXRhIGZvciBjZXJ0YWluIGF0dHIgY2hhbmdlc1xyXG4gICAgICAgICAgICB0aGlzLm9uKCd0ZXh0Q2hhbmdlLmtvbnZhIHRleHRTdHJva2Uua29udmEgdGV4dFN0cm9rZVdpZHRoLmtvbnZhJywgdGhhdC5fc2V0VGV4dERhdGEpO1xyXG4gICAgICAgICAgICB0aGF0Ll9zZXRUZXh0RGF0YSgpO1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LnNldEF0dHIoJ2ZvbnQnLCB0aGlzLl9nZXRDb250ZXh0Rm9udCgpKTtcclxuICAgICAgICAgICAgY29udGV4dC5zZXRBdHRyKCd0ZXh0QmFzZWxpbmUnLCAnbWlkZGxlJyk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc2V0QXR0cigndGV4dEFsaWduJywgJ2xlZnQnKTtcclxuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZ2x5cGhJbmZvID0gdGhpcy5nbHlwaEluZm87XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBnbHlwaEluZm8ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwMCA9IGdseXBoSW5mb1tpXS5wMDtcclxuXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShwMC54LCBwMC55KTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQucm90YXRlKGdseXBoSW5mb1tpXS5yb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpYWxUZXh0ID0gZ2x5cGhJbmZvW2ldLnRleHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLy8vIFRvIGFzc2lzdCB3aXRoIGRlYnVnZ2luZyB2aXN1YWxseSwgdW5jb21tZW50IGZvbGxvd2luZ1xyXG4gICAgICAgICAgICAgICAgLy8gY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIC8vIGlmIChpICUgMilcclxuICAgICAgICAgICAgICAgIC8vIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnY3lhbic7XHJcbiAgICAgICAgICAgICAgICAvLyBlbHNlXHJcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ2dyZWVuJztcclxuICAgICAgICAgICAgICAgIC8vIHZhciBwMSA9IGdseXBoSW5mb1tpXS5wMTtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnRleHQubW92ZVRvKHAwLngsIHAwLnkpO1xyXG4gICAgICAgICAgICAgICAgLy8gY29udGV4dC5saW5lVG8ocDEueCwgcDEueSk7XHJcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogZ2V0IHRleHQgd2lkdGggaW4gcGl4ZWxzXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRUZXh0V2lkdGg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0V2lkdGg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBnZXQgdGV4dCBoZWlnaHQgaW4gcGl4ZWxzXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRUZXh0SGVpZ2h0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dEhlaWdodDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHNldCB0ZXh0XHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldFRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcclxuICAgICAgICAgICAgS29udmEuVGV4dC5wcm90b3R5cGUuc2V0VGV4dC5jYWxsKHRoaXMsIHRleHQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldFRleHRTaXplOiBmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBkdW1teUNhbnZhcyA9IHRoaXMuZHVtbXlDYW52YXM7XHJcbiAgICAgICAgICAgIHZhciBfY29udGV4dCA9IGR1bW15Q2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcblxyXG4gICAgICAgICAgICBfY29udGV4dC5zYXZlKCk7XHJcblxyXG4gICAgICAgICAgICBfY29udGV4dC5mb250ID0gdGhpcy5fZ2V0Q29udGV4dEZvbnQoKTtcclxuICAgICAgICAgICAgdmFyIG1ldHJpY3MgPSBfY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KTtcclxuXHJcbiAgICAgICAgICAgIF9jb250ZXh0LnJlc3RvcmUoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogbWV0cmljcy53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogcGFyc2VJbnQodGhpcy5hdHRycy5mb250U2l6ZSwgMTApXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfc2V0VGV4dERhdGE6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuX2dldFRleHRTaXplKHRoaXMuYXR0cnMudGV4dCk7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dFdpZHRoID0gc2l6ZS53aWR0aDtcclxuICAgICAgICAgICAgdGhpcy50ZXh0SGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdseXBoSW5mbyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNoYXJBcnIgPSB0aGlzLmF0dHJzLnRleHQuc3BsaXQoJycpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHAwLCBwMSwgcGF0aENtZDtcclxuXHJcbiAgICAgICAgICAgIHZhciBwSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRUID0gMDtcclxuXHJcbiAgICAgICAgICAgIHZhciBnZXROZXh0UGF0aFNlZ21lbnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHRoYXQuZGF0YUFycmF5O1xyXG5cclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IHBJbmRleCArIDE7IGogPCBwYXRoRGF0YS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHBhdGhEYXRhW2pdLnBhdGhMZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBJbmRleCA9IGo7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aERhdGFbal07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYocGF0aERhdGFbal0uY29tbWFuZCA9PT0gJ00nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAwID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogcGF0aERhdGFbal0ucG9pbnRzWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogcGF0aERhdGFbal0ucG9pbnRzWzFdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGZpbmRTZWdtZW50VG9GaXRDaGFyYWN0ZXIgPSBmdW5jdGlvbihjKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGdseXBoV2lkdGggPSB0aGF0Ll9nZXRUZXh0U2l6ZShjKS53aWR0aDtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgY3VyckxlbiA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXR0ZW1wdHMgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIHAxID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUoTWF0aC5hYnMoZ2x5cGhXaWR0aCAtIGN1cnJMZW4pIC8gZ2x5cGhXaWR0aCA+IDAuMDEgJiYgYXR0ZW1wdHMgPCAyNSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1bXVsYXRpdmVQYXRoTGVuZ3RoID0gY3VyckxlbjtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZShwYXRoQ21kID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aENtZCA9IGdldE5leHRQYXRoU2VnbWVudCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYocGF0aENtZCAmJiBjdW11bGF0aXZlUGF0aExlbmd0aCArIHBhdGhDbWQucGF0aExlbmd0aCA8IGdseXBoV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1bXVsYXRpdmVQYXRoTGVuZ3RoICs9IHBhdGhDbWQucGF0aExlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhDbWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHBhdGhDbWQgPT09IHt9IHx8IHAwID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZWVkTmV3U2VnbWVudCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhdGhDbWQuY29tbWFuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdMJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKEtvbnZhLlBhdGguZ2V0TGluZUxlbmd0aChwMC54LCBwMC55LCBwYXRoQ21kLnBvaW50c1swXSwgcGF0aENtZC5wb2ludHNbMV0pID4gZ2x5cGhXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAxID0gS29udmEuUGF0aC5nZXRQb2ludE9uTGluZShnbHlwaFdpZHRoLCBwMC54LCBwMC55LCBwYXRoQ21kLnBvaW50c1swXSwgcGF0aENtZC5wb2ludHNbMV0sIHAwLngsIHAwLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aENtZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdBJzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBwYXRoQ21kLnBvaW50c1s0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDQgPSB0aGV0YVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRUaGV0YSA9IHBhdGhDbWQucG9pbnRzWzVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNSA9IGRUaGV0YVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IHBhdGhDbWQucG9pbnRzWzRdICsgZFRoZXRhO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRUID09PSAwKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IHN0YXJ0ICsgMC4wMDAwMDAwMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgaW4gY2FzZSBzdGFydCBpcyAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGdseXBoV2lkdGggPiBjdXJyTGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgKz0gKE1hdGguUEkgLyAxODAuMCkgKiBkVGhldGEgLyBNYXRoLmFicyhkVGhldGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgLT0gTWF0aC5QSSAvIDM2MC4wICogZFRoZXRhIC8gTWF0aC5hYnMoZFRoZXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVkaXQgZm9yIGJ1ZyBmaXg6IEB0aGVydGggaHR0cHM6Ly9naXRodWIuY29tL2VyaWNkcm93ZWxsL0tvbnZhSlMvaXNzdWVzLzI0OVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2xkIGNvZGUgZmFpbGVkIHRvIHJlbmRlciB0ZXh0IGFsb25nIGFyYyBvZiB0aGlzIHBhdGg6IFwiTSA1MCA1MCBhIDE1MCA1MCAwIDAgMSAyNTAgNTAgbCA1MCAwXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRUaGV0YSA8IDAgJiYgY3VycmVudFQgPCBlbmQgfHwgZFRoZXRhID49IDAgJiYgY3VycmVudFQgPiBlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IGVuZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWVkTmV3U2VnbWVudCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMSA9IEtvbnZhLlBhdGguZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMocGF0aENtZC5wb2ludHNbMF0sIHBhdGhDbWQucG9pbnRzWzFdLCBwYXRoQ21kLnBvaW50c1syXSwgcGF0aENtZC5wb2ludHNbM10sIGN1cnJlbnRULCBwYXRoQ21kLnBvaW50c1s2XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnQyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjdXJyZW50VCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGdseXBoV2lkdGggPiBwYXRoQ21kLnBhdGhMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgPSAwLjAwMDAwMDAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgPSBnbHlwaFdpZHRoIC8gcGF0aENtZC5wYXRoTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZ2x5cGhXaWR0aCA+IGN1cnJMZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCArPSAoZ2x5cGhXaWR0aCAtIGN1cnJMZW4pIC8gcGF0aENtZC5wYXRoTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgLT0gKGN1cnJMZW4gLSBnbHlwaFdpZHRoKSAvIHBhdGhDbWQucGF0aExlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjdXJyZW50VCA+IDEuMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gMS4wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZWROZXdTZWdtZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAxID0gS29udmEuUGF0aC5nZXRQb2ludE9uQ3ViaWNCZXppZXIoY3VycmVudFQsIHBhdGhDbWQuc3RhcnQueCwgcGF0aENtZC5zdGFydC55LCBwYXRoQ21kLnBvaW50c1swXSwgcGF0aENtZC5wb2ludHNbMV0sIHBhdGhDbWQucG9pbnRzWzJdLCBwYXRoQ21kLnBvaW50c1szXSwgcGF0aENtZC5wb2ludHNbNF0sIHBhdGhDbWQucG9pbnRzWzVdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdRJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRUID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgPSBnbHlwaFdpZHRoIC8gcGF0aENtZC5wYXRoTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihnbHlwaFdpZHRoID4gY3Vyckxlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUICs9IChnbHlwaFdpZHRoIC0gY3VyckxlbikgLyBwYXRoQ21kLnBhdGhMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCAtPSAoY3VyckxlbiAtIGdseXBoV2lkdGgpIC8gcGF0aENtZC5wYXRoTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRUID4gMS4wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgPSAxLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVlZE5ld1NlZ21lbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcDEgPSBLb252YS5QYXRoLmdldFBvaW50T25RdWFkcmF0aWNCZXppZXIoY3VycmVudFQsIHBhdGhDbWQuc3RhcnQueCwgcGF0aENtZC5zdGFydC55LCBwYXRoQ21kLnBvaW50c1swXSwgcGF0aENtZC5wb2ludHNbMV0sIHBhdGhDbWQucG9pbnRzWzJdLCBwYXRoQ21kLnBvaW50c1szXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihwMSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJMZW4gPSBLb252YS5QYXRoLmdldExpbmVMZW5ndGgocDAueCwgcDAueSwgcDEueCwgcDEueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihuZWVkTmV3U2VnbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkTmV3U2VnbWVudCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoQ21kID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNoYXJBcnIubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHAxIHN1Y2ggdGhhdCBsaW5lIHNlZ21lbnQgYmV0d2VlbiBwMCBhbmQgcDEgaXMgYXBwcm94LiB3aWR0aCBvZiBnbHlwaFxyXG4gICAgICAgICAgICAgICAgZmluZFNlZ21lbnRUb0ZpdENoYXJhY3RlcihjaGFyQXJyW2ldKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihwMCA9PT0gdW5kZWZpbmVkIHx8IHAxID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBLb252YS5QYXRoLmdldExpbmVMZW5ndGgocDAueCwgcDAueSwgcDEueCwgcDEueSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogU2luY2UgZ2x5cGhzIGFyZSByZW5kZXJlZCBvbmUgYXQgYSB0aW1lLCBhbnkga2VybmluZyBwYWlyIGRhdGEgYnVpbHQgaW50byB0aGUgZm9udCB3aWxsIG5vdCBiZSB1c2VkLlxyXG4gICAgICAgICAgICAgICAgLy8gQ2FuIGZvcmVzZWUgaGF2aW5nIGEgcm91Z2ggcGFpciB0YWJsZSBidWlsdCBpbiB0aGF0IHRoZSBkZXZlbG9wZXIgY2FuIG92ZXJyaWRlIGFzIG5lZWRlZC5cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIga2VybiA9IDA7XHJcbiAgICAgICAgICAgICAgICAvLyBwbGFjZWhvbGRlciBmb3IgZnV0dXJlIGltcGxlbWVudGF0aW9uXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG1pZHBvaW50ID0gS29udmEuUGF0aC5nZXRQb2ludE9uTGluZShrZXJuICsgd2lkdGggLyAyLjAsIHAwLngsIHAwLnksIHAxLngsIHAxLnkpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciByb3RhdGlvbiA9IE1hdGguYXRhbjIoKHAxLnkgLSBwMC55KSwgKHAxLnggLSBwMC54KSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdseXBoSW5mby5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc3Bvc2VYOiBtaWRwb2ludC54LFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9zZVk6IG1pZHBvaW50LnksXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogY2hhckFycltpXSxcclxuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogcm90YXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgcDA6IHAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHAxOiBwMVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBwMCA9IHAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRTZWxmUmVjdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGZvbnRTaXplID0gdGhpcy5mb250U2l6ZSgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5nbHlwaEluZm8uZm9yRWFjaChmdW5jdGlvbihpbmZvKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChpbmZvLnAwLngpO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goaW5mby5wMC55KTtcclxuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGluZm8ucDEueCk7XHJcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChpbmZvLnAxLnkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIG1pblggPSBwb2ludHNbMF07XHJcbiAgICAgICAgICAgIHZhciBtYXhYID0gcG9pbnRzWzBdO1xyXG4gICAgICAgICAgICB2YXIgbWluWSA9IHBvaW50c1swXTtcclxuICAgICAgICAgICAgdmFyIG1heFkgPSBwb2ludHNbMF07XHJcbiAgICAgICAgICAgIHZhciB4LCB5O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHggPSBwb2ludHNbaSAqIDJdOyB5ID0gcG9pbnRzW2kgKiAyICsgMV07XHJcbiAgICAgICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCk7XHJcbiAgICAgICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCk7XHJcbiAgICAgICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSk7XHJcbiAgICAgICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHg6IE1hdGgucm91bmQobWluWCkgLSBmb250U2l6ZSxcclxuICAgICAgICAgICAgICAgIHk6IE1hdGgucm91bmQobWluWSkgLSBmb250U2l6ZSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKG1heFggLSBtaW5YKSArIGZvbnRTaXplICogMixcclxuICAgICAgICAgICAgICAgIGhlaWdodDogTWF0aC5yb3VuZChtYXhZIC0gbWluWSkgKyBmb250U2l6ZSAqIDJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIG1hcCBUZXh0UGF0aCBtZXRob2RzIHRvIFRleHRcclxuICAgIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZS5fZ2V0Q29udGV4dEZvbnQgPSBLb252YS5UZXh0LnByb3RvdHlwZS5fZ2V0Q29udGV4dEZvbnQ7XHJcblxyXG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuVGV4dFBhdGgsIEtvbnZhLlNoYXBlKTtcclxuXHJcbiAgICAvLyBhZGQgc2V0dGVycyBhbmQgZ2V0dGVyc1xyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dFBhdGgsICdmb250RmFtaWx5JywgJ0FyaWFsJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzZXQgZm9udCBmYW1pbHlcclxuICAgICAqIEBuYW1lIHNldEZvbnRGYW1pbHlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb250RmFtaWx5XHJcbiAgICAgKi9cclxuXHJcbiAgICAgLyoqXHJcbiAgICAgKiBnZXQgZm9udCBmYW1pbHlcclxuICAgICAqIEBuYW1lIGdldEZvbnRGYW1pbHlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHRQYXRoLCAnZm9udFNpemUnLCAxMik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzZXQgZm9udCBzaXplXHJcbiAgICAgKiBAbmFtZSBzZXRGb250U2l6ZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtpbnR9IGZvbnRTaXplXHJcbiAgICAgKi9cclxuXHJcbiAgICAgLyoqXHJcbiAgICAgKiBnZXQgZm9udCBzaXplXHJcbiAgICAgKiBAbmFtZSBnZXRGb250U2l6ZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dFBhdGgsICdmb250U3R5bGUnLCBOT1JNQUwpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2V0IGZvbnQgc3R5bGUuICBDYW4gYmUgJ25vcm1hbCcsICdpdGFsaWMnLCBvciAnYm9sZCcuICAnbm9ybWFsJyBpcyB0aGUgZGVmYXVsdC5cclxuICAgICAqIEBuYW1lIHNldEZvbnRTdHlsZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvbnRTdHlsZVxyXG4gICAgICovXHJcblxyXG4gICAgIC8qKlxyXG4gICAgICogZ2V0IGZvbnQgc3R5bGVcclxuICAgICAqIEBuYW1lIGdldEZvbnRTdHlsZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dFBhdGgsICdmb250VmFyaWFudCcsIE5PUk1BTCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzZXQgZm9udCB2YXJpYW50LiAgQ2FuIGJlICdub3JtYWwnIG9yICdzbWFsbC1jYXBzJy4gICdub3JtYWwnIGlzIHRoZSBkZWZhdWx0LlxyXG4gICAgICogQG5hbWUgc2V0Rm9udFZhcmlhbnRcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb250VmFyaWFudFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZ2V0IGZvbnQgdmFyaWFudFxyXG4gICAgICogQG5hbWUgZ2V0Rm9udFZhcmlhbnRcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyKEtvbnZhLlRleHRQYXRoLCAndGV4dCcsIEVNUFRZX1NUUklORyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQgdGV4dFxyXG4gICAgICogQG5hbWUgZ2V0VGV4dFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLlRleHRQYXRoKTtcclxufSkoKTtcclxuXG4oZnVuY3Rpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICAvKipcclxuICAgICAqIFJlZ3VsYXJQb2x5Z29uIGNvbnN0cnVjdG9yLiZuYnNwOyBFeGFtcGxlcyBpbmNsdWRlIHRyaWFuZ2xlcywgc3F1YXJlcywgcGVudGFnb25zLCBoZXhhZ29ucywgZXRjLlxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcclxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5zaWRlc1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5yYWRpdXNcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiB2YXIgaGV4YWdvbiA9IG5ldyBLb252YS5SZWd1bGFyUG9seWdvbih7XHJcbiAgICAgKiAgIHg6IDEwMCxcclxuICAgICAqICAgeTogMjAwLFxyXG4gICAgICogICBzaWRlczogNixcclxuICAgICAqICAgcmFkaXVzOiA3MCxcclxuICAgICAqICAgZmlsbDogJ3JlZCcsXHJcbiAgICAgKiAgIHN0cm9rZTogJ2JsYWNrJyxcclxuICAgICAqICAgc3Ryb2tlV2lkdGg6IDRcclxuICAgICAqIH0pO1xyXG4gICAgICovXHJcbiAgICBLb252YS5SZWd1bGFyUG9seWdvbiA9IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xyXG4gICAgfTtcclxuXHJcbiAgICBLb252YS5SZWd1bGFyUG9seWdvbi5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgX2NlbnRyb2lkOiB0cnVlLFxyXG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAnUmVndWxhclBvbHlnb24nO1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgc2lkZXMgPSB0aGlzLmF0dHJzLnNpZGVzLFxyXG4gICAgICAgICAgICAgICAgcmFkaXVzID0gdGhpcy5hdHRycy5yYWRpdXMsXHJcbiAgICAgICAgICAgICAgICBuLCB4LCB5O1xyXG5cclxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oMCwgMCAtIHJhZGl1cyk7XHJcblxyXG4gICAgICAgICAgICBmb3IobiA9IDE7IG4gPCBzaWRlczsgbisrKSB7XHJcbiAgICAgICAgICAgICAgICB4ID0gcmFkaXVzICogTWF0aC5zaW4obiAqIDIgKiBNYXRoLlBJIC8gc2lkZXMpO1xyXG4gICAgICAgICAgICAgICAgeSA9IC0xICogcmFkaXVzICogTWF0aC5jb3MobiAqIDIgKiBNYXRoLlBJIC8gc2lkZXMpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oeCwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJhZGl1cygpICogMjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldEhlaWdodCgpXHJcbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFkaXVzKCkgKiAyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0V2lkdGgoKVxyXG4gICAgICAgIHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xyXG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRXaWR0aC5jYWxsKHRoaXMsIHdpZHRoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmFkaXVzKCkgIT09IHdpZHRoIC8gMikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYWRpdXMod2lkdGggLyAyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0SGVpZ2h0KClcclxuICAgICAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xyXG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRIZWlnaHQuY2FsbCh0aGlzLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yYWRpdXMoKSAhPT0gaGVpZ2h0IC8gMikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYWRpdXMoaGVpZ2h0IC8gMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuUmVndWxhclBvbHlnb24sIEtvbnZhLlNoYXBlKTtcclxuXHJcbiAgICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5SZWd1bGFyUG9seWdvbiwgJ3JhZGl1cycsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2V0IHJhZGl1c1xyXG4gICAgICogQG5hbWUgc2V0UmFkaXVzXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuUmVndWxhclBvbHlnb24ucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXHJcbiAgICAgKi9cclxuXHJcbiAgICAgLyoqXHJcbiAgICAgKiBnZXQgcmFkaXVzXHJcbiAgICAgKiBAbmFtZSBnZXRSYWRpdXNcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5SZWd1bGFyUG9seWdvbi5wcm90b3R5cGVcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlJlZ3VsYXJQb2x5Z29uLCAnc2lkZXMnLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHNldCBudW1iZXIgb2Ygc2lkZXNcclxuICAgICAqIEBuYW1lIHNldFNpZGVzXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuUmVndWxhclBvbHlnb24ucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge2ludH0gc2lkZXNcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0IG51bWJlciBvZiBzaWRlc1xyXG4gICAgICogQG5hbWUgZ2V0U2lkZXNcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5SZWd1bGFyUG9seWdvbi5wcm90b3R5cGVcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5SZWd1bGFyUG9seWdvbik7XHJcbn0pKCk7XHJcblxuKGZ1bmN0aW9uKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFyIGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxyXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXHJcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGNvbmZpZy5udW1Qb2ludHNcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuaW5uZXJSYWRpdXNcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcub3V0ZXJSYWRpdXNcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiB2YXIgc3RhciA9IG5ldyBLb252YS5TdGFyKHtcclxuICAgICAqICAgeDogMTAwLFxyXG4gICAgICogICB5OiAyMDAsXHJcbiAgICAgKiAgIG51bVBvaW50czogNSxcclxuICAgICAqICAgaW5uZXJSYWRpdXM6IDcwLFxyXG4gICAgICogICBvdXRlclJhZGl1czogNzAsXHJcbiAgICAgKiAgIGZpbGw6ICdyZWQnLFxyXG4gICAgICogICBzdHJva2U6ICdibGFjaycsXHJcbiAgICAgKiAgIHN0cm9rZVdpZHRoOiA0XHJcbiAgICAgKiB9KTtcclxuICAgICAqL1xyXG4gICAgS29udmEuU3RhciA9IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xyXG4gICAgfTtcclxuXHJcbiAgICBLb252YS5TdGFyLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBfY2VudHJvaWQ6IHRydWUsXHJcbiAgICAgICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XHJcbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcclxuICAgICAgICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICdTdGFyJztcclxuICAgICAgICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIGlubmVyUmFkaXVzID0gdGhpcy5pbm5lclJhZGl1cygpLFxyXG4gICAgICAgICAgICAgICAgb3V0ZXJSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzKCksXHJcbiAgICAgICAgICAgICAgICBudW1Qb2ludHMgPSB0aGlzLm51bVBvaW50cygpO1xyXG5cclxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oMCwgMCAtIG91dGVyUmFkaXVzKTtcclxuXHJcbiAgICAgICAgICAgIGZvcih2YXIgbiA9IDE7IG4gPCBudW1Qb2ludHMgKiAyOyBuKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciByYWRpdXMgPSBuICUgMiA9PT0gMCA/IG91dGVyUmFkaXVzIDogaW5uZXJSYWRpdXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHJhZGl1cyAqIE1hdGguc2luKG4gKiBNYXRoLlBJIC8gbnVtUG9pbnRzKTtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0gLTEgKiByYWRpdXMgKiBNYXRoLmNvcyhuICogTWF0aC5QSSAvIG51bVBvaW50cyk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG5cclxuICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRXaWR0aCgpXHJcbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPdXRlclJhZGl1cygpICogMjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldEhlaWdodCgpXHJcbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAqIDI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRXaWR0aCgpXHJcbiAgICAgICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XHJcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFdpZHRoLmNhbGwodGhpcywgd2lkdGgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vdXRlclJhZGl1cygpICE9PSB3aWR0aCAvIDIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0T3V0ZXJSYWRpdXMod2lkdGggLyAyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0SGVpZ2h0KClcclxuICAgICAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xyXG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRIZWlnaHQuY2FsbCh0aGlzLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vdXRlclJhZGl1cygpICE9PSBoZWlnaHQgLyAyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE91dGVyUmFkaXVzKGhlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlN0YXIsIEtvbnZhLlNoYXBlKTtcclxuXHJcbiAgICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TdGFyLCAnbnVtUG9pbnRzJywgNSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzZXQgbnVtYmVyIG9mIHBvaW50c1xyXG4gICAgICogQG5hbWUgc2V0TnVtUG9pbnRzXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3Rhci5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gcG9pbnRzXHJcbiAgICAgKi9cclxuXHJcbiAgICAgLyoqXHJcbiAgICAgKiBnZXQgbnVtYmVyIG9mIHBvaW50c1xyXG4gICAgICogQG5hbWUgZ2V0TnVtUG9pbnRzXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3Rhci5wcm90b3R5cGVcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlN0YXIsICdpbm5lclJhZGl1cycsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2V0IGlubmVyIHJhZGl1c1xyXG4gICAgICogQG5hbWUgc2V0SW5uZXJSYWRpdXNcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFyLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xyXG4gICAgICovXHJcblxyXG4gICAgIC8qKlxyXG4gICAgICogZ2V0IGlubmVyIHJhZGl1c1xyXG4gICAgICogQG5hbWUgZ2V0SW5uZXJSYWRpdXNcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFyLnByb3RvdHlwZVxyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3RhciwgJ291dGVyUmFkaXVzJywgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzZXQgb3V0ZXIgcmFkaXVzXHJcbiAgICAgKiBAbmFtZSBzZXRPdXRlclJhZGl1c1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YXIucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXHJcbiAgICAgKi9cclxuXHJcbiAgICAgLyoqXHJcbiAgICAgKiBnZXQgb3V0ZXIgcmFkaXVzXHJcbiAgICAgKiBAbmFtZSBnZXRPdXRlclJhZGl1c1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YXIucHJvdG90eXBlXHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuU3Rhcik7XHJcbn0pKCk7XHJcblxuKGZ1bmN0aW9uKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgLy8gY29uc3RhbnRzXHJcbiAgICB2YXIgQVRUUl9DSEFOR0VfTElTVCA9IFsnZm9udEZhbWlseScsICdmb250U2l6ZScsICdmb250U3R5bGUnLCAncGFkZGluZycsICdsaW5lSGVpZ2h0JywgJ3RleHQnXSxcclxuICAgICAgICBDSEFOR0VfS09OVkEgPSAnQ2hhbmdlLmtvbnZhJyxcclxuICAgICAgICBOT05FID0gJ25vbmUnLFxyXG4gICAgICAgIFVQID0gJ3VwJyxcclxuICAgICAgICBSSUdIVCA9ICdyaWdodCcsXHJcbiAgICAgICAgRE9XTiA9ICdkb3duJyxcclxuICAgICAgICBMRUZUID0gJ2xlZnQnLFxyXG4gICAgICAgIExBQkVMID0gJ0xhYmVsJyxcclxuXHJcbiAgICAgLy8gY2FjaGVkIHZhcmlhYmxlc1xyXG4gICAgIGF0dHJDaGFuZ2VMaXN0TGVuID0gQVRUUl9DSEFOR0VfTElTVC5sZW5ndGg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMYWJlbCBjb25zdHJ1Y3Rvci4mbmJzcDsgTGFiZWxzIGFyZSBncm91cHMgdGhhdCBjb250YWluIGEgVGV4dCBhbmQgVGFnIHNoYXBlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBjcmVhdGUgbGFiZWxcclxuICAgICAqIHZhciBsYWJlbCA9IG5ldyBLb252YS5MYWJlbCh7XHJcbiAgICAgKiAgIHg6IDEwMCxcclxuICAgICAqICAgeTogMTAwLFxyXG4gICAgICogICBkcmFnZ2FibGU6IHRydWVcclxuICAgICAqIH0pO1xyXG4gICAgICpcclxuICAgICAqIC8vIGFkZCBhIHRhZyB0byB0aGUgbGFiZWxcclxuICAgICAqIGxhYmVsLmFkZChuZXcgS29udmEuVGFnKHtcclxuICAgICAqICAgZmlsbDogJyNiYmInLFxyXG4gICAgICogICBzdHJva2U6ICcjMzMzJyxcclxuICAgICAqICAgc2hhZG93Q29sb3I6ICdibGFjaycsXHJcbiAgICAgKiAgIHNoYWRvd0JsdXI6IDEwLFxyXG4gICAgICogICBzaGFkb3dPZmZzZXQ6IFsxMCwgMTBdLFxyXG4gICAgICogICBzaGFkb3dPcGFjaXR5OiAwLjIsXHJcbiAgICAgKiAgIGxpbmVKb2luOiAncm91bmQnLFxyXG4gICAgICogICBwb2ludGVyRGlyZWN0aW9uOiAndXAnLFxyXG4gICAgICogICBwb2ludGVyV2lkdGg6IDIwLFxyXG4gICAgICogICBwb2ludGVySGVpZ2h0OiAyMCxcclxuICAgICAqICAgY29ybmVyUmFkaXVzOiA1XHJcbiAgICAgKiB9KSk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gYWRkIHRleHQgdG8gdGhlIGxhYmVsXHJcbiAgICAgKiBsYWJlbC5hZGQobmV3IEtvbnZhLlRleHQoe1xyXG4gICAgICogICB0ZXh0OiAnSGVsbG8gV29ybGQhJyxcclxuICAgICAqICAgZm9udFNpemU6IDUwLFxyXG4gICAgICogICBsaW5lSGVpZ2h0OiAxLjIsXHJcbiAgICAgKiAgIHBhZGRpbmc6IDEwLFxyXG4gICAgICogICBmaWxsOiAnZ3JlZW4nXHJcbiAgICAgKiAgfSkpO1xyXG4gICAgICovXHJcbiAgICBLb252YS5MYWJlbCA9IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuX19fX2luaXQoY29uZmlnKTtcclxuICAgIH07XHJcblxyXG4gICAgS29udmEuTGFiZWwucHJvdG90eXBlID0ge1xyXG4gICAgICAgIF9fX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgS29udmEuR3JvdXAuY2FsbCh0aGlzLCBjb25maWcpO1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IExBQkVMO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5vbignYWRkLmtvbnZhJywgZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll9hZGRMaXN0ZW5lcnMoZXZ0LmNoaWxkKTtcclxuICAgICAgICAgICAgICAgIHRoYXQuX3N5bmMoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBnZXQgVGV4dCBzaGFwZSBmb3IgdGhlIGxhYmVsLiAgWW91IG5lZWQgdG8gYWNjZXNzIHRoZSBUZXh0IHNoYXBlIGluIG9yZGVyIHRvIHVwZGF0ZVxyXG4gICAgICAgICAqIHRoZSB0ZXh0IHByb3BlcnRpZXNcclxuICAgICAgICAgKiBAbmFtZSBnZXRUZXh0XHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5MYWJlbC5wcm90b3R5cGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRUZXh0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZCgnVGV4dCcpWzBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogZ2V0IFRhZyBzaGFwZSBmb3IgdGhlIGxhYmVsLiAgWW91IG5lZWQgdG8gYWNjZXNzIHRoZSBUYWcgc2hhcGUgaW4gb3JkZXIgdG8gdXBkYXRlXHJcbiAgICAgICAgICogdGhlIHBvaW50ZXIgcHJvcGVydGllcyBhbmQgdGhlIGNvcm5lciByYWRpdXNcclxuICAgICAgICAgKiBAbmFtZSBnZXRUYWdcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkxhYmVsLnByb3RvdHlwZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFRhZzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmQoJ1RhZycpWzBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2FkZExpc3RlbmVyczogZnVuY3Rpb24odGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBuO1xyXG4gICAgICAgICAgICB2YXIgZnVuYyA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fc3luYygpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0ZXh0IGRhdGEgZm9yIGNlcnRhaW4gYXR0ciBjaGFuZ2VzXHJcbiAgICAgICAgICAgIGZvcihuID0gMDsgbiA8IGF0dHJDaGFuZ2VMaXN0TGVuOyBuKyspIHtcclxuICAgICAgICAgICAgICAgIHRleHQub24oQVRUUl9DSEFOR0VfTElTVFtuXSArIENIQU5HRV9LT05WQSwgZnVuYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGV4dCgpLmdldFdpZHRoKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUZXh0KCkuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfc3luYzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5nZXRUZXh0KCksXHJcbiAgICAgICAgICAgICAgICB0YWcgPSB0aGlzLmdldFRhZygpLFxyXG4gICAgICAgICAgICAgICAgd2lkdGgsIGhlaWdodCwgcG9pbnRlckRpcmVjdGlvbiwgcG9pbnRlcldpZHRoLCB4LCB5LCBwb2ludGVySGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgaWYgKHRleHQgJiYgdGFnKSB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHRleHQuZ2V0V2lkdGgoKTtcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHRleHQuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyRGlyZWN0aW9uID0gdGFnLmdldFBvaW50ZXJEaXJlY3Rpb24oKTtcclxuICAgICAgICAgICAgICAgIHBvaW50ZXJXaWR0aCA9IHRhZy5nZXRQb2ludGVyV2lkdGgoKTtcclxuICAgICAgICAgICAgICAgIHBvaW50ZXJIZWlnaHQgPSB0YWcuZ2V0UG9pbnRlckhlaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgeCA9IDA7XHJcbiAgICAgICAgICAgICAgICB5ID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2gocG9pbnRlckRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVVA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSB3aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSAtMSAqIHBvaW50ZXJIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUklHSFQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSB3aWR0aCArIHBvaW50ZXJXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRE9XTjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHdpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGhlaWdodCArIHBvaW50ZXJIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTEVGVDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IC0xICogcG9pbnRlcldpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGFnLnNldEF0dHJzKHtcclxuICAgICAgICAgICAgICAgICAgICB4OiAtMSAqIHgsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogLTEgKiB5LFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGV4dC5zZXRBdHRycyh7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogLTEgKiB4LFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IC0xICogeVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkxhYmVsLCBLb252YS5Hcm91cCk7XHJcblxyXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLkxhYmVsKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRhZyBjb25zdHJ1Y3Rvci4mbmJzcDsgQSBUYWcgY2FuIGJlIGNvbmZpZ3VyZWRcclxuICAgICAqICB0byBoYXZlIGEgcG9pbnRlciBlbGVtZW50IHRoYXQgcG9pbnRzIHVwLCByaWdodCwgZG93biwgb3IgbGVmdFxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnBvaW50ZXJEaXJlY3Rpb25dIGNhbiBiZSB1cCwgcmlnaHQsIGRvd24sIGxlZnQsIG9yIG5vbmU7IHRoZSBkZWZhdWx0XHJcbiAgICAgKiAgaXMgbm9uZS4gIFdoZW4gYSBwb2ludGVyIGlzIHByZXNlbnQsIHRoZSBwb3NpdGlvbmluZyBvZiB0aGUgbGFiZWwgaXMgcmVsYXRpdmUgdG8gdGhlIHRpcCBvZiB0aGUgcG9pbnRlci5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnBvaW50ZXJXaWR0aF1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnBvaW50ZXJIZWlnaHRdXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jb3JuZXJSYWRpdXNdXHJcbiAgICAgKi9cclxuICAgIEtvbnZhLlRhZyA9IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xyXG4gICAgfTtcclxuXHJcbiAgICBLb252YS5UYWcucHJvdG90eXBlID0ge1xyXG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgICAgICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1RhZyc7XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCksXHJcbiAgICAgICAgICAgICAgICBwb2ludGVyRGlyZWN0aW9uID0gdGhpcy5nZXRQb2ludGVyRGlyZWN0aW9uKCksXHJcbiAgICAgICAgICAgICAgICBwb2ludGVyV2lkdGggPSB0aGlzLmdldFBvaW50ZXJXaWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgcG9pbnRlckhlaWdodCA9IHRoaXMuZ2V0UG9pbnRlckhlaWdodCgpLFxyXG4gICAgICAgICAgICAgICAgY29ybmVyUmFkaXVzID0gdGhpcy5nZXRDb3JuZXJSYWRpdXMoKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKDAsIDApO1xyXG5cclxuICAgICAgICAgICAgaWYgKHBvaW50ZXJEaXJlY3Rpb24gPT09IFVQKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbygod2lkdGggLSBwb2ludGVyV2lkdGgpIC8gMiwgMCk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCAvIDIsIC0xICogcG9pbnRlckhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbygod2lkdGggKyBwb2ludGVyV2lkdGgpIC8gMiwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCFjb3JuZXJSYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoLCAwKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoIC0gY29ybmVyUmFkaXVzLCAwKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuYXJjKHdpZHRoIC0gY29ybmVyUmFkaXVzLCBjb3JuZXJSYWRpdXMsIGNvcm5lclJhZGl1cywgTWF0aC5QSSAqIDMgLyAyLCAwLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChwb2ludGVyRGlyZWN0aW9uID09PSBSSUdIVCkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGgsIChoZWlnaHQgLSBwb2ludGVySGVpZ2h0KSAvIDIpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGggKyBwb2ludGVyV2lkdGgsIGhlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGgsIChoZWlnaHQgKyBwb2ludGVySGVpZ2h0KSAvIDIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZighY29ybmVyUmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoLCBoZWlnaHQgLSBjb3JuZXJSYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5hcmMod2lkdGggLSBjb3JuZXJSYWRpdXMsIGhlaWdodCAtIGNvcm5lclJhZGl1cywgY29ybmVyUmFkaXVzLCAwLCBNYXRoLlBJIC8gMiwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocG9pbnRlckRpcmVjdGlvbiA9PT0gRE9XTikge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oKHdpZHRoICsgcG9pbnRlcldpZHRoKSAvIDIsIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCAvIDIsIGhlaWdodCArIHBvaW50ZXJIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oKHdpZHRoIC0gcG9pbnRlcldpZHRoKSAvIDIsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCFjb3JuZXJSYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDAsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhjb3JuZXJSYWRpdXMsIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFyYyhjb3JuZXJSYWRpdXMsIGhlaWdodCAtIGNvcm5lclJhZGl1cywgY29ybmVyUmFkaXVzLCBNYXRoLlBJIC8gMiwgTWF0aC5QSSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocG9pbnRlckRpcmVjdGlvbiA9PT0gTEVGVCkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oMCwgKGhlaWdodCArIHBvaW50ZXJIZWlnaHQpIC8gMik7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbygtMSAqIHBvaW50ZXJXaWR0aCwgaGVpZ2h0IC8gMik7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbygwLCAoaGVpZ2h0IC0gcG9pbnRlckhlaWdodCkgLyAyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoY29ybmVyUmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbygwLCBjb3JuZXJSYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5hcmMoY29ybmVyUmFkaXVzLCBjb3JuZXJSYWRpdXMsIGNvcm5lclJhZGl1cywgTWF0aC5QSSwgTWF0aC5QSSAqIDMgLyAyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0U2VsZlJlY3Q6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgeCA9IDAsXHJcbiAgICAgICAgICAgICAgICB5ID0gMCxcclxuICAgICAgICAgICAgICAgIHBvaW50ZXJXaWR0aCA9IHRoaXMuZ2V0UG9pbnRlcldpZHRoKCksXHJcbiAgICAgICAgICAgICAgICBwb2ludGVySGVpZ2h0ID0gdGhpcy5nZXRQb2ludGVySGVpZ2h0KCksXHJcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSB0aGlzLnBvaW50ZXJEaXJlY3Rpb24oKSxcclxuICAgICAgICAgICAgICAgIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IFVQKSB7XHJcbiAgICAgICAgICAgICAgICB5IC09IHBvaW50ZXJIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgKz0gcG9pbnRlckhlaWdodDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IERPV04pIHtcclxuICAgICAgICAgICAgICAgIGhlaWdodCArPSBwb2ludGVySGVpZ2h0O1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gTEVGVCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQVJHSCEhISBJIGhhdmUgbm8gaWRlYSB3aHkgc2hvdWxkIEkgdXNlZCBtYWdpYyAxLjUhISEhISEhISFcclxuICAgICAgICAgICAgICAgIHggLT0gcG9pbnRlcldpZHRoICogMS41O1xyXG4gICAgICAgICAgICAgICAgd2lkdGggKz0gcG9pbnRlcldpZHRoO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gUklHSFQpIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoICs9IHBvaW50ZXJXaWR0aCAqIDEuNTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuVGFnLCBLb252YS5TaGFwZSk7XHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UYWcsICdwb2ludGVyRGlyZWN0aW9uJywgTk9ORSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzZXQgcG9pbnRlciBEaXJlY3Rpb25cclxuICAgICAqIEBuYW1lIHNldFBvaW50ZXJEaXJlY3Rpb25cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UYWcucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcG9pbnRlckRpcmVjdGlvbiBjYW4gYmUgdXAsIHJpZ2h0LCBkb3duLCBsZWZ0LCBvciBub25lLiAgVGhlXHJcbiAgICAgKiAgZGVmYXVsdCBpcyBub25lXHJcbiAgICAgKi9cclxuXHJcbiAgICAgLyoqXHJcbiAgICAgKiBnZXQgcG9pbnRlciBEaXJlY3Rpb25cclxuICAgICAqIEBuYW1lIGdldFBvaW50ZXJEaXJlY3Rpb25cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UYWcucHJvdG90eXBlXHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UYWcsICdwb2ludGVyV2lkdGgnLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHNldCBwb2ludGVyIHdpZHRoXHJcbiAgICAgKiBAbmFtZSBzZXRQb2ludGVyV2lkdGhcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UYWcucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9pbnRlcldpZHRoXHJcbiAgICAgKi9cclxuXHJcbiAgICAgLyoqXHJcbiAgICAgKiBnZXQgcG9pbnRlciB3aWR0aFxyXG4gICAgICogQG5hbWUgZ2V0UG9pbnRlcldpZHRoXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGFnLnByb3RvdHlwZVxyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGFnLCAncG9pbnRlckhlaWdodCcsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2V0IHBvaW50ZXIgaGVpZ2h0XHJcbiAgICAgKiBAbmFtZSBzZXRQb2ludGVySGVpZ2h0XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGFnLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvaW50ZXJIZWlnaHRcclxuICAgICAqL1xyXG5cclxuICAgICAvKipcclxuICAgICAqIGdldCBwb2ludGVyIGhlaWdodFxyXG4gICAgICogQG5hbWUgZ2V0UG9pbnRlckhlaWdodFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRhZy5wcm90b3R5cGVcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRhZywgJ2Nvcm5lclJhZGl1cycsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2V0IGNvcm5lciByYWRpdXNcclxuICAgICAqIEBuYW1lIHNldENvcm5lclJhZGl1c1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRhZy5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3JuZXIgcmFkaXVzXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldCBjb3JuZXIgcmFkaXVzXHJcbiAgICAgKiBAbmFtZSBnZXRDb3JuZXJSYWRpdXNcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UYWcucHJvdG90eXBlXHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuVGFnKTtcclxufSkoKTtcclxuXG4oZnVuY3Rpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICAvKipcclxuICAgICAqIEFycm93IGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxyXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWcucG9pbnRzXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy50ZW5zaW9uXSBIaWdoZXIgdmFsdWVzIHdpbGwgcmVzdWx0IGluIGEgbW9yZSBjdXJ2eSBsaW5lLiAgQSB2YWx1ZSBvZiAwIHdpbGwgcmVzdWx0IGluIG5vIGludGVycG9sYXRpb24uXHJcbiAgICAgKiAgIFRoZSBkZWZhdWx0IGlzIDBcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcucG9pbnRlckxlbmd0aFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5wb2ludGVyV2lkdGhcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiB2YXIgbGluZSA9IG5ldyBLb252YS5MaW5lKHtcclxuICAgICAqICAgcG9pbnRzOiBbNzMsIDcwLCAzNDAsIDIzLCA0NTAsIDYwLCA1MDAsIDIwXSxcclxuICAgICAqICAgc3Ryb2tlOiAncmVkJyxcclxuICAgICAqICAgdGVuc2lvbjogMSxcclxuICAgICAqICAgcG9pbnRlckxlbmd0aCA6IDEwLFxyXG4gICAgICogICBwb2ludGVyV2lkdGggOiAxMlxyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuICAgIEtvbnZhLkFycm93ID0gZnVuY3Rpb24oY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5fX19faW5pdChjb25maWcpO1xyXG4gICAgfTtcclxuXHJcbiAgICBLb252YS5BcnJvdy5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgX19fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgIEtvbnZhLkxpbmUuY2FsbCh0aGlzLCBjb25maWcpO1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICdBcnJvdyc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjdHgpIHtcclxuICAgICAgICAgICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMoKTtcclxuICAgICAgICAgICAgdmFyIG4gPSBwb2ludHMubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgZHggPSBwb2ludHNbbiAtIDJdIC0gcG9pbnRzW24gLSA0XTtcclxuICAgICAgICAgICAgdmFyIGR5ID0gcG9pbnRzW24gLSAxXSAtIHBvaW50c1tuIC0gM107XHJcbiAgICAgICAgICAgIHZhciByYWRpYW5zID0gKE1hdGguYXRhbjIoZHksIGR4KSArIFBJMikgJSBQSTI7XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLnBvaW50ZXJMZW5ndGgoKTtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5wb2ludGVyV2lkdGgoKTtcclxuXHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShwb2ludHNbbiAtIDJdLCBwb2ludHNbbiAtIDFdKTtcclxuICAgICAgICAgICAgY3R4LnJvdGF0ZShyYWRpYW5zKTtcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbygwLCAwKTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbygtbGVuZ3RoLCB3aWR0aCAvIDIpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKC1sZW5ndGgsIC13aWR0aCAvIDIpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5wb2ludGVyQXRCZWdpbm5pbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xyXG4gICAgICAgICAgICAgICAgZHggPSBwb2ludHNbMl0gLSBwb2ludHNbMF07XHJcbiAgICAgICAgICAgICAgICBkeSA9IHBvaW50c1szXSAtIHBvaW50c1sxXTtcclxuICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoKE1hdGguYXRhbjIoLWR5LCAtZHgpICsgUEkyKSAlIFBJMik7XHJcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKDAsIDApO1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbygtMTAsIDYpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbygtMTAsIC02KTtcclxuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGN0eC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XHJcbiAgICAgICAgICAgIEtvbnZhLkxpbmUucHJvdG90eXBlLl9zY2VuZUZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkFycm93LCBLb252YS5MaW5lKTtcclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBwb2ludGVyTGVuZ3RoXHJcbiAgICAgKiBAbmFtZSBwb2ludGVyTGVuZ3RoXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQXJyb3cucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gTGVuZ3RoIG9mIHBvaW50ZXIgb2YgYXJyb3cuXHJcbiAgICAgKiAgIFRoZSBkZWZhdWx0IGlzIDEwLlxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgdGVuc2lvblxyXG4gICAgICogdmFyIHBvaW50ZXJMZW5ndGggPSBsaW5lLnBvaW50ZXJMZW5ndGgoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgdGVuc2lvblxyXG4gICAgICogbGluZS5wb2ludGVyTGVuZ3RoKDE1KTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkFycm93LCAncG9pbnRlckxlbmd0aCcsIDEwKTtcclxuICAgIC8qKlxyXG4gICAgICogZ2V0L3NldCBwb2ludGVyV2lkdGhcclxuICAgICAqIEBuYW1lIHBvaW50ZXJXaWR0aFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkFycm93LnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFdpZHRoIG9mIHBvaW50ZXIgb2YgYXJyb3cuXHJcbiAgICAgKiAgIFRoZSBkZWZhdWx0IGlzIDEwLlxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgdGVuc2lvblxyXG4gICAgICogdmFyIHBvaW50ZXJXaWR0aCA9IGxpbmUucG9pbnRlcldpZHRoKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IHRlbnNpb25cclxuICAgICAqIGxpbmUucG9pbnRlcldpZHRoKDE1KTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkFycm93LCAncG9pbnRlcldpZHRoJywgMTApO1xyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQvc2V0IHBvaW50ZXJBdEJlZ2lubmluZ1xyXG4gICAgICogQG5hbWUgcG9pbnRlckF0QmVnaW5uaW5nXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQXJyb3cucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gU2hvdWxkIHBvaW50ZXIgZGlzcGxheWVkIGF0IGJlZ2lubmluZyBvZiBhcnJvdy5cclxuICAgICAqICAgVGhlIGRlZmF1bHQgaXMgZmFsc2UuXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBnZXQgdGVuc2lvblxyXG4gICAgICogdmFyIHBvaW50ZXJBdEJlZ2lubmluZyA9IGxpbmUucG9pbnRlckF0QmVnaW5uaW5nKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gc2V0IHRlbnNpb25cclxuICAgICAqIGxpbmUucG9pbnRlckF0QmVnaW5uaW5nKHRydWUpO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuQXJyb3csICdwb2ludGVyQXRCZWdpbm5pbmcnLCBmYWxzZSk7XHJcbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuQXJyb3cpO1xyXG5cclxufSkoKTtcclxuXHJcbiIsImltcG9ydCBLb252YSBmcm9tICdrb252YSc7XG5cbmZ1bmN0aW9uIHBsYXlBbmltYXRpb24ocGxheWVySGFuZCwgYWlIYW5kLCBvdXRjb21lKSB7XG4gIGNvbnN0IGhhbmRDb2xvcnMgPSB7XG4gICAgcm9jazogJyM4YTRjNDEnLFxuICAgIHNjaXNzb3JzOiAnI2M1Y2FlOScsXG4gICAgcGFwZXI6ICcjZmZlMTlmJyxcbiAgICBsaXphcmQ6ICcjMDBjMThhJyxcbiAgICBzcG9jazogJyM3NDhlYmQnXG4gIH1cblxuICBjb25zdCBoZXhSYWRpdXMgPSA3NTtcblxuICBsZXQgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jlc3VsdHMnKTtcbiAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gIGxldCBzdGFnZSA9IG5ldyBLb252YS5TdGFnZSh7XG4gICAgY29udGFpbmVyOiAncmVzdWx0cycsXG4gICAgd2lkdGg6IGNvbnRhaW5lci5vZmZzZXRXaWR0aCxcbiAgICBoZWlnaHQ6IGNvbnRhaW5lci5vZmZzZXRIZWlnaHRcbiAgfSk7XG5cbiAgbGV0IGJhY2tncm91bmQgPSBuZXcgS29udmEuTGF5ZXIoKTtcbiAgbGV0IGZvcmVncm91bmQgPSBuZXcgS29udmEuTGF5ZXIoeyBvZmZzZXQ6IHsgeTogMzUgfSB9KTtcbiAgbGV0IG92ZXJsYXkgPSBuZXcgS29udmEuTGF5ZXIoKTtcblxuICBsZXQgbGVmdCA9IG5ldyBLb252YS5Hcm91cCh7XG4gICAgeDogLShoZXhSYWRpdXMgKiAzKSxcbiAgICB5OiAoc3RhZ2UuaGVpZ2h0KCkgLyAyKSAtIChoZXhSYWRpdXMgKiAwLjc1KSAtIDMsXG4gIH0pO1xuICBsZXQgcmlnaHQgPSBuZXcgS29udmEuR3JvdXAoe1xuICAgIHg6IHN0YWdlLndpZHRoKCkgKyAoaGV4UmFkaXVzICogMyksXG4gICAgeTogKHN0YWdlLmhlaWdodCgpIC8gMikgKyAoaGV4UmFkaXVzICogMC43NSkgKyAzLFxuICB9KTtcblxuICBsZXQgYmFja2dyb3VuZEZpbGwgPSBuZXcgS29udmEuUmVjdCh7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHdpZHRoOiBzdGFnZS53aWR0aCgpLFxuICAgIGhlaWdodDogc3RhZ2UuaGVpZ2h0KCksXG4gICAgZmlsbDogJ3JnYmEoNTAsIDYwLCA4MCwgMSknXG4gIH0pO1xuXG4gIGxldCBoZXhMID0gbmV3IEtvbnZhLlJlZ3VsYXJQb2x5Z29uKHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgcmFkaXVzOiBoZXhSYWRpdXMsXG4gICAgc2lkZXM6IDYsXG4gICAgc3Ryb2tlOiBoYW5kQ29sb3JzW3BsYXllckhhbmRdLFxuICAgIHN0cm9rZVdpZHRoOiA2LFxuICAgIGZpbGw6ICdyZ2JhKDAsIDAsIDAsIDAuNSknXG4gIH0pO1xuICBsZXQgaGV4UiA9IG5ldyBLb252YS5SZWd1bGFyUG9seWdvbih7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHJhZGl1czogaGV4UmFkaXVzLFxuICAgIHNpZGVzOiA2LFxuICAgIHN0cm9rZTogaGFuZENvbG9yc1thaUhhbmRdLFxuICAgIHN0cm9rZVdpZHRoOiA2LFxuICAgIGZpbGw6ICdyZ2JhKDAsIDAsIDAsIDAuNSknXG4gIH0pO1xuXG4gIGxldCBwbGF5ZXJJbWdFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbWctJyArIHBsYXllckhhbmQpO1xuICBsZXQgcGxheWVySW1nID0gbmV3IEtvbnZhLkltYWdlKHtcbiAgICB4OiAtNTAsXG4gICAgeTogLTUwLFxuICAgIGltYWdlOiBwbGF5ZXJJbWdFbCxcbiAgICB3aWR0aDogMTAwLFxuICAgIGhlaWdodDogMTAwXG4gIH0pO1xuXG4gIGxldCBhaUltZ0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ltZy0nICsgYWlIYW5kKTtcbiAgbGV0IGFpSW1nID0gbmV3IEtvbnZhLkltYWdlKHtcbiAgICB4OiAtNTAsXG4gICAgeTogLTUwLFxuICAgIGltYWdlOiBhaUltZ0VsLFxuICAgIHdpZHRoOiAxMDAsXG4gICAgaGVpZ2h0OiAxMDBcbiAgfSk7XG5cbiAgbGV0IHRleHQgPSBuZXcgS29udmEuVGV4dCh7XG4gICAgeDogc3RhZ2Uud2lkdGgoKSAvIDIsXG4gICAgeTogc3RhZ2UuaGVpZ2h0KCkgKiAwLjgsXG4gICAgdGV4dDogb3V0Y29tZS5tZXNzYWdlLFxuICAgIGZvbnRGYW1pbHk6ICdMYXRvJyxcbiAgICBmb250U2l6ZTogMzIsXG4gICAgZmlsbDogJ2JsYWNrJyxcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgcGFkZGluZzogMTBcbiAgfSk7XG4gIHRleHQuc2V0T2Zmc2V0KHtcbiAgICB4OiB0ZXh0LndpZHRoKCkgLyAyXG4gIH0pO1xuXG4gIGxldCB0ZXh0Qm94ID0gbmV3IEtvbnZhLlJlY3Qoe1xuICAgIHg6IChzdGFnZS53aWR0aCgpIC8gMikgLSAodGV4dC53aWR0aCgpIC8gMikgLSAzMCxcbiAgICB5OiBzdGFnZS5oZWlnaHQoKSAqIDAuOCxcbiAgICB3aWR0aDogdGV4dC53aWR0aCgpICsgNjAsXG4gICAgaGVpZ2h0OiB0ZXh0LmhlaWdodCgpLFxuICAgIGZpbGw6ICd3aGl0ZScsXG4gICAgY29ybmVyUmFkaXVzOiAyLFxuICAgIHNoYWRvd0NvbG9yOiAnYmxhY2snLFxuICAgIHNoYWRvd0JsdXI6IDc1LFxuICAgIHNoYWRvd09wYWNpdHk6IDAuMlxuICB9KTtcblxuICBsZWZ0LmFkZChoZXhMLCBwbGF5ZXJJbWcpO1xuICByaWdodC5hZGQoaGV4UiwgYWlJbWcpO1xuICBiYWNrZ3JvdW5kLmFkZChiYWNrZ3JvdW5kRmlsbCk7XG4gIGZvcmVncm91bmQuYWRkKGxlZnQsIHJpZ2h0KTtcbiAgb3ZlcmxheS5hZGQodGV4dEJveCwgdGV4dCk7XG4gIHN0YWdlLmFkZChiYWNrZ3JvdW5kLCBmb3JlZ3JvdW5kLCBvdmVybGF5KTtcblxuICBuZXcgS29udmEuQW5pbWF0aW9uKGZ1bmN0aW9uKGZyYW1lKSB7XG4gICAgbGVmdC5zZXRYKGZyYW1lLnRpbWUgLyAxLjUpO1xuICAgIHJpZ2h0LnNldFgoc3RhZ2Uud2lkdGgoKSAtIGZyYW1lLnRpbWUgLyAxLjUpO1xuXG4gICAgaWYgKGxlZnQueCgpID49IChzdGFnZS53aWR0aCgpIC8gMikgLSAoaGV4UmFkaXVzIC8gMikgLSAzKSB7XG4gICAgICBsZWZ0LnNldFgoKHN0YWdlLndpZHRoKCkgLyAyKSAtIChoZXhSYWRpdXMgLyAyKSAtIDMpO1xuICAgICAgcmlnaHQuc2V0WCgoc3RhZ2Uud2lkdGgoKSAvIDIpICsgKGhleFJhZGl1cyAvIDIpICsgMyk7XG5cbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgb3V0Y29tZUFuaW1hdGlvbi5zdGFydCgpO1xuICAgIH1cbiAgfSwgc3RhZ2UpLnN0YXJ0KCk7XG5cbiAgbGV0IG91dGNvbWVBbmltYXRpb24gPSBuZXcgS29udmEuQW5pbWF0aW9uKGZ1bmN0aW9uKGZyYW1lKSB7XG4gICAgbGV0IHNjYWxlTW9kID0gZnJhbWUudGltZSAvIDMwMDA7XG5cbiAgICBpZiAob3V0Y29tZS5zdGF0ZSA9PSAnd2luJykge1xuICAgICAgaGV4TC5zY2FsZSh7IHg6IDEgKyBzY2FsZU1vZCwgeTogMSArIHNjYWxlTW9kIH0pO1xuICAgICAgaGV4Ui5zY2FsZSh7IHg6IDEgLSBzY2FsZU1vZCwgeTogMSAtIHNjYWxlTW9kIH0pO1xuICAgICAgcmlnaHQub3BhY2l0eSgxIC0gZnJhbWUudGltZSAvIDUwMCk7XG4gICAgfVxuICAgIGlmIChvdXRjb21lLnN0YXRlID09ICdsb3NlJykge1xuICAgICAgaGV4TC5zY2FsZSh7IHg6IDEgLSBzY2FsZU1vZCwgeTogMSAtIHNjYWxlTW9kIH0pO1xuICAgICAgaGV4Ui5zY2FsZSh7IHg6IDEgKyBzY2FsZU1vZCwgeTogMSArIHNjYWxlTW9kIH0pO1xuICAgICAgbGVmdC5vcGFjaXR5KDEgLSBmcmFtZS50aW1lIC8gNTAwKTtcbiAgICB9XG4gICAgaWYgKG91dGNvbWUuc3RhdGUgPT0gJ2RyYXcnKSB7XG4gICAgICBsZWZ0Lm9wYWNpdHkoMSAtIGZyYW1lLnRpbWUgLyA1MDApO1xuICAgICAgcmlnaHQub3BhY2l0eSgxIC0gZnJhbWUudGltZSAvIDUwMCk7XG4gICAgfVxuXG4gICAgaWYgKHNjYWxlTW9kID49IDAuMSkge1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfVxuICB9LCBzdGFnZSk7XG5cbiAgbGV0IHdhaXRUaGVuSGlkZVJlc3VsdCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH0sIDMwMDApO1xuXG4gIGZ1bmN0aW9uIGhpZGVSZXN1bHROb3coKSB7XG4gICAgY2xlYXJUaW1lb3V0KHdhaXRUaGVuSGlkZVJlc3VsdCk7XG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9XG5cbiAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGlkZVJlc3VsdE5vdyk7XG4gIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgaGlkZVJlc3VsdE5vdyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBsYXlBbmltYXRpb247XG4iLCJpbXBvcnQgKiBhcyB1dGlsaXR5IGZyb20gJy4vdXRpbGl0eSc7XG5pbXBvcnQgcGxheUFuaW1hdGlvbiBmcm9tICcuL2FuaW1hdGlvbic7XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZ2FtZSk7XG5cbmZ1bmN0aW9uIGdhbWUoKSB7XG4gIC8qKiBAdHlwZSB7T2JqZWN0fSAqKi9cbiAgY29uc3QgaGFuZHMgPSB7XG4gICAgcm9jazoge1xuICAgICAgZWw6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb2NrJyksXG4gICAgICBiZWF0czogWydzY2lzc29ycycsICdsaXphcmQnXVxuICAgIH0sXG4gICAgc2Npc3NvcnM6IHtcbiAgICAgIGVsOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2Npc3NvcnMnKSxcbiAgICAgIGJlYXRzOiBbJ3BhcGVyJywgJ2xpemFyZCddXG4gICAgfSxcbiAgICBwYXBlcjoge1xuICAgICAgZWw6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXBlcicpLFxuICAgICAgYmVhdHM6IFsncm9jaycsICdzcG9jayddXG4gICAgfSxcbiAgICBsaXphcmQ6IHtcbiAgICAgIGVsOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGl6YXJkJyksXG4gICAgICBiZWF0czogWydwYXBlcicsICdzcG9jayddXG4gICAgfSxcbiAgICBzcG9jazoge1xuICAgICAgZWw6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzcG9jaycpLFxuICAgICAgYmVhdHM6IFsnc2Npc3NvcnMnLCAncm9jayddXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJpbmQgYW4gZXZlbnQgdG8gZWFjaCBoYW5kIGVsZW1lbnQgc28gdGhhdCB3aGVuIGEgYnV0dG9uIGlzIGNsaWNrZWQgdGhhdFxuICAgKiBoYW5kIGlzIHBsYXllZC5cbiAgICovXG4gIGZvciAobGV0IGhhbmQgaW4gaGFuZHMpIHtcbiAgICBpZiAoaGFuZHMuaGFzT3duUHJvcGVydHkoaGFuZCkpIHtcbiAgICAgIGhhbmRzW2hhbmRdLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcGxheSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJpbmQgYW4gZXZlbnQgdG8gdGhlIHN0YXJ0IG1nZW51IGdhbWUgbW9kZSBidXR0b25zIHRvIHN0YXJ0IHRoZSBnYW1lLlxuICAgKlxuICAgKiBDdXJyZW50bHkgcHJlc3NpbmcgYW55IGdhbWUgbW9kZSBidXR0b24gd2lsbCBqdXN0IHJldmVhbCB0aGUgZ2FtZSB3aXRob3V0XG4gICAqIGFjdHVhbGx5IG1vZGlmeWluZyBhbnkgcnVsZXMuXG4gICAqL1xuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5maW5pdGUnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGFydC1tZW51Jykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2FtZScpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICB9KTtcblxuICAvKipcbiAgICogVGFrZSB0aGUgdXNlcidzIGlucHV0dGVkIGhhbmQsIGdlbmVyYXRlIHRoZSBBSSdzIGhhbmQsIGFuZCBwYXNzIHRoZW0gYWxvbmdcbiAgICogdG8gYmUganVkZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQge09iamVjdH1cbiAgICovXG4gIGZ1bmN0aW9uIHBsYXkoZXZlbnQpIHtcbiAgICBkZXRlcm1pbmVXaW5uZXIoXG4gICAgICBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWhhbmQnKSxcbiAgICAgIGNob29zZUFpSGFuZCgpLmdldEF0dHJpYnV0ZSgnZGF0YS1oYW5kJylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzaW5nIGEgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgcGljayBvbmUgb2YgdGhlIGhhbmRzIGZvciB0aGUgQUkgdG8gcGxheS5cbiAgICpcbiAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAqL1xuICBmdW5jdGlvbiBjaG9vc2VBaUhhbmQoKSB7XG4gICAgbGV0IGhhbmQgPSB1dGlsaXR5LnJhbmRvbVByb3BlcnR5KGhhbmRzKTtcbiAgICByZXR1cm4gaGFuZC5lbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgdGhlIHBsYXllciBoYXMgd29uLCBsb3N0IG9yIGRyYXduIHdpdGggdGhlIEFJLlxuICAgKlxuICAgKiBAcGFyYW0gcGxheWVySGFuZCB7c3RyaW5nfVxuICAgKiBAcGFyYW0gYWlIYW5kIHtzdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiBkZXRlcm1pbmVXaW5uZXIocGxheWVySGFuZCwgYWlIYW5kKSB7XG4gICAgLy8gRHJhd1xuICAgIGlmIChwbGF5ZXJIYW5kID09PSBhaUhhbmQpIHtcbiAgICAgIHBsYXlBbmltYXRpb24ocGxheWVySGFuZCwgYWlIYW5kLCB7IHN0YXRlOiAnZHJhdycsIG1lc3NhZ2U6ICdEcmF3JyB9KTtcbiAgICAgIHNjb3JlKDEsICdkcmF3cycpO1xuICAgIH1cbiAgICAvLyBXaW5cbiAgICBlbHNlIGlmIChoYW5kc1twbGF5ZXJIYW5kXS5iZWF0cy5pbmRleE9mKGFpSGFuZCkgPiAtMSkge1xuICAgICAgcGxheUFuaW1hdGlvbihwbGF5ZXJIYW5kLCBhaUhhbmQsIHsgc3RhdGU6ICd3aW4nLCBtZXNzYWdlOiAnWW91IHdpbiEnIH0pO1xuICAgICAgc2NvcmUoMSwgJ3BsYXllcicpO1xuICAgIH1cbiAgICAvLyBMb3NlXG4gICAgZWxzZSB7XG4gICAgICBwbGF5QW5pbWF0aW9uKHBsYXllckhhbmQsIGFpSGFuZCwgeyBzdGF0ZTogJ2xvc2UnLCBtZXNzYWdlOiAnWW91IGxvc2UnIH0pO1xuICAgICAgc2NvcmUoMSwgJ2FpJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBwb2ludHMgdG8gYSBwbGF5ZXIncyBzY29yZS5cbiAgICpcbiAgICogQHBhcmFtIGFtb3VudCB7bnVtYmVyfVxuICAgKiBAcGFyYW0gd2hvIHtzdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiBzY29yZShhbW91bnQsIHdobykge1xuICAgIGxldCBhbW91bnRFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgd2hvICsgJyA+IC5hbW91bnQnKVswXTtcbiAgICBhbW91bnRFbC5pbm5lckhUTUwgPSBOdW1iZXIoYW1vdW50RWwuaW5uZXJIVE1MKSArIGFtb3VudDtcbiAgfVxufVxuIiwiLyoqXG4gKiBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIHRoZSBwYXNzZWQgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0gbWluIHtudW1iZXJ9XG4gKiBAcGFyYW0gbWF4IHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tSW50KG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkgKyBtaW4pO1xufVxuXG4vKipcbiAqIFJldHVybiBhIHJhbmRvbSBwcm9wZXJ0eSBmcm9tIHRoZSBwYXNzZWQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBvYmplY3Qge29iamVjdH1cbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21Qcm9wZXJ0eShvYmplY3QpIHtcbiAgbGV0IHByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICBsZXQgaW5kZXggPSByYW5kb21JbnQoMCwgcHJvcGVydGllcy5sZW5ndGggLSAxKTtcbiAgbGV0IHByb3BlcnR5S2V5ID0gcHJvcGVydGllc1tpbmRleF07XG5cbiAgcmV0dXJuIG9iamVjdFtwcm9wZXJ0eUtleV07XG59XG4iXX0=
